// VeZ Runtime - Memory Allocator
// Production-grade memory allocator with multiple strategies

use std::mem::Layout;

// Global allocator interface
pub trait GlobalAlloc {
    unsafe fn alloc(&self, layout: Layout) -> *mut u8;
    unsafe fn dealloc(&self, ptr: *mut u8, layout: Layout);
    unsafe fn realloc(&self, ptr: *mut u8, layout: Layout, new_size: usize) -> *mut u8;
    unsafe fn alloc_zeroed(&self, layout: Layout) -> *mut u8;
}

// System allocator (uses OS malloc/free)
pub struct System;

impl GlobalAlloc for System {
    unsafe fn alloc(&self, layout: Layout) -> *mut u8 {
        extern "C" {
            fn malloc(size: usize) -> *mut u8;
        }
        
        if layout.size() == 0 {
            return layout.align() as *mut u8;
        }
        
        malloc(layout.size())
    }
    
    unsafe fn dealloc(&self, ptr: *mut u8, layout: Layout) {
        extern "C" {
            fn free(ptr: *mut u8);
        }
        
        if layout.size() != 0 {
            free(ptr);
        }
    }
    
    unsafe fn realloc(&self, ptr: *mut u8, layout: Layout, new_size: usize) -> *mut u8 {
        extern "C" {
            fn realloc(ptr: *mut u8, size: usize) -> *mut u8;
        }
        
        if new_size == 0 {
            self.dealloc(ptr, layout);
            return layout.align() as *mut u8;
        }
        
        realloc(ptr, new_size)
    }
    
    unsafe fn alloc_zeroed(&self, layout: Layout) -> *mut u8 {
        extern "C" {
            fn calloc(nmemb: usize, size: usize) -> *mut u8;
        }
        
        if layout.size() == 0 {
            return layout.align() as *mut u8;
        }
        
        calloc(1, layout.size())
    }
}

// Arena allocator for fast bulk allocations
pub struct Arena {
    ptr: *mut u8,
    capacity: usize,
    used: usize,
}

impl Arena {
    pub fn new(capacity: usize) -> Arena {
        let layout = Layout::from_size_align(capacity, 8).unwrap();
        let ptr = unsafe { System.alloc(layout) };
        
        Arena {
            ptr,
            capacity,
            used: 0,
        }
    }
    
    pub fn alloc(&mut self, layout: Layout) -> *mut u8 {
        let align = layout.align();
        let size = layout.size();
        
        // Align the current position
        let aligned = (self.used + align - 1) & !(align - 1);
        
        if aligned + size > self.capacity {
            panic!("Arena out of memory");
        }
        
        let ptr = unsafe { self.ptr.add(aligned) };
        self.used = aligned + size;
        ptr
    }
    
    pub fn reset(&mut self) {
        self.used = 0;
    }
    
    pub fn clear(&mut self) {
        unsafe {
            let layout = Layout::from_size_align(self.capacity, 8).unwrap();
            System.dealloc(self.ptr, layout);
        }
        self.ptr = null_mut();
        self.used = 0;
        self.capacity = 0;
    }
}

impl Drop for Arena {
    fn drop(&mut self) {
        if !self.ptr.is_null() {
            self.clear();
        }
    }
}

// Pool allocator for fixed-size allocations
pub struct Pool<T> {
    blocks: Vec<*mut T>,
    free_list: Vec<*mut T>,
    block_size: usize,
}

impl<T> Pool<T> {
    pub fn new(block_size: usize) -> Pool<T> {
        Pool {
            blocks: Vec::new(),
            free_list: Vec::new(),
            block_size,
        }
    }
    
    pub fn alloc(&mut self) -> *mut T {
        if let Some(ptr) = self.free_list.pop() {
            return ptr;
        }
        
        // Allocate new block
        let layout = Layout::array::<T>(self.block_size).unwrap();
        let ptr = unsafe { System.alloc(layout) as *mut T };
        self.blocks.push(ptr);
        
        // Add remaining slots to free list
        for i in 1..self.block_size {
            unsafe {
                self.free_list.push(ptr.add(i));
            }
        }
        
        ptr
    }
    
    pub fn dealloc(&mut self, ptr: *mut T) {
        self.free_list.push(ptr);
    }
}

impl<T> Drop for Pool<T> {
    fn drop(&mut self) {
        for block in self.blocks.iter() {
            let layout = Layout::array::<T>(self.block_size).unwrap();
            unsafe {
                System.dealloc(*block as *mut u8, layout);
            }
        }
    }
}

// Global allocator instance
#[global_allocator]
static GLOBAL: System = System;

// Allocation statistics
pub struct AllocStats {
    pub allocations: usize,
    pub deallocations: usize,
    pub bytes_allocated: usize,
    pub bytes_deallocated: usize,
    pub peak_memory: usize,
}

static mut ALLOC_STATS: AllocStats = AllocStats {
    allocations: 0,
    deallocations: 0,
    bytes_allocated: 0,
    bytes_deallocated: 0,
    peak_memory: 0,
};

pub fn get_alloc_stats() -> &'static AllocStats {
    unsafe { &ALLOC_STATS }
}

pub fn reset_alloc_stats() {
    unsafe {
        ALLOC_STATS = AllocStats {
            allocations: 0,
            deallocations: 0,
            bytes_allocated: 0,
            bytes_deallocated: 0,
            peak_memory: 0,
        };
    }
}
