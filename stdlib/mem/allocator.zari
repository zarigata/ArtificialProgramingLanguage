// Memory allocator interface

use core::ptr::null_mut;

// Memory layout descriptor
pub struct Layout {
    size: usize,
    align: usize,
}

impl Layout {
    // Create a layout for a type
    pub fn new<T>() -> Layout {
        Layout {
            size: size_of::<T>(),
            align: align_of::<T>(),
        }
    }
    
    // Create a layout for an array
    pub fn array<T>(n: usize) -> Layout {
        Layout {
            size: size_of::<T>() * n,
            align: align_of::<T>(),
        }
    }
    
    // Create a layout from size and alignment
    pub fn from_size_align(size: usize, align: usize) -> Result<Layout, ()> {
        if align == 0 || !align.is_power_of_two() {
            return Err(());
        }
        
        Ok(Layout { size, align })
    }
    
    // Get the size
    pub fn size(&self) -> usize {
        self.size
    }
    
    // Get the alignment
    pub fn align(&self) -> usize {
        self.align
    }
    
    // Pad the layout to alignment
    pub fn pad_to_align(&self) -> Layout {
        let len = self.size;
        let len_rounded_up = (len + self.align - 1) & !(self.align - 1);
        Layout {
            size: len_rounded_up,
            align: self.align,
        }
    }
}

// Global allocator functions
extern "C" {
    fn malloc(size: usize) -> *mut u8;
    fn free(ptr: *mut u8);
    fn realloc(ptr: *mut u8, size: usize) -> *mut u8;
    fn calloc(nmemb: usize, size: usize) -> *mut u8;
}

// Allocate memory with the given layout
pub unsafe fn alloc(layout: Layout) -> *mut u8 {
    malloc(layout.size())
}

// Allocate zeroed memory with the given layout
pub unsafe fn alloc_zeroed(layout: Layout) -> *mut u8 {
    calloc(1, layout.size())
}

// Deallocate memory
pub unsafe fn dealloc(ptr: *mut u8, layout: Layout) {
    free(ptr);
}

// Reallocate memory
pub unsafe fn realloc_memory(ptr: *mut u8, old_layout: Layout, new_size: usize) -> *mut u8 {
    realloc(ptr, new_size)
}

// Box: heap-allocated value
pub struct Box<T> {
    ptr: *mut T,
}

impl<T> Box<T> {
    // Create a new box
    pub fn new(value: T) -> Box<T> {
        let layout = Layout::new::<T>();
        let ptr = unsafe { alloc(layout) as *mut T };
        
        if ptr.is_null() {
            panic!("allocation failed");
        }
        
        unsafe {
            write(ptr, value);
        }
        
        Box { ptr }
    }
    
    // Get a reference to the value
    pub fn as_ref(&self) -> &T {
        unsafe { &*self.ptr }
    }
    
    // Get a mutable reference to the value
    pub fn as_mut(&mut self) -> &mut T {
        unsafe { &mut *self.ptr }
    }
    
    // Leak the box, returning a mutable reference
    pub fn leak(self) -> &'static mut T {
        let ptr = self.ptr;
        forget(self);
        unsafe { &mut *ptr }
    }
}

impl<T> Drop for Box<T> {
    fn drop(&mut self) {
        unsafe {
            drop_in_place(self.ptr);
            let layout = Layout::new::<T>();
            dealloc(self.ptr as *mut u8, layout);
        }
    }
}

impl<T> Deref for Box<T> {
    type Target = T;
    
    fn deref(&self) -> &T {
        self.as_ref()
    }
}

impl<T> DerefMut for Box<T> {
    fn deref_mut(&mut self) -> &mut T {
        self.as_mut()
    }
}

impl<T: Clone> Clone for Box<T> {
    fn clone(&self) -> Box<T> {
        Box::new(self.as_ref().clone())
    }
}

impl<T: Display> Display for Box<T> {
    fn display(&self) -> String {
        self.as_ref().display()
    }
}

impl<T: Debug> Debug for Box<T> {
    fn debug(&self) -> String {
        format!("Box({:?})", self.as_ref())
    }
}

// Reference counting pointer
pub struct Rc<T> {
    ptr: *mut RcBox<T>,
}

struct RcBox<T> {
    value: T,
    strong: usize,
}

impl<T> Rc<T> {
    // Create a new reference-counted pointer
    pub fn new(value: T) -> Rc<T> {
        let layout = Layout::new::<RcBox<T>>();
        let ptr = unsafe { alloc(layout) as *mut RcBox<T> };
        
        if ptr.is_null() {
            panic!("allocation failed");
        }
        
        unsafe {
            write(ptr, RcBox {
                value,
                strong: 1,
            });
        }
        
        Rc { ptr }
    }
    
    // Get the strong reference count
    pub fn strong_count(&self) -> usize {
        unsafe { (*self.ptr).strong }
    }
    
    // Get a reference to the value
    pub fn as_ref(&self) -> &T {
        unsafe { &(*self.ptr).value }
    }
}

impl<T> Clone for Rc<T> {
    fn clone(&self) -> Rc<T> {
        unsafe {
            (*self.ptr).strong += 1;
        }
        Rc { ptr: self.ptr }
    }
}

impl<T> Drop for Rc<T> {
    fn drop(&mut self) {
        unsafe {
            (*self.ptr).strong -= 1;
            if (*self.ptr).strong == 0 {
                drop_in_place(&mut (*self.ptr).value);
                let layout = Layout::new::<RcBox<T>>();
                dealloc(self.ptr as *mut u8, layout);
            }
        }
    }
}

impl<T> Deref for Rc<T> {
    type Target = T;
    
    fn deref(&self) -> &T {
        self.as_ref()
    }
}

impl<T: Display> Display for Rc<T> {
    fn display(&self) -> String {
        self.as_ref().display()
    }
}

impl<T: Debug> Debug for Rc<T> {
    fn debug(&self) -> String {
        format!("Rc({:?})", self.as_ref())
    }
}

// Utility functions
pub fn size_of<T>() -> usize {
    core::mem::size_of::<T>()
}

pub fn align_of<T>() -> usize {
    core::mem::align_of::<T>()
}

pub fn forget<T>(value: T) {
    core::mem::forget(value)
}

pub unsafe fn drop_in_place<T>(ptr: *mut T) {
    core::ptr::drop_in_place(ptr)
}

pub fn swap<T>(a: &mut T, b: &mut T) {
    unsafe {
        let tmp = read(a);
        write(a, read(b));
        write(b, tmp);
    }
}

pub fn replace<T>(dest: &mut T, src: T) -> T {
    unsafe {
        let old = read(dest);
        write(dest, src);
        old
    }
}
