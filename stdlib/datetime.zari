## DateTime Module
## Provides comprehensive date and time manipulation functions

## Time units for duration calculations
enum TimeUnit:
    Nanoseconds
    Microseconds
    Milliseconds
    Seconds
    Minutes
    Hours
    Days
    Weeks

## Duration represents a span of time
struct Duration:
    nanoseconds: i64
    
    def __init__(self, ns: i64):
        self.nanoseconds = ns
    
    def from_nanos(ns: i64) -> Duration:
        return Duration(ns)
    
    def from_micros(us: i64) -> Duration:
        return Duration(us * 1000)
    
    def from_millis(ms: i64) -> Duration:
        return Duration(ms * 1_000_000)
    
    def from_secs(s: i64) -> Duration:
        return Duration(s * 1_000_000_000)
    
    def from_minutes(m: i64) -> Duration:
        return Duration.from_secs(m * 60)
    
    def from_hours(h: i64) -> Duration:
        return Duration.from_minutes(h * 60)
    
    def from_days(d: i64) -> Duration:
        return Duration.from_hours(d * 24)
    
    def from_weeks(w: i64) -> Duration:
        return Duration.from_days(w * 7)
    
    def as_nanos(self) -> i64:
        return self.nanoseconds
    
    def as_micros(self) -> i64:
        return self.nanoseconds / 1000
    
    def as_millis(self) -> i64:
        return self.nanoseconds / 1_000_000
    
    def as_secs(self) -> i64:
        return self.nanoseconds / 1_000_000_000
    
    def as_minutes(self) -> i64:
        return self.as_secs() / 60
    
    def as_hours(self) -> i64:
        return self.as_minutes() / 60
    
    def as_days(self) -> i64:
        return self.as_hours() / 24
    
    def __add__(self, other: Duration) -> Duration:
        return Duration(self.nanoseconds + other.nanoseconds)
    
    def __sub__(self, other: Duration) -> Duration:
        return Duration(self.nanoseconds - other.nanoseconds)
    
    def __mul__(self, factor: i64) -> Duration:
        return Duration(self.nanoseconds * factor)
    
    def __truediv__(self, divisor: i64) -> Duration:
        return Duration(self.nanoseconds / divisor)
    
    def __eq__(self, other: Duration) -> bool:
        return self.nanoseconds == other.nanoseconds
    
    def __lt__(self, other: Duration) -> bool:
        return self.nanoseconds < other.nanoseconds
    
    def __le__(self, other: Duration) -> bool:
        return self.nanoseconds <= other.nanoseconds
    
    def __gt__(self, other: Duration) -> bool:
        return self.nanoseconds > other.nanoseconds
    
    def __ge__(self, other: Duration) -> bool:
        return self.nanoseconds >= other.nanoseconds
    
    def is_zero(self) -> bool:
        return self.nanoseconds == 0
    
    def __str__(self) -> string:
        if self.nanoseconds >= 1_000_000_000:
            return format("{}s", self.as_secs())
        elif self.nanoseconds >= 1_000_000:
            return format("{}ms", self.as_millis())
        elif self.nanoseconds >= 1_000:
            return format("{}Î¼s", self.as_micros())
        else:
            return format("{}ns", self.nanoseconds)


## Date represents a calendar date (year, month, day)
struct Date:
    year: i32
    month: u8    # 1-12
    day: u8      # 1-31
    
    def __init__(self, year: i32, month: u8, day: u8):
        self.year = year
        self.month = month
        self.day = day
    
    def today() -> Date:
        # Returns current date from system time
        return Date.from_timestamp(now())
    
    def from_timestamp(ts: i64) -> Date:
        # Convert Unix timestamp to date
        days = ts / 86400
        return Date.from_days_since_epoch(days)
    
    def from_days_since_epoch(days: i64) -> Date:
        # Algorithm to convert days since epoch to date
        z = days + 719468
        era = z / 146097
        doe = z - era * 146097
        yoe = (doe - doe / 1460 + doe / 36524 - doe / 146096) / 365
        y = yoe + era * 400
        doy = doe - (365 * yoe + yoe / 4 - yoe / 100)
        mp = (5 * doy + 2) / 153
        d = doy - (153 * mp + 2) / 5 + 1
        m = mp + if mp < 10 then 3 else -9
        year = y + if m <= 2 then 1 else 0
        return Date(year, m, d)
    
    def to_timestamp(self) -> i64:
        return self.days_since_epoch() * 86400
    
    def days_since_epoch(self) -> i64:
        # Convert date to days since Unix epoch (1970-01-01)
        y = self.year
        m = self.month
        d = self.day
        
        if m <= 2:
            y -= 1
            m += 12
        
        era = y / 400
        yoe = y - era * 400
        doy = (153 * (m - 3) + 2) / 5 + d - 1
        doe = yoe * 365 + yoe / 4 - yoe / 100 + doy
        return era * 146097 + doe - 719468
    
    def is_leap_year(self) -> bool:
        return (self.year % 4 == 0 and self.year % 100 != 0) or self.year % 400 == 0
    
    def days_in_month(self) -> u8:
        if self.month in [1, 3, 5, 7, 8, 10, 12]:
            return 31
        elif self.month in [4, 6, 9, 11]:
            return 30
        elif self.month == 2:
            return if self.is_leap_year() then 29 else 28
        return 0
    
    def day_of_week(self) -> u8:
        # Returns 0=Sunday, 1=Monday, ..., 6=Saturday
        days = self.days_since_epoch()
        return (days + 4) % 7
    
    def day_of_year(self) -> u16:
        month_days = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334]
        doy = month_days[self.month - 1] + self.day
        if self.month > 2 and self.is_leap_year():
            doy += 1
        return doy
    
    def week_of_year(self) -> u8:
        doy = self.day_of_year()
        dow = self.day_of_week()
        week = (doy - dow + 10) / 7
        return week
    
    def quarter(self) -> u8:
        return (self.month - 1) / 3 + 1
    
    def is_weekend(self) -> bool:
        dow = self.day_of_week()
        return dow == 0 or dow == 6
    
    def is_weekday(self) -> bool:
        return not self.is_weekend()
    
    def __add__(self, duration: Duration) -> Date:
        days = duration.as_days()
        return Date.from_days_since_epoch(self.days_since_epoch() + days)
    
    def __sub__(self, duration: Duration) -> Date:
        days = duration.as_days()
        return Date.from_days_since_epoch(self.days_since_epoch() - days)
    
    def __eq__(self, other: Date) -> bool:
        return self.year == other.year and self.month == other.month and self.day == other.day
    
    def __lt__(self, other: Date) -> bool:
        if self.year != other.year:
            return self.year < other.year
        if self.month != other.month:
            return self.month < other.month
        return self.day < other.day
    
    def __le__(self, other: Date) -> bool:
        return self == other or self < other
    
    def __gt__(self, other: Date) -> bool:
        return not self <= other
    
    def __ge__(self, other: Date) -> bool:
        return not self < other
    
    def format(self, fmt: string) -> string:
        result = ""
        i = 0
        while i < len(fmt):
            if char_at(fmt, i) == '%' and i + 1 < len(fmt):
                spec = char_at(fmt, i + 1)
                if spec == 'Y':
                    result += str(self.year)
                elif spec == 'y':
                    result += str(self.year % 100).pad_left(2, '0')
                elif spec == 'm':
                    result += str(self.month).pad_left(2, '0')
                elif spec == 'd':
                    result += str(self.day).pad_left(2, '0')
                elif spec == 'B':
                    month_names = ["January", "February", "March", "April", "May", "June",
                                   "July", "August", "September", "October", "November", "December"]
                    result += month_names[self.month - 1]
                elif spec == 'b':
                    month_abbr = ["Jan", "Feb", "Mar", "Apr", "May", "Jun",
                                  "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
                    result += month_abbr[self.month - 1]
                elif spec == 'A':
                    day_names = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"]
                    result += day_names[self.day_of_week()]
                elif spec == 'a':
                    day_abbr = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"]
                    result += day_abbr[self.day_of_week()]
                elif spec == 'w':
                    result += str(self.day_of_week())
                elif spec == 'j':
                    result += str(self.day_of_year()).pad_left(3, '0')
                elif spec == 'U':
                    result += str(self.week_of_year()).pad_left(2, '0')
                elif spec == 'q':
                    result += str(self.quarter())
                else:
                    result += char_at(fmt, i)
                    result += spec
                i += 2
            else:
                result += char_at(fmt, i)
                i += 1
        return result
    
    def __str__(self) -> string:
        return self.format("%Y-%m-%d")


## Time represents a time of day (hour, minute, second, nanosecond)
struct Time:
    hour: u8       # 0-23
    minute: u8     # 0-59
    second: u8     # 0-59
    nanosecond: u32  # 0-999,999,999
    
    def __init__(self, hour: u8, minute: u8, second: u8 = 0, nanosecond: u32 = 0):
        self.hour = hour
        self.minute = minute
        self.second = second
        self.nanosecond = nanosecond
    
    def midnight() -> Time:
        return Time(0, 0, 0, 0)
    
    def noon() -> Time:
        return Time(12, 0, 0, 0)
    
    def now() -> Time:
        return Time.from_timestamp(now() % 86400)
    
    def from_timestamp(ts: i64) -> Time:
        secs = ts % 86400
        hour = secs / 3600
        minute = (secs % 3600) / 60
        second = secs % 60
        return Time(hour, minute, second, 0)
    
    def from_duration(d: Duration) -> Time:
        total_secs = d.as_secs() % 86400
        hour = total_secs / 3600
        minute = (total_secs % 3600) / 60
        second = total_secs % 60
        nanosecond = d.as_nanos() % 1_000_000_000
        return Time(hour, minute, second, nanosecond)
    
    def to_duration(self) -> Duration:
        total_nanos = self.nanosecond
        total_nanos += self.second * 1_000_000_000
        total_nanos += self.minute * 60 * 1_000_000_000
        total_nanos += self.hour * 3600 * 1_000_000_000
        return Duration(total_nanos)
    
    def to_timestamp(self) -> i64:
        return self.hour * 3600 + self.minute * 60 + self.second
    
    def is_am(self) -> bool:
        return self.hour < 12
    
    def is_pm(self) -> bool:
        return self.hour >= 12
    
    def hour_12(self) -> u8:
        h = self.hour % 12
        return if h == 0 then 12 else h
    
    def __add__(self, duration: Duration) -> Time:
        total = self.to_duration() + duration
        return Time.from_duration(total)
    
    def __sub__(self, duration: Duration) -> Time:
        total = self.to_duration() - duration
        return Time.from_duration(total)
    
    def __eq__(self, other: Time) -> bool:
        return self.hour == other.hour and self.minute == other.minute and \
               self.second == other.second and self.nanosecond == other.nanosecond
    
    def __lt__(self, other: Time) -> bool:
        if self.hour != other.hour:
            return self.hour < other.hour
        if self.minute != other.minute:
            return self.minute < other.minute
        if self.second != other.second:
            return self.second < other.second
        return self.nanosecond < other.nanosecond
    
    def __le__(self, other: Time) -> bool:
        return self == other or self < other
    
    def __gt__(self, other: Time) -> bool:
        return not self <= other
    
    def __ge__(self, other: Time) -> bool:
        return not self < other
    
    def format(self, fmt: string) -> string:
        result = ""
        i = 0
        while i < len(fmt):
            if char_at(fmt, i) == '%' and i + 1 < len(fmt):
                spec = char_at(fmt, i + 1)
                if spec == 'H':
                    result += str(self.hour).pad_left(2, '0')
                elif spec == 'I':
                    result += str(self.hour_12()).pad_left(2, '0')
                elif spec == 'M':
                    result += str(self.minute).pad_left(2, '0')
                elif spec == 'S':
                    result += str(self.second).pad_left(2, '0')
                elif spec == 'f':
                    result += str(self.nanosecond).pad_left(9, '0')
                elif spec == 'p':
                    result += if self.is_am() then "AM" else "PM"
                elif spec == 'P':
                    result += if self.is_am() then "am" else "pm"
                else:
                    result += char_at(fmt, i)
                    result += spec
                i += 2
            else:
                result += char_at(fmt, i)
                i += 1
        return result
    
    def __str__(self) -> string:
        return self.format("%H:%M:%S")


## DateTime represents a specific point in time
struct DateTime:
    date: Date
    time: Time
    
    def __init__(self, date: Date, time: Time):
        self.date = date
        self.time = time
    
    def __init__(self, year: i32, month: u8, day: u8, hour: u8 = 0, minute: u8 = 0, second: u8 = 0, nanosecond: u32 = 0):
        self.date = Date(year, month, day)
        self.time = Time(hour, minute, second, nanosecond)
    
    def now() -> DateTime:
        ts = now()
        return DateTime.from_timestamp(ts)
    
    def from_timestamp(ts: i64) -> DateTime:
        date = Date.from_timestamp(ts)
        time = Time.from_timestamp(ts)
        return DateTime(date, time)
    
    def from_iso8601(s: string) -> DateTime:
        # Parse ISO 8601 format: YYYY-MM-DDTHH:MM:SS
        # Basic validation
        if len(s) < 10:
            return DateTime(1970, 1, 1)
        
        year = to_int(slice(s, 0, 4))
        month = to_int(slice(s, 5, 7))
        day = to_int(slice(s, 8, 10))
        
        hour = 0
        minute = 0
        second = 0
        
        if len(s) >= 19 and char_at(s, 10) == 'T':
            hour = to_int(slice(s, 11, 13))
            minute = to_int(slice(s, 14, 16))
            second = to_int(slice(s, 17, 19))
        
        return DateTime(year, month, day, hour, minute, second)
    
    def to_timestamp(self) -> i64:
        return self.date.to_timestamp() + self.time.to_timestamp()
    
    def to_iso8601(self) -> string:
        return format("{}T{}", self.date, self.time)
    
    def year(self) -> i32:
        return self.date.year
    
    def month(self) -> u8:
        return self.date.month
    
    def day(self) -> u8:
        return self.date.day
    
    def hour(self) -> u8:
        return self.time.hour
    
    def minute(self) -> u8:
        return self.time.minute
    
    def second(self) -> u8:
        return self.time.second
    
    def nanosecond(self) -> u32:
        return self.time.nanosecond
    
    def day_of_week(self) -> u8:
        return self.date.day_of_week()
    
    def day_of_year(self) -> u16:
        return self.date.day_of_year()
    
    def week_of_year(self) -> u8:
        return self.date.week_of_year()
    
    def quarter(self) -> u8:
        return self.date.quarter()
    
    def is_weekend(self) -> bool:
        return self.date.is_weekend()
    
    def is_weekday(self) -> bool:
        return self.date.is_weekday()
    
    def __add__(self, duration: Duration) -> DateTime:
        new_ts = self.to_timestamp() + duration.as_secs()
        new_ns = self.time.nanosecond + (duration.as_nanos() % 1_000_000_000)
        if new_ns >= 1_000_000_000:
            new_ts += 1
            new_ns -= 1_000_000_000
        result = DateTime.from_timestamp(new_ts)
        result.time.nanosecond = new_ns
        return result
    
    def __sub__(self, duration: Duration) -> DateTime:
        return self + (duration * -1)
    
    def __eq__(self, other: DateTime) -> bool:
        return self.date == other.date and self.time == other.time
    
    def __lt__(self, other: DateTime) -> bool:
        if self.date != other.date:
            return self.date < other.date
        return self.time < other.time
    
    def __le__(self, other: DateTime) -> bool:
        return self == other or self < other
    
    def __gt__(self, other: DateTime) -> bool:
        return not self <= other
    
    def __ge__(self, other: DateTime) -> bool:
        return not self < other
    
    def format(self, fmt: string) -> string:
        # Combine date and time formatting
        result = ""
        i = 0
        while i < len(fmt):
            if char_at(fmt, i) == '%' and i + 1 < len(fmt):
                spec = char_at(fmt, i + 1)
                # Date formats
                if spec in 'YymdBbAwjUq':
                    result += self.date.format('%' + spec)
                # Time formats
                elif spec in 'HIMSfpP':
                    result += self.time.format('%' + spec)
                else:
                    result += char_at(fmt, i)
                    result += spec
                i += 2
            else:
                result += char_at(fmt, i)
                i += 1
        return result
    
    def __str__(self) -> string:
        return self.to_iso8601()


## Time zone representation
struct TimeZone:
    name: string
    offset_seconds: i32  # Offset from UTC in seconds
    
    def __init__(self, name: string, offset_seconds: i32):
        self.name = name
        self.offset_seconds = offset_seconds
    
    def utc() -> TimeZone:
        return TimeZone("UTC", 0)
    
    def eastern() -> TimeZone:
        return TimeZone("EST", -5 * 3600)
    
    def central() -> TimeZone:
        return TimeZone("CST", -6 * 3600)
    
    def mountain() -> TimeZone:
        return TimeZone("MST", -7 * 3600)
    
    def pacific() -> TimeZone:
        return TimeZone("PST", -8 * 3600)
    
    def from_offset_hours(hours: i32) -> TimeZone:
        return TimeZone("UTC" + (hours >= 0 ? "+" : "") + hours, hours * 3600)
    
    def offset(self) -> Duration:
        return Duration.from_secs(self.offset_seconds)
    
    def format_offset(self) -> string:
        abs_secs = abs(self.offset_seconds)
        hours = abs_secs / 3600
        minutes = (abs_secs % 3600) / 60
        sign = if self.offset_seconds >= 0 then "+" else "-"
        return format("{}{:02d}:{:02d}", sign, hours, minutes)
    
    def __str__(self) -> string:
        return self.name


## Stopwatch for measuring elapsed time
class Stopwatch:
    def __init__(self):
        self._start_time = 0
        self._elapsed = 0
        self._running = false
    
    def start(self):
        if not self._running:
            self._start_time = now_nanos()
            self._running = true
    
    def stop(self) -> Duration:
        if self._running:
            self._elapsed += now_nanos() - self._start_time
            self._running = false
        return Duration.from_nanos(self._elapsed)
    
    def reset(self):
        self._elapsed = 0
        self._start_time = 0
        self._running = false
    
    def restart(self):
        self.reset()
        self.start()
    
    def elapsed(self) -> Duration:
        if self._running:
            return Duration.from_nanos(self._elapsed + now_nanos() - self._start_time)
        return Duration.from_nanos(self._elapsed)
    
    def elapsed_millis(self) -> i64:
        return self.elapsed().as_millis()
    
    def elapsed_secs(self) -> i64:
        return self.elapsed().as_secs()
    
    def is_running(self) -> bool:
        return self._running


## Utility functions

## Get current Unix timestamp in seconds
def now() -> i64:
    # System call to get current time
    return @syscall(time)

## Get current Unix timestamp in nanoseconds
def now_nanos() -> i64:
    # System call to get high-resolution time
    return @syscall(clock_gettime, CLOCK_REALTIME)

## Sleep for specified duration
def sleep(duration: Duration):
    @syscall(nanosleep, duration.as_secs(), duration.as_nanos() % 1_000_000_000)

## Sleep for specified milliseconds
def sleep_millis(ms: i64):
    sleep(Duration.from_millis(ms))

## Sleep for specified seconds
def sleep_secs(secs: i64):
    sleep(Duration.from_secs(secs))

## Parse date from string using format
def parse_date(s: string, fmt: string) -> Date:
    # Basic implementation - supports %Y, %m, %d
    year = 1970
    month = 1
    day = 1
    
    si = 0
    fi = 0
    while fi < len(fmt) and si < len(s):
        if char_at(fmt, fi) == '%' and fi + 1 < len(fmt):
            spec = char_at(fmt, fi + 1)
            if spec == 'Y':
                year = to_int(slice(s, si, si + 4))
                si += 4
            elif spec == 'm':
                month = to_int(slice(s, si, si + 2))
                si += 2
            elif spec == 'd':
                day = to_int(slice(s, si, si + 2))
                si += 2
            else:
                si += 1
            fi += 2
        else:
            si += 1
            fi += 1
    
    return Date(year, month, day)

## Parse time from string using format
def parse_time(s: string, fmt: string) -> Time:
    hour = 0
    minute = 0
    second = 0
    
    si = 0
    fi = 0
    while fi < len(fmt) and si < len(s):
        if char_at(fmt, fi) == '%' and fi + 1 < len(fmt):
            spec = char_at(fmt, fi + 1)
            if spec == 'H':
                hour = to_int(slice(s, si, si + 2))
                si += 2
            elif spec == 'M':
                minute = to_int(slice(s, si, si + 2))
                si += 2
            elif spec == 'S':
                second = to_int(slice(s, si, si + 2))
                si += 2
            else:
                si += 1
            fi += 2
        else:
            si += 1
            fi += 1
    
    return Time(hour, minute, second)

## Parse datetime from string using format
def parse_datetime(s: string, fmt: string) -> DateTime:
    date = parse_date(s, fmt)
    time = parse_time(s, fmt)
    return DateTime(date, time)

## Calculate age in years from birth date
def age(birth_date: Date) -> i32:
    today = Date.today()
    years = today.year - birth_date.year
    if today.month < birth_date.month or \
       (today.month == birth_date.month and today.day < birth_date.day):
        years -= 1
    return years

## Check if year is a leap year
def is_leap_year(year: i32) -> bool:
    return (year % 4 == 0 and year % 100 != 0) or year % 400 == 0

## Get number of days in a month
def days_in_month(year: i32, month: u8) -> u8:
    if month in [1, 3, 5, 7, 8, 10, 12]:
        return 31
    elif month in [4, 6, 9, 11]:
        return 30
    elif month == 2:
        return if is_leap_year(year) then 29 else 28
    return 0

## Get the day of the week for a date (0=Sunday, 6=Saturday)
def weekday(date: Date) -> u8:
    return date.day_of_week()

## Add days to a date
def add_days(date: Date, days: i64) -> Date:
    return Date.from_days_since_epoch(date.days_since_epoch() + days)

## Add months to a date
def add_months(date: Date, months: i32) -> Date:
    new_month = date.month + months
    new_year = date.year
    
    while new_month > 12:
        new_month -= 12
        new_year += 1
    
    while new_month < 1:
        new_month += 12
        new_year -= 1
    
    # Adjust day if necessary
    max_day = days_in_month(new_year, new_month)
    new_day = min(date.day, max_day)
    
    return Date(new_year, new_month, new_day)

## Add years to a date
def add_years(date: Date, years: i32) -> Date:
    new_year = date.year + years
    max_day = days_in_month(new_year, date.month)
    new_day = min(date.day, max_day)
    return Date(new_year, date.month, new_day)

## Calculate difference between two dates in days
def days_between(date1: Date, date2: Date) -> i64:
    return date2.days_since_epoch() - date1.days_since_epoch()

## Calculate difference between two times
def time_between(time1: Time, time2: Time) -> Duration:
    return time2.to_duration() - time1.to_duration()

## Calculate difference between two datetimes
def datetime_between(dt1: DateTime, dt2: DateTime) -> Duration:
    secs = dt2.to_timestamp() - dt1.to_timestamp()
    nanos = dt2.time.nanosecond - dt1.time.nanosecond
    return Duration.from_secs(secs) + Duration.from_nanos(nanos)

## Check if date is between two dates (inclusive)
def is_date_between(date: Date, start: Date, end: Date) -> bool:
    return date >= start and date <= end

## Check if time is between two times (inclusive)
def is_time_between(time: Time, start: Time, end: Time) -> bool:
    if start <= end:
        return time >= start and time <= end
    else:
        # Handles overnight range (e.g., 22:00 - 06:00)
        return time >= start or time <= end

## Get start of day for datetime
def start_of_day(dt: DateTime) -> DateTime:
    return DateTime(dt.date, Time.midnight())

## Get end of day for datetime
def end_of_day(dt: DateTime) -> DateTime:
    return DateTime(dt.date, Time(23, 59, 59, 999999999))

## Get start of week (Sunday) for date
def start_of_week(date: Date) -> Date:
    dow = date.day_of_week()
    return add_days(date, -dow)

## Get end of week (Saturday) for date
def end_of_week(date: Date) -> Date:
    dow = date.day_of_week()
    return add_days(date, 6 - dow)

## Get start of month for date
def start_of_month(date: Date) -> Date:
    return Date(date.year, date.month, 1)

## Get end of month for date
def end_of_month(date: Date) -> Date:
    last_day = days_in_month(date.year, date.month)
    return Date(date.year, date.month, last_day)

## Get start of year for date
def start_of_year(date: Date) -> Date:
    return Date(date.year, 1, 1)

## Get end of year for date
def end_of_year(date: Date) -> Date:
    return Date(date.year, 12, 31)

## Get start of quarter for date
def start_of_quarter(date: Date) -> Date:
    q = date.quarter()
    month = (q - 1) * 3 + 1
    return Date(date.year, month, 1)

## Get end of quarter for date
def end_of_quarter(date: Date) -> Date:
    q = date.quarter()
    month = q * 3
    last_day = days_in_month(date.year, month)
    return Date(date.year, month, last_day)

## Timer class for benchmarking
class Timer:
    def __init__(self, name: string = ""):
        self._name = name
        self._sw = Stopwatch()
    
    def start(self):
        self._sw.start()
    
    def stop(self) -> Duration:
        return self._sw.stop()
    
    def elapsed(self) -> Duration:
        return self._sw.elapsed()
    
    def __enter__(self) -> Timer:
        self.start()
        return self
    
    def __exit__(self, exc_type, exc_val, exc_tb):
        elapsed = self.stop()
        if self._name:
            print(format("{}: {}", self._name, elapsed))
        return false
