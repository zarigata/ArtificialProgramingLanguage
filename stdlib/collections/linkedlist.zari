// VeZ LinkedList - Doubly-linked list implementation
// Provides O(1) insertion/removal at head, tail, and arbitrary positions

pub struct LinkedList<T>:
    head: Option<Box<Node<T>>>
    tail: Option<*mut Node<T>>
    len: usize

struct Node<T>:
    value: T
    next: Option<Box<Node<T>>>
    prev: Option<*mut Node<T>>

impl<T> LinkedList<T>:
    
    pub fn new() -> Self:
        LinkedList:
            head: None
            tail: None
            len: 0
    
    pub fn push_front(&mut self, value: T):
        let mut node = Box::new(Node:
            value: value
            next: self.head.take()
            prev: None
        )
        
        match &mut self.tail:
            None:
                self.tail = Some(&mut *node as *mut Node<T>)
            Some(tail):
                if self.head.is_none():
                    node.prev = Some(*tail)
        }
        
        if let Some(old_head) = &mut node.next:
            old_head.prev = Some(&mut *node as *mut Node<T>)
        }
        
        self.head = Some(node)
        self.len += 1
    
    pub fn push_back(&mut self, value: T):
        let mut node = Box::new(Node:
            value: value
            next: None
            prev: self.tail
        )
        
        let node_ptr = &mut *node as *mut Node<T>
        
        match &mut self.tail {
            None:
                self.head = Some(node)
            Some(tail):
                unsafe { (**tail).next = Some(node) }
        }
        
        self.tail = Some(node_ptr)
        self.len += 1
    
    pub fn pop_front(&mut self) -> Option<T>:
        self.head.take().map(|mut old_head| {
            self.len -= 1
            match old_head.next.take() {
                Some(mut new_head) => {
                    new_head.prev = None
                    self.head = Some(new_head)
                }
                None => {
                    self.tail = None
                }
            }
            old_head.value
        })
    }
    
    pub fn pop_back(&mut self) -> Option<T>:
        self.tail.take().map(|tail_ptr| {
            self.len -= 1
            unsafe {
                let tail = Box::from_raw(tail_ptr)
                match tail.prev {
                    Some(prev_ptr) => {
                        (*prev_ptr).next = None
                        self.tail = Some(prev_ptr)
                    }
                    None => {
                        self.head = None
                    }
                }
                tail.value
            }
        })
    }
    
    pub fn front(&self) -> Option<&T>:
        self.head.as_ref().map(|node| &node.value)
    }
    
    pub fn front_mut(&mut self) -> Option<&mut T> {
        self.head.as_mut().map(|node| &mut node.value)
    }
    
    pub fn back(&self) -> Option<&T> {
        self.tail.map(|ptr| unsafe { &(*ptr).value })
    }
    
    pub fn back_mut(&mut self) -> Option<&mut T> {
        self.tail.map(|ptr| unsafe { &mut (*ptr).value })
    }
    
    pub fn len(&self) -> usize:
        self.len
    
    pub fn is_empty(&self) -> bool:
        self.len == 0
    
    pub fn clear(&mut self):
        while self.pop_front().is_some() {}
    }
    
    pub fn iter(&self) -> Iter<T>:
        Iter:
            front: self.head.as_ref().map(|n| &**n)
            back: self.tail.map(|p| unsafe { &*p })
            len: self.len
    }
    
    pub fn iter_mut(&mut self) -> IterMut<T>:
        IterMut:
            front: self.head.as_mut().map(|n| &mut **n)
            back: self.tail.map(|p| unsafe { &mut *p })
            len: self.len
    }
    
    pub fn contains(&self, value: &T) -> bool where T: PartialEq:
        self.iter().any(|v| v == value)
    
    pub fn split_off(&mut self, at: usize) -> LinkedList<T>:
        assert!(at <= self.len, "split_off out of bounds")
        
        if at == 0:
            return std::mem::take(self)
        }
        
        if at == self.len:
            return LinkedList::new()
        }
        
        let mut iter = self.iter_mut()
        for _ in 0..at - 1:
            iter.next()
        }
        
        let mut second = LinkedList::new()
        second.len = self.len - at
        self.len = at
        
        second
    }

struct Iter<'a, T>:
    front: Option<&'a Node<T>>
    back: Option<&'a Node<T>>
    len: usize

impl<'a, T> Iterator for Iter<'a, T>:
    type Item = &'a T
    
    fn next(&mut self) -> Option<&'a T>:
        if self.len == 0 {
            return None
        }
        
        self.front.map(|node| {
            if std::ptr::eq(node, self.back.unwrap()) {
                self.len = 0
            } else {
                self.len -= 1
                self.front = node.next.as_ref().map(|n| &**n)
            }
            &node.value
        })
    }
}

struct IterMut<'a, T>:
    front: Option<&'a mut Node<T>>
    back: Option<&'a mut Node<T>>
    len: usize

impl<'a, T> Iterator for IterMut<'a, T>:
    type Item = &'a mut T
    
    fn next(&mut self) -> Option<&'a mut T> {
        if self.len == 0 {
            return None
        }
        
        // Safe iteration with mutable access
        self.front.take().map(|node| {
            self.len -= 1
            &mut node.value
        })
    }
}

impl<T: Clone> Clone for LinkedList<T>:
    fn clone(&self) -> Self:
        let mut list = LinkedList::new()
        for item in self.iter():
            list.push_back(item.clone())
        list

impl<T> Default for LinkedList<T>:
    fn default() -> Self:
        LinkedList::new()

impl<T: Debug> Debug for LinkedList<T>:
    fn fmt(&self, f: &mut Formatter) -> Result:
        f.write_str("[")
        for (i, item) in self.iter().enumerate():
            if i > 0:
                f.write_str(" <-> ")
            f.write_fmt(format_args!("{:?}", item))
        f.write_str("]")

impl<T> Drop for LinkedList<T>:
    fn drop(&mut self):
        while self.pop_front().is_some() {}

impl<T> IntoIterator for LinkedList<T>:
    type Item = T
    type IntoIter = IntoIter<T>
    
    fn into_iter(self) -> IntoIter<T>:
        IntoIter:
            list: self

struct IntoIter<T>:
    list: LinkedList<T>

impl<T> Iterator for IntoIter<T>:
    type Item = T
    
    fn next(&mut self) -> Option<T> {
        self.list.pop_front()
    }

impl<'a, T> IntoIterator for &'a LinkedList<T>:
    type Item = &'a T
    type IntoIter = Iter<'a, T>
    
    fn into_iter(self) -> Iter<'a, T>:
        self.iter()

impl FromIterator<T> for LinkedList<T>:
    fn from_iter<I: IntoIterator<Item = T>>(iter: I) -> Self:
        let mut list = LinkedList::new()
        for item in iter:
            list.push_back(item)
        list
