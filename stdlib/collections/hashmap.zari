// VeZ HashMap - Hash table implementation
// Provides O(1) average-case lookup, insert, and delete

pub struct HashMap<K, V>:
    buckets: Vec<Option<Entry<K, V>>>
    len: usize
    capacity: usize
    load_factor: f32

struct Entry<K, V>:
    key: K
    value: V
    hash: u64
    occupied: bool

trait Hash:
    fn hash(&self) -> u64

trait Eq:
    fn eq(&self, other: &Self) -> bool

impl<K: Hash + Eq, V> HashMap<K, V>:
    
    pub fn new() -> Self:
        HashMap:
            buckets: Vec::with_capacity(16)
            len: 0
            capacity: 16
            load_factor: 0.75
    
    pub fn with_capacity(capacity: usize) -> Self:
        let cap = next_power_of_two(capacity)
        HashMap:
            buckets: Vec::with_capacity(cap)
            len: 0
            capacity: cap
            load_factor: 0.75
    
    pub fn insert(&mut self, key: K, value: V) -> Option<V>:
        if self.needs_resize():
            self.resize()
        
        let hash = key.hash()
        let index = self.bucket_index(hash)
        
        for i in range(self.probe_sequence(index)):
            let idx = (index + i) % self.capacity
            match &self.buckets[idx]:
                Some(entry) if entry.occupied and entry.hash == hash and entry.key.eq(&key):
                    let old = entry.value
                    entry.value = value
                    return Some(old)
                None or Some(entry) if not entry.occupied:
                    self.buckets[idx] = Some(Entry:
                        key: key
                        value: value
                        hash: hash
                        occupied: true
                    )
                    self.len += 1
                    return None
                _:
                    pass
        
        None
    
    pub fn get(&self, key: &K) -> Option<&V>:
        let hash = key.hash()
        let index = self.bucket_index(hash)
        
        for i in range(self.probe_sequence(index)):
            let idx = (index + i) % self.capacity
            match &self.buckets[idx]:
                Some(entry) if entry.occupied and entry.hash == hash and entry.key.eq(key):
                    return Some(&entry.value)
                None:
                    return None
                _:
                    pass
        
        None
    
    pub fn get_mut(&mut self, key: &K) -> Option<&mut V>:
        let hash = key.hash()
        let index = self.bucket_index(hash)
        
        for i in range(self.probe_sequence(index)):
            let idx = (index + i) % self.capacity
            match &mut self.buckets[idx]:
                Some(entry) if entry.occupied and entry.hash == hash and entry.key.eq(key):
                    return Some(&mut entry.value)
                None:
                    return None
                _:
                    pass
        
        None
    
    pub fn remove(&mut self, key: &K) -> Option<V>:
        let hash = key.hash()
        let index = self.bucket_index(hash)
        
        for i in range(self.probe_sequence(index)):
            let idx = (index + i) % self.capacity
            match &mut self.buckets[idx]:
                Some(entry) if entry.occupied and entry.hash == hash and entry.key.eq(key):
                    entry.occupied = False
                    self.len -= 1
                    return Some(entry.value)
                None:
                    return None
                _:
                    pass
        
        None
    
    pub fn contains_key(&self, key: &K) -> bool:
        self.get(key).is_some()
    
    pub fn len(&self) -> usize:
        self.len
    
    pub fn is_empty(&self) -> bool:
        self.len == 0
    
    pub fn clear(&mut self):
        for bucket in &mut self.buckets:
            bucket = None
        self.len = 0
    
    pub fn keys(&self) -> Vec<&K>:
        let mut keys = Vec::new()
        for bucket in &self.buckets:
            match bucket:
                Some(entry) if entry.occupied:
                    keys.push(&entry.key)
                _:
                    pass
        keys
    
    pub fn values(&self) -> Vec<&V>:
        let mut values = Vec::new()
        for bucket in &self.buckets:
            match bucket:
                Some(entry) if entry.occupied:
                    values.push(&entry.value)
                _:
                    pass
        values
    
    pub fn entries(&self) -> Vec<(&K, &V)>:
        let mut entries = Vec::new()
        for bucket in &self.buckets:
            match bucket:
                Some(entry) if entry.occupied:
                    entries.push((&entry.key, &entry.value))
                _:
                    pass
        entries
    
    pub fn or_insert(&mut self, key: K, default: V) -> &mut V:
        if self.needs_resize():
            self.resize()
        
        let hash = key.hash()
        let index = self.bucket_index(hash)
        
        for i in range(self.probe_sequence(index)):
            let idx = (index + i) % self.capacity
            match &mut self.buckets[idx]:
                Some(entry) if entry.occupied and entry.hash == hash and entry.key.eq(&key):
                    return &mut entry.value
                None or Some(entry) if not entry.occupied:
                    self.buckets[idx] = Some(Entry:
                        key: key
                        value: default
                        hash: hash
                        occupied: true
                    )
                    self.len += 1
                    return &mut self.buckets[idx].unwrap().value
                _:
                    pass
        
        unreachable()
    
    pub fn or_insert_with<F: Fn() -> V>(&mut self, key: K, default: F) -> &mut V:
        if self.needs_resize():
            self.resize()
        
        let hash = key.hash()
        let index = self.bucket_index(hash)
        
        for i in range(self.probe_sequence(index)):
            let idx = (index + i) % self.capacity
            match &mut self.buckets[idx]:
                Some(entry) if entry.occupied and entry.hash == hash and entry.key.eq(&key):
                    return &mut entry.value
                None or Some(entry) if not entry.occupied:
                    self.buckets[idx] = Some(Entry:
                        key: key
                        value: default()
                        hash: hash
                        occupied: true
                    )
                    self.len += 1
                    return &mut self.buckets[idx].unwrap().value
                _:
                    pass
        
        unreachable()
    
    pub fn entry(&mut self, key: K) -> EntryRef<K, V>:
        EntryRef:
            map: self
            key: key
    
    fn bucket_index(&self, hash: u64) -> usize:
        (hash as usize) % self.capacity
    
    fn probe_sequence(&self, start: usize) -> Range<usize>:
        0..self.capacity
    
    fn needs_resize(&self) -> bool:
        (self.len as f32) / (self.capacity as f32) > self.load_factor
    
    fn resize(&mut self):
        let new_capacity = self.capacity * 2
        let old_buckets = self.buckets
        self.buckets = Vec::with_capacity(new_capacity)
        self.capacity = new_capacity
        self.len = 0
        
        for bucket in old_buckets:
            match bucket:
                Some(entry) if entry.occupied:
                    self.insert(entry.key, entry.value)
                _:
                    pass

struct EntryRef<K, V>:
    map: &mut HashMap<K, V>
    key: K

impl<K, V> EntryRef<K, V>:
    pub fn or_insert(self, default: V) -> &mut V:
        self.map.or_insert(self.key, default)
    
    pub fn or_insert_with<F: Fn() -> V>(self, default: F) -> &mut V:
        self.map.or_insert_with(self.key, default)

fn next_power_of_two(n: usize) -> usize:
    if n == 0:
        return 1
    let mut power = 1
    while power < n:
        power *= 2
    power

impl<K: Hash + Eq, V> Clone for HashMap<K, V> where K: Clone, V: Clone:
    fn clone(&self) -> Self:
        let mut new_map = HashMap::with_capacity(self.capacity)
        for (k, v) in self.entries():
            new_map.insert(k.clone(), v.clone())
        new_map

impl<K: Hash + Eq, V> Default for HashMap<K, V>:
    fn default() -> Self:
        HashMap::new()

impl<K: Hash + Eq, V> Debug for HashMap<K, V> where K: Debug, V: Debug:
    fn fmt(&self, f: &mut Formatter) -> Result:
        f.write_str("HashMap { ")
        for (i, (k, v)) in self.entries().iter().enumerate():
            if i > 0:
                f.write_str(", ")
            f.write_fmt(format_args!("{:?}: {:?}", k, v))
        f.write_str(" }")

impl<K: Hash + Eq, V> IntoIterator for HashMap<K, V>:
    type Item = (K, V)
    type IntoIter = IntoIter<K, V>
    
    fn into_iter(self) -> IntoIter<K, V>:
        IntoIter:
            buckets: self.buckets
            index: 0

struct IntoIter<K, V>:
    buckets: Vec<Option<Entry<K, V>>>
    index: usize

impl<K, V> Iterator for IntoIter<K, V>:
    type Item = (K, V)
    
    fn next(&mut self) -> Option<(K, V)>:
        while self.index < self.buckets.len():
            match &self.buckets[self.index]:
                Some(entry) if entry.occupied:
                    self.index += 1
                    return Some((entry.key, entry.value))
                _:
                    self.index += 1
        None
