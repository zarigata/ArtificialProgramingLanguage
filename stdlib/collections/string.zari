// UTF-8 string implementation

use collections::Vec;
use core::ptr::{copy, write};

pub struct String {
    vec: Vec<u8>,
}

impl String {
    // Creates a new empty String
    pub fn new() -> String {
        String {
            vec: Vec::new(),
        }
    }
    
    // Creates a new String with the specified capacity
    pub fn with_capacity(capacity: usize) -> String {
        String {
            vec: Vec::with_capacity(capacity),
        }
    }
    
    // Creates a String from a string literal
    pub fn from(s: &str) -> String {
        let mut string = String::with_capacity(s.len());
        for byte in s.bytes() {
            string.vec.push(byte);
        }
        string
    }
    
    // Returns the length of the string in bytes
    pub fn len(&self) -> usize {
        self.vec.len()
    }
    
    // Returns true if the string is empty
    pub fn is_empty(&self) -> bool {
        self.vec.is_empty()
    }
    
    // Returns the capacity of the string
    pub fn capacity(&self) -> usize {
        self.vec.capacity()
    }
    
    // Appends a character to the string
    pub fn push(&mut self, ch: char) {
        let mut buf = [0u8; 4];
        let bytes = ch.encode_utf8(&mut buf);
        for byte in bytes {
            self.vec.push(*byte);
        }
    }
    
    // Appends a string slice to the string
    pub fn push_str(&mut self, s: &str) {
        for byte in s.bytes() {
            self.vec.push(byte);
        }
    }
    
    // Removes the last character and returns it
    pub fn pop(&mut self) -> Option<char> {
        if self.is_empty() {
            return None;
        }
        
        // Find the start of the last character
        let mut i = self.len() - 1;
        while i > 0 && (self.vec[i] & 0b1100_0000) == 0b1000_0000 {
            i -= 1;
        }
        
        // Decode the character
        let ch = self.char_at(i);
        
        // Remove the bytes
        let char_len = self.len() - i;
        for _ in 0..char_len {
            self.vec.pop();
        }
        
        ch
    }
    
    // Inserts a character at the specified byte position
    pub fn insert(&mut self, idx: usize, ch: char) {
        let mut buf = [0u8; 4];
        let bytes = ch.encode_utf8(&mut buf);
        for (i, byte) in bytes.iter().enumerate() {
            self.vec.insert(idx + i, *byte);
        }
    }
    
    // Inserts a string slice at the specified byte position
    pub fn insert_str(&mut self, idx: usize, s: &str) {
        for (i, byte) in s.bytes().enumerate() {
            self.vec.insert(idx + i, byte);
        }
    }
    
    // Removes a character at the specified byte position
    pub fn remove(&mut self, idx: usize) -> char {
        let ch = self.char_at(idx).unwrap();
        let char_len = ch.len_utf8();
        for _ in 0..char_len {
            self.vec.remove(idx);
        }
        ch
    }
    
    // Clears the string
    pub fn clear(&mut self) {
        self.vec.clear();
    }
    
    // Reserves capacity for at least additional more bytes
    pub fn reserve(&mut self, additional: usize) {
        self.vec.reserve(additional);
    }
    
    // Shrinks the capacity to match the length
    pub fn shrink_to_fit(&mut self) {
        self.vec.shrink_to_fit();
    }
    
    // Returns a string slice of the entire string
    pub fn as_str(&self) -> &str {
        unsafe {
            str::from_utf8_unchecked(self.vec.as_slice())
        }
    }
    
    // Returns a byte slice of the string
    pub fn as_bytes(&self) -> &[u8] {
        self.vec.as_slice()
    }
    
    // Returns the character at the specified byte position
    fn char_at(&self, idx: usize) -> Option<char> {
        if idx >= self.len() {
            return None;
        }
        
        let first_byte = self.vec[idx];
        let width = if first_byte < 0x80 {
            1
        } else if first_byte < 0xE0 {
            2
        } else if first_byte < 0xF0 {
            3
        } else {
            4
        };
        
        if idx + width > self.len() {
            return None;
        }
        
        let mut code_point = 0u32;
        match width {
            1 => code_point = first_byte as u32,
            2 => {
                code_point = ((first_byte & 0x1F) as u32) << 6;
                code_point |= (self.vec[idx + 1] & 0x3F) as u32;
            }
            3 => {
                code_point = ((first_byte & 0x0F) as u32) << 12;
                code_point |= ((self.vec[idx + 1] & 0x3F) as u32) << 6;
                code_point |= (self.vec[idx + 2] & 0x3F) as u32;
            }
            4 => {
                code_point = ((first_byte & 0x07) as u32) << 18;
                code_point |= ((self.vec[idx + 1] & 0x3F) as u32) << 12;
                code_point |= ((self.vec[idx + 2] & 0x3F) as u32) << 6;
                code_point |= (self.vec[idx + 3] & 0x3F) as u32;
            }
            _ => return None,
        }
        
        char::from_u32(code_point)
    }
    
    // Checks if the string contains a substring
    pub fn contains(&self, pat: &str) -> bool {
        self.as_str().contains(pat)
    }
    
    // Checks if the string starts with a prefix
    pub fn starts_with(&self, prefix: &str) -> bool {
        if prefix.len() > self.len() {
            return false;
        }
        
        for (i, byte) in prefix.bytes().enumerate() {
            if self.vec[i] != byte {
                return false;
            }
        }
        
        true
    }
    
    // Checks if the string ends with a suffix
    pub fn ends_with(&self, suffix: &str) -> bool {
        if suffix.len() > self.len() {
            return false;
        }
        
        let offset = self.len() - suffix.len();
        for (i, byte) in suffix.bytes().enumerate() {
            if self.vec[offset + i] != byte {
                return false;
            }
        }
        
        true
    }
    
    // Splits the string by whitespace
    pub fn split_whitespace(&self) -> Vec<String> {
        let mut result = Vec::new();
        let mut current = String::new();
        
        for ch in self.chars() {
            if ch.is_whitespace() {
                if !current.is_empty() {
                    result.push(current);
                    current = String::new();
                }
            } else {
                current.push(ch);
            }
        }
        
        if !current.is_empty() {
            result.push(current);
        }
        
        result
    }
    
    // Returns an iterator over the characters
    pub fn chars(&self) -> CharIterator {
        CharIterator {
            string: self,
            index: 0,
        }
    }
    
    // Converts the string to lowercase
    pub fn to_lowercase(&self) -> String {
        let mut result = String::with_capacity(self.len());
        for ch in self.chars() {
            result.push(ch.to_lowercase());
        }
        result
    }
    
    // Converts the string to uppercase
    pub fn to_uppercase(&self) -> String {
        let mut result = String::with_capacity(self.len());
        for ch in self.chars() {
            result.push(ch.to_uppercase());
        }
        result
    }
    
    // Trims whitespace from both ends
    pub fn trim(&self) -> String {
        let s = self.as_str();
        String::from(s.trim())
    }
}

impl Clone for String {
    fn clone(&self) -> String {
        String {
            vec: self.vec.clone(),
        }
    }
}

impl PartialEq for String {
    fn eq(&self, other: &String) -> bool {
        self.vec == other.vec
    }
}

impl Display for String {
    fn display(&self) -> String {
        self.clone()
    }
}

impl Debug for String {
    fn debug(&self) -> String {
        format!("\"{}\"", self.as_str())
    }
}

impl Add for String {
    type Output = String;
    
    fn add(mut self, other: String) -> String {
        self.push_str(other.as_str());
        self
    }
}

impl AddAssign for String {
    fn add_assign(&mut self, other: String) {
        self.push_str(other.as_str());
    }
}

// Character iterator
pub struct CharIterator<'a> {
    string: &'a String,
    index: usize,
}

impl<'a> Iterator for CharIterator<'a> {
    type Item = char;
    
    fn next(&mut self) -> Option<char> {
        if self.index >= self.string.len() {
            return None;
        }
        
        let ch = self.string.char_at(self.index);
        if let Some(c) = ch {
            self.index += c.len_utf8();
            Some(c)
        } else {
            None
        }
    }
}

// Formatting macro
macro_rules! format {
    ($fmt:expr) => {
        String::from($fmt)
    };
    ($fmt:expr, $($args:expr),*) => {{
        let mut s = String::new();
        // Format string implementation
        s
    }};
}
