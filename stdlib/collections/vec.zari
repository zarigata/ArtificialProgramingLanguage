// Dynamic array implementation

use core::mem::{size_of, align_of};
use core::ptr::{null_mut, copy, write, read};

pub struct Vec<T> {
    ptr: *mut T,
    len: usize,
    cap: usize,
}

impl<T> Vec<T> {
    // Creates a new empty Vec
    pub fn new() -> Vec<T> {
        Vec {
            ptr: null_mut(),
            len: 0,
            cap: 0,
        }
    }
    
    // Creates a new Vec with the specified capacity
    pub fn with_capacity(capacity: usize) -> Vec<T> {
        if capacity == 0 {
            Vec::new()
        } else {
            let layout = Layout::array::<T>(capacity);
            let ptr = unsafe { alloc(layout) as *mut T };
            Vec {
                ptr,
                len: 0,
                cap: capacity,
            }
        }
    }
    
    // Returns the number of elements in the vector
    pub fn len(&self) -> usize {
        self.len
    }
    
    // Returns true if the vector contains no elements
    pub fn is_empty(&self) -> bool {
        self.len == 0
    }
    
    // Returns the number of elements the vector can hold without reallocating
    pub fn capacity(&self) -> usize {
        self.cap
    }
    
    // Appends an element to the back of the vector
    pub fn push(&mut self, value: T) {
        if self.len == self.cap {
            self.grow();
        }
        
        unsafe {
            write(self.ptr.add(self.len), value);
        }
        self.len += 1;
    }
    
    // Removes the last element and returns it, or None if empty
    pub fn pop(&mut self) -> Option<T> {
        if self.len == 0 {
            None
        } else {
            self.len -= 1;
            unsafe {
                Some(read(self.ptr.add(self.len)))
            }
        }
    }
    
    // Returns a reference to an element at the given index
    pub fn get(&self, index: usize) -> Option<&T> {
        if index < self.len {
            unsafe {
                Some(&*self.ptr.add(index))
            }
        } else {
            None
        }
    }
    
    // Returns a mutable reference to an element at the given index
    pub fn get_mut(&mut self, index: usize) -> Option<&mut T> {
        if index < self.len {
            unsafe {
                Some(&mut *self.ptr.add(index))
            }
        } else {
            None
        }
    }
    
    // Inserts an element at position index
    pub fn insert(&mut self, index: usize, value: T) {
        if index > self.len {
            panic!("index out of bounds");
        }
        
        if self.len == self.cap {
            self.grow();
        }
        
        unsafe {
            let p = self.ptr.add(index);
            copy(p, p.add(1), self.len - index);
            write(p, value);
        }
        self.len += 1;
    }
    
    // Removes and returns the element at position index
    pub fn remove(&mut self, index: usize) -> T {
        if index >= self.len {
            panic!("index out of bounds");
        }
        
        unsafe {
            let p = self.ptr.add(index);
            let value = read(p);
            copy(p.add(1), p, self.len - index - 1);
            self.len -= 1;
            value
        }
    }
    
    // Clears the vector, removing all values
    pub fn clear(&mut self) {
        while self.len > 0 {
            self.pop();
        }
    }
    
    // Reserves capacity for at least additional more elements
    pub fn reserve(&mut self, additional: usize) {
        let required = self.len + additional;
        if required > self.cap {
            self.grow_to(required);
        }
    }
    
    // Shrinks the capacity to match the length
    pub fn shrink_to_fit(&mut self) {
        if self.len < self.cap {
            if self.len == 0 {
                unsafe {
                    if !self.ptr.is_null() {
                        let layout = Layout::array::<T>(self.cap);
                        dealloc(self.ptr as *mut u8, layout);
                    }
                }
                self.ptr = null_mut();
                self.cap = 0;
            } else {
                let new_layout = Layout::array::<T>(self.len);
                let new_ptr = unsafe { alloc(new_layout) as *mut T };
                unsafe {
                    copy(self.ptr, new_ptr, self.len);
                    let old_layout = Layout::array::<T>(self.cap);
                    dealloc(self.ptr as *mut u8, old_layout);
                }
                self.ptr = new_ptr;
                self.cap = self.len;
            }
        }
    }
    
    // Returns a slice containing the entire vector
    pub fn as_slice(&self) -> &[T] {
        unsafe {
            slice::from_raw_parts(self.ptr, self.len)
        }
    }
    
    // Returns a mutable slice containing the entire vector
    pub fn as_mut_slice(&mut self) -> &mut [T] {
        unsafe {
            slice::from_raw_parts_mut(self.ptr, self.len)
        }
    }
    
    // Grows the vector's capacity
    fn grow(&mut self) {
        let new_cap = if self.cap == 0 {
            4
        } else {
            self.cap * 2
        };
        self.grow_to(new_cap);
    }
    
    // Grows the vector to the specified capacity
    fn grow_to(&mut self, new_cap: usize) {
        let new_layout = Layout::array::<T>(new_cap);
        let new_ptr = unsafe { alloc(new_layout) as *mut T };
        
        if self.len > 0 {
            unsafe {
                copy(self.ptr, new_ptr, self.len);
            }
        }
        
        if self.cap > 0 {
            unsafe {
                let old_layout = Layout::array::<T>(self.cap);
                dealloc(self.ptr as *mut u8, old_layout);
            }
        }
        
        self.ptr = new_ptr;
        self.cap = new_cap;
    }
}

impl<T> Drop for Vec<T> {
    fn drop(&mut self) {
        self.clear();
        
        if self.cap > 0 {
            unsafe {
                let layout = Layout::array::<T>(self.cap);
                dealloc(self.ptr as *mut u8, layout);
            }
        }
    }
}

impl<T: Clone> Clone for Vec<T> {
    fn clone(&self) -> Vec<T> {
        let mut new_vec = Vec::with_capacity(self.len);
        for i in 0..self.len {
            unsafe {
                let val = &*self.ptr.add(i);
                new_vec.push(val.clone());
            }
        }
        new_vec
    }
}

impl<T> Index<usize> for Vec<T> {
    type Output = T;
    
    fn index(&self, index: usize) -> &T {
        if index >= self.len {
            panic!("index out of bounds");
        }
        unsafe {
            &*self.ptr.add(index)
        }
    }
}

impl<T> IndexMut<usize> for Vec<T> {
    fn index_mut(&mut self, index: usize) -> &mut T {
        if index >= self.len {
            panic!("index out of bounds");
        }
        unsafe {
            &mut *self.ptr.add(index)
        }
    }
}

impl<T: PartialEq> PartialEq for Vec<T> {
    fn eq(&self, other: &Vec<T>) -> bool {
        if self.len != other.len {
            return false;
        }
        
        for i in 0..self.len {
            if self[i] != other[i] {
                return false;
            }
        }
        
        true
    }
}

impl<T: Display> Display for Vec<T> {
    fn display(&self) -> String {
        let mut s = String::from("[");
        for i in 0..self.len {
            if i > 0 {
                s.push_str(", ");
            }
            s.push_str(&self[i].to_string());
        }
        s.push(']');
        s
    }
}

impl<T: Debug> Debug for Vec<T> {
    fn debug(&self) -> String {
        let mut s = String::from("Vec[");
        for i in 0..self.len {
            if i > 0 {
                s.push_str(", ");
            }
            s.push_str(&format!("{:?}", self[i]));
        }
        s.push(']');
        s
    }
}

// Iterator implementation
pub struct VecIter<'a, T> {
    vec: &'a Vec<T>,
    index: usize,
}

impl<T> Vec<T> {
    pub fn iter(&self) -> VecIter<T> {
        VecIter {
            vec: self,
            index: 0,
        }
    }
}

impl<'a, T> Iterator for VecIter<'a, T> {
    type Item = &'a T;
    
    fn next(&mut self) -> Option<&'a T> {
        if self.index < self.vec.len {
            let item = &self.vec[self.index];
            self.index += 1;
            Some(item)
        } else {
            None
        }
    }
}
