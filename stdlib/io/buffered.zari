// VeZ Standard Library - Buffered I/O
// Provides buffered readers and writers for efficient I/O operations

/// Default buffer size for buffered I/O operations
const DEFAULT_BUF_SIZE: usize = 8192

/// BufferedReader provides buffered reading capabilities
/// Reduces system calls by reading chunks into an internal buffer
pub struct BufferedReader[T]:
    inner: T
    buffer: Vec[u8]
    pos: usize
    filled: usize

impl BufferedReader[T]:
    /// Create a new BufferedReader with default buffer size
    pub fn new(inner: T) -> Self:
        return Self {
            inner: inner,
            buffer: Vec[u8].with_capacity(DEFAULT_BUF_SIZE),
            pos: 0,
            filled: 0
        }
    
    /// Create a new BufferedReader with custom buffer size
    pub fn with_capacity(inner: T, capacity: usize) -> Self:
        return Self {
            inner: inner,
            buffer: Vec[u8].with_capacity(capacity),
            pos: 0,
            filled: 0
        }
    
    /// Read a single byte from the buffer
    /// Returns Some(byte) or None if EOF
    pub fn read_byte(&mut self) -> Option[u8]:
        if self.pos >= self.filled:
            if not self.fill_buffer():
                return None
        end
        
        let byte = self.buffer[self.pos]
        self.pos += 1
        return Some(byte)
    
    /// Read bytes into the provided buffer
    /// Returns the number of bytes read
    pub fn read(&mut self, buf: &mut [u8]) -> usize:
        let mut read_count = 0
        
        while read_count < buf.len():
            if self.pos >= self.filled:
                if not self.fill_buffer():
                    break
            end
            
            let available = self.filled - self.pos
            let remaining = buf.len() - read_count
            let to_copy = min(available, remaining)
            
            # Copy from internal buffer to output buffer
            for i in range(to_copy):
                buf[read_count + i] = self.buffer[self.pos + i]
            end
            
            self.pos += to_copy
            read_count += to_copy
        end
        
        return read_count
    
    /// Read until delimiter, returning bytes read (including delimiter)
    pub fn read_until(&mut self, delim: u8, buf: &mut Vec[u8]) -> usize:
        let mut read_count = 0
        
        loop:
            if self.pos >= self.filled:
                if not self.fill_buffer():
                    break
            end
            
            let byte = self.buffer[self.pos]
            self.pos += 1
            buf.push(byte)
            read_count += 1
            
            if byte == delim:
                break
        end
        
        return read_count
    
    /// Read a line into the provided string buffer
    /// Returns true if a line was read, false on EOF
    pub fn read_line(&mut self, line: &mut String) -> bool:
        line.clear()
        
        loop:
            if self.pos >= self.filled:
                if not self.fill_buffer():
                    return line.len() > 0
            end
            
            let byte = self.buffer[self.pos]
            self.pos += 1
            
            if byte == '\n' as u8:
                return true
            elif byte == '\r' as u8:
                # Check for \r\n
                if self.pos < self.filled or self.fill_buffer():
                    if self.buffer[self.pos] == '\n' as u8:
                        self.pos += 1
                    end
                end
                return true
            else:
                line.push(byte as char)
        end
    
    /// Peek at the next byte without consuming it
    pub fn peek(&mut self) -> Option[u8]:
        if self.pos >= self.filled:
            if not self.fill_buffer():
                return None
        end
        return Some(self.buffer[self.pos])
    
    /// Get the inner reader, discarding any buffered data
    pub fn into_inner(self) -> T:
        return self.inner
    
    /// Get a reference to the inner reader
    pub fn get_ref(&self) -> &T:
        return &self.inner
    
    /// Fill the internal buffer from the underlying reader
    /// Returns true if bytes were read, false on EOF
    fn fill_buffer(&mut self) -> bool:
        self.buffer.clear()
        self.pos = 0
        self.filled = 0
        
        let bytes_read = self.inner.read(self.buffer.as_mut_slice())
        if bytes_read == 0:
            return false
        end
        
        self.filled = bytes_read
        return true
    end


/// BufferedWriter provides buffered writing capabilities
/// Buffers writes to reduce system calls
pub struct BufferedWriter[T]:
    inner: T
    buffer: Vec[u8]

impl BufferedWriter[T]:
    /// Create a new BufferedWriter with default buffer size
    pub fn new(inner: T) -> Self:
        return Self {
            inner: inner,
            buffer: Vec[u8].with_capacity(DEFAULT_BUF_SIZE)
        }
    
    /// Create a new BufferedWriter with custom buffer size
    pub fn with_capacity(inner: T, capacity: usize) -> Self:
        return Self {
            inner: inner,
            buffer: Vec[u8].with_capacity(capacity)
        }
    
    /// Write a single byte to the buffer
    pub fn write_byte(&mut self, byte: u8):
        if self.buffer.len() >= self.buffer.capacity():
            self.flush()
        end
        self.buffer.push(byte)
    
    /// Write bytes from the provided slice
    /// Returns the number of bytes written
    pub fn write(&mut self, buf: &[u8]) -> usize:
        # If buffer is full and data is larger than capacity,
        # write directly to avoid double buffering
        if buf.len() >= self.buffer.capacity():
            self.flush()
            return self.inner.write(buf)
        end
        
        # If buffer doesn't have room, flush first
        let remaining = self.buffer.capacity() - self.buffer.len()
        if buf.len() > remaining:
            self.flush()
        end
        
        for byte in buf:
            self.buffer.push(byte)
        end
        
        return buf.len()
    
    /// Write a string to the buffer
    pub fn write_str(&mut self, s: &str):
        self.write(s.as_bytes())
    
    /// Write a line (string + newline) to the buffer
    pub fn write_line(&mut self, s: &str):
        self.write_str(s)
        self.write_byte('\n' as u8)
    
    /// Flush the buffer to the underlying writer
    pub fn flush(&mut self):
        if self.buffer.len() > 0:
            self.inner.write(self.buffer.as_slice())
            self.buffer.clear()
        end
    
    /// Flush and get the inner writer
    pub fn into_inner(mut self) -> T:
        self.flush()
        return self.inner
    
    /// Get a reference to the inner writer
    pub fn get_ref(&self) -> &T:
        return &self.inner


/// BufReader is an alias for BufferedReader
pub type BufReader[T] = BufferedReader[T]

/// BufWriter is an alias for BufferedWriter  
pub type BufWriter[T] = BufferedWriter[T]


/// LineIterator for iterating over lines in a reader
pub struct LineIterator[T]:
    reader: BufferedReader[T]
    done: bool

impl LineIterator[T]:
    pub fn new(reader: BufferedReader[T]) -> Self:
        return Self {
            reader: reader,
            done: false
        }
    
    pub fn next(&mut self) -> Option[String]:
        if self.done:
            return None
        end
        
        let mut line = String.new()
        let has_content = self.reader.read_line(&mut line)
        
        if not has_content and line.len() == 0:
            self.done = true
            return None
        end
        
        return Some(line)


/// Helper functions

/// Create a buffered reader from any readable type
pub fn buf_reader[T](inner: T) -> BufferedReader[T]:
    return BufferedReader.new(inner)

/// Create a buffered writer from any writable type
pub fn buf_writer[T](inner: T) -> BufferedWriter[T]:
    return BufferedWriter.new(inner)

/// Read entire contents into a string
pub fn read_to_string[T](reader: &mut BufferedReader[T]) -> String:
    let mut result = String.new()
    let mut line = String.new()
    
    while reader.read_line(&mut line):
        result.append(&line)
        line.clear()
    
    return result

/// Copy all data from reader to writer
pub fn copy[R, W](reader: &mut BufferedReader[R], writer: &mut BufferedWriter[W]) -> usize:
    let mut total = 0
    let mut buf: [u8; 8192] = [0; 8192]
    
    loop:
        let n = reader.read(&mut buf)
        if n == 0:
            break
        end
        writer.write(&buf[0..n])
        total += n
    
    writer.flush()
    return total
