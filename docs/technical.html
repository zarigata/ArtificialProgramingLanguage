<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>VeZ Technical Documentation ‚Äì Examples, Guides & API Reference</title>
  <meta name="description" content="Comprehensive technical documentation for VeZ: code examples, tutorials, API reference, language specification, and developer guides." />
  <meta name="keywords" content="VeZ documentation, VeZ examples, VeZ tutorials, VeZ API, GPU programming, async programming, systems programming" />
  <link rel="icon" type="image/png" href="../Favicon.png" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;500;600;700&family=Inter:wght@400;500;600&family=JetBrains+Mono:wght@400;600&display=swap" rel="stylesheet" />
  <style>
    html { scroll-behavior: smooth; }
    :root {
      --blue: #0080ff;
      --cyan: #00d9ff;
      --purple: #6b2fff;
      --dark: #0b0d14;
      --gray: #1a1a1a;
      --light: #e0e0e0;
      --white: #ffffff;
      --accent: linear-gradient(120deg, #0080ff 0%, #00d9ff 40%, #6b2fff 100%);
      --shadow: 0 18px 50px rgba(0, 0, 0, 0.35);
      --card: #121420;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: 'Inter', system-ui, -apple-system, sans-serif;
      background: var(--dark);
      color: var(--light);
      line-height: 1.6;
      overflow-x: hidden;
    }
    a { color: var(--cyan); text-decoration: none; }
    a:hover { color: var(--white); }
    header {
      padding: 28px 6vw 20px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      position: sticky;
      top: 0;
      background: rgba(11, 13, 20, 0.92);
      backdrop-filter: blur(8px);
      z-index: 20;
      border-bottom: 1px solid rgba(255,255,255,0.04);
    }
    .logo {
      display: flex;
      align-items: center;
      gap: 10px;
      font-weight: 700;
      letter-spacing: 0.02em;
    }
    .logo-mark {
      width: 38px;
      height: 38px;
      border-radius: 10px;
      background: var(--accent);
      display: grid;
      place-items: center;
      overflow: hidden;
      box-shadow: var(--shadow);
    }
    .logo-mark img {
      width: 100%;
      height: 100%;
      object-fit: cover;
      display: block;
    }
    nav a { margin-left: 18px; font-weight: 600; color: var(--light); }
    nav a:hover { color: var(--white); }
    .hero {
      padding: 80px 6vw 60px;
      background: radial-gradient(circle at 20% 20%, rgba(0,128,255,0.08), transparent 30%),
                  radial-gradient(circle at 80% 0%, rgba(107,47,255,0.1), transparent 25%);
    }
    h1 {
      font-family: 'Space Grotesk', 'Inter', sans-serif;
      font-size: clamp(38px, 5vw, 54px);
      margin: 16px 0 16px;
      line-height: 1.15;
      color: var(--white);
    }
    h2 { 
      font-family: 'Space Grotesk', sans-serif; 
      color: var(--white); 
      font-size: clamp(28px, 4vw, 36px); 
      margin: 32px 0 12px; 
    }
    h3 { 
      font-family: 'Space Grotesk', sans-serif; 
      color: var(--white); 
      font-size: clamp(20px, 3vw, 24px); 
      margin: 20px 0 10px; 
    }
    p.lead {
      font-size: 18px;
      color: #c7d2ff;
      margin: 0 0 26px;
      max-width: 860px;
    }
    .tag {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 6px 12px;
      border-radius: 999px;
      background: rgba(0, 128, 255, 0.12);
      color: var(--cyan);
      font-weight: 600;
      letter-spacing: 0.04em;
      font-size: 13px;
    }
    section { padding: 60px 6vw; border-top: 1px solid rgba(255,255,255,0.04); }
    .grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
      gap: 18px;
      margin: 24px 0;
    }
    .card {
      background: var(--card);
      border: 1px solid rgba(255,255,255,0.08);
      border-radius: 14px;
      padding: 20px;
      box-shadow: 0 12px 30px rgba(0,0,0,0.25);
      transition: transform 200ms ease, border-color 200ms ease;
    }
    .card:hover { transform: translateY(-4px); border-color: rgba(0,217,255,0.3); }
    .card h3 { margin: 6px 0 10px; }
    .card p { margin: 0 0 10px; color: #c3cbde; }
    .code-block {
      font-family: 'JetBrains Mono', monospace;
      color: #d6e1ff;
      background: rgba(0,0,0,0.4);
      border: 1px solid rgba(255,255,255,0.08);
      border-radius: 12px;
      padding: 20px;
      font-size: 14px;
      line-height: 1.6;
      white-space: pre-wrap;
      overflow-x: auto;
      margin: 16px 0;
    }
    .code-inline {
      font-family: 'JetBrains Mono', monospace;
      background: rgba(0,128,255,0.15);
      padding: 2px 6px;
      border-radius: 4px;
      font-size: 0.9em;
      color: var(--cyan);
    }
    .split { 
      display: grid; 
      grid-template-columns: repeat(auto-fit, minmax(320px, 1fr)); 
      gap: 20px; 
      margin: 24px 0;
    }
    .toc {
      background: rgba(0,128,255,0.06);
      border: 1px solid rgba(0,128,255,0.2);
      border-radius: 12px;
      padding: 20px;
      margin: 24px 0;
    }
    .toc h3 { margin-top: 0; }
    .toc ul { margin: 0; padding-left: 20px; }
    .toc li { margin: 8px 0; }
    .pill-row { display: flex; flex-wrap: wrap; gap: 8px; margin: 12px 0; }
    .pill { 
      padding: 6px 12px; 
      border-radius: 999px; 
      background: rgba(255,255,255,0.08); 
      color: #cdd5ec; 
      font-weight: 600; 
      font-size: 13px; 
    }
    .btn {
      display: inline-flex;
      align-items: center;
      gap: 10px;
      padding: 12px 18px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.12);
      font-weight: 700;
      background: rgba(255,255,255,0.03);
      color: var(--light);
      cursor: pointer;
      transition: transform 160ms ease;
    }
    .btn-primary {
      background: var(--accent);
      color: var(--white);
      border: none;
      box-shadow: var(--shadow);
    }
    .btn:hover { transform: translateY(-2px); }
    .mini { font-size: 13px; color: #9fb4dd; }
    .note {
      background: rgba(107,47,255,0.08);
      border-left: 3px solid var(--purple);
      padding: 12px 16px;
      border-radius: 8px;
      margin: 16px 0;
    }
    .warning {
      background: rgba(255,165,0,0.08);
      border-left: 3px solid #ffa500;
      padding: 12px 16px;
      border-radius: 8px;
      margin: 16px 0;
    }
    footer {
      padding: 40px 6vw 60px;
      background: #090b11;
      border-top: 1px solid rgba(255,255,255,0.06);
      color: #96a3c2;
      font-size: 14px;
    }
    .reveal { opacity: 0; transform: translateY(14px); transition: opacity 400ms ease, transform 400ms ease; }
    .reveal.visible { opacity: 1; transform: translateY(0); }
    @media (max-width: 900px) {
      .split { grid-template-columns: 1fr; }
    }
  </style>
</head>
<body>
  <header>
    <div class="logo">
      <div class="logo-mark">
        <img src="../LOGO.png" alt="VeZ logo" />
      </div>
      <div>
        <div style="font-size:16px;">VeZ Technical Docs</div>
        <div class="mini">Developer Resources</div>
      </div>
    </div>
    <nav>
      <a href="./index.html">Home</a>
      <a href="#examples">Examples</a>
      <a href="#guides">Guides</a>
      <a href="#api">API Reference</a>
      <a href="#spec">Specification</a>
    </nav>
  </header>

  <main>
    <section class="hero reveal">
      <div class="tag">Technical Documentation</div>
      <h1>VeZ Developer Resources</h1>
      <p class="lead">
        Comprehensive documentation, code examples, tutorials, and API reference for building high-performance, memory-safe applications with VeZ. From GPU kernels to async services, explore everything you need to master VeZ.
      </p>
      <div class="pill-row">
        <div class="pill">üöÄ Getting Started</div>
        <div class="pill">üíª Code Examples</div>
        <div class="pill">üìö Tutorials</div>
        <div class="pill">üîß API Reference</div>
        <div class="pill">üìñ Language Spec</div>
      </div>
    </section>

    <section id="toc" class="reveal">
      <div class="toc">
        <h3>üìã Table of Contents</h3>
        <ul>
          <li><a href="#quickstart">Quick Start Guide</a></li>
          <li><a href="#examples">Code Examples</a>
            <ul>
              <li><a href="#gpu-examples">GPU Computing</a></li>
              <li><a href="#async-examples">Async Programming</a></li>
              <li><a href="#systems-examples">Systems Programming</a></li>
              <li><a href="#ai-examples">AI/ML Pipelines</a></li>
            </ul>
          </li>
          <li><a href="#guides">Developer Guides</a></li>
          <li><a href="#api">API Reference</a></li>
          <li><a href="#spec">Language Specification</a></li>
          <li><a href="#llm-integration">LLM Integration</a></li>
        </ul>
      </div>
    </section>

    <section id="quickstart" class="reveal">
      <div class="tag">Getting Started</div>
      <h2>Quick Start Guide</h2>
      <p>Get VeZ up and running in minutes. This guide covers installation, your first program, and basic concepts.</p>
      
      <h3>Installation</h3>
      <div class="code-block">$ git clone https://github.com/zarigata/ArtificialProgramingLanguage
$ cd ArtificialProgramingLanguage/compiler
$ cargo build --release

# Add to PATH
$ export PATH="$PWD/target/release:$PATH"

# Verify installation
$ vezc --version
VeZ compiler v0.1.0</div>

      <h3>Your First VeZ Program</h3>
      <p>Create a file called <span class="code-inline">hello.zari</span>:</p>
      <div class="code-block">fn main() {
    println!("Hello, VeZ!");
}</div>

      <p>Compile and run:</p>
      <div class="code-block">$ vezc hello.zari -o hello
$ ./hello
Hello, VeZ!</div>

      <h3>Basic Syntax Overview</h3>
      <div class="split">
        <div class="card">
          <h3>Variables & Types</h3>
          <div class="code-block">// Immutable by default
let x = 42;
let name = "VeZ";

// Mutable variables
let mut counter = 0;
counter += 1;

// Type annotations
let pi: f64 = 3.14159;
let flag: bool = true;</div>
        </div>
        <div class="card">
          <h3>Functions</h3>
          <div class="code-block">// Basic function
fn add(a: i32, b: i32) -> i32 {
    return a + b;
}

// Expression-based return
fn multiply(a: i32, b: i32) -> i32 {
    a * b  // implicit return
}

// Generic function
fn max<T: Ord>(a: T, b: T) -> T {
    if a > b { a } else { b }
}</div>
        </div>
      </div>
    </section>

    <section id="examples" class="reveal">
      <div class="tag">Code Examples</div>
      <h2>Comprehensive Code Examples</h2>
      <p>Real-world examples demonstrating VeZ's capabilities across different domains.</p>

      <h3 id="gpu-examples">üéÆ GPU Computing</h3>
      
      <div class="card">
        <h3>SAXPY Kernel (GPU-Accelerated)</h3>
        <p>Single-precision A¬∑X + Y operation optimized for parallel execution.</p>
        <div class="code-block">// VeZ: AI-tuned parallel kernel
fn saxpy(a: f32, x: &Vec<f32>, y: &Vec<f32>) -> Vec<f32> {
    parallel for i in 0..x.len {
        y[i] = a * x[i] + y[i];
    }
    return y;
}

// Usage
fn main() {
    let a = 2.5;
    let x = vec![1.0, 2.0, 3.0, 4.0];
    let y = vec![5.0, 6.0, 7.0, 8.0];
    
    let result = saxpy(a, &x, &y);
    println!("Result: {:?}", result);
}</div>
        <div class="note">
          <strong>Note:</strong> The <span class="code-inline">parallel for</span> keyword automatically distributes work across GPU threads. VeZ handles memory transfers and synchronization.
        </div>
      </div>

      <div class="card">
        <h3>Matrix Multiplication (GPU)</h3>
        <p>Optimized matrix multiplication with bounds checking and parallel execution.</p>
        <div class="code-block">fn matmul(a: &Matrix, b: &Matrix) -> Matrix {
    // Compile-time bounds checking
    assert(a.cols == b.rows);
    
    let mut out = Matrix::zero(a.rows, b.cols);
    
    // Nested parallel loops for 2D parallelism
    parallel for i in 0..a.rows {
        parallel for j in 0..b.cols {
            let mut acc = 0.0;
            for k in 0..a.cols {
                acc += a.at(i, k) * b.at(k, j);
            }
            out.set(i, j, acc);
        }
    }
    
    return out;
}

// Example: 1024x1024 matrix multiplication
fn main() {
    let a = Matrix::random(1024, 1024);
    let b = Matrix::random(1024, 1024);
    
    let start = time::now();
    let c = matmul(&a, &b);
    let elapsed = time::now() - start;
    
    println!("Computed {}x{} matmul in {}ms", 
             c.rows, c.cols, elapsed);
}</div>
      </div>

      <div class="card">
        <h3>Softmax (LLM-Friendly)</h3>
        <p>Numerically stable softmax implementation with explicit bounds.</p>
        <div class="code-block">// LLM-friendly: minimal tokens, explicit bounds
fn softmax(logits: &Vec<f32>) -> Vec<f32> {
    // Find max for numerical stability
    let max_v = max(logits);
    
    // Subtract max and exponentiate
    parallel for i in 0..logits.len {
        logits[i] = exp(logits[i] - max_v);
    }
    
    // Normalize
    let sum_v = sum(logits);
    parallel for i in 0..logits.len {
        logits[i] = logits[i] / sum_v;
    }
    
    return logits;
}</div>
      </div>

      <h3 id="async-examples">‚ö° Async Programming</h3>

      <div class="card">
        <h3>Async HTTP Server</h3>
        <p>High-performance async web server with concurrent request handling.</p>
        <div class="code-block">import std.io;
import std.net;
import std.async;

async fn handle_request(req: Request) -> Response {
    match req.path() {
        "/" => Response::ok("Welcome to VeZ!"),
        "/api/data" => {
            let data = fetch_data().await?;
            Response::json(data)
        }
        _ => Response::not_found(),
    }
}

async fn fetch_data() -> Result<Data, Error> {
    let content = File::read_to_string("data.json").await?;
    let data: Data = json::parse(&content)?;
    Ok(data)
}

fn main() {
    let runtime = Runtime::new().unwrap();
    
    runtime.block_on(async {
        let server = Server::bind("127.0.0.1:8080").await?;
        println!("Server listening on port 8080");
        
        loop {
            let (stream, addr) = server.accept().await?;
            println!("Connection from {}", addr);
            
            // Spawn concurrent task
            spawn(async move {
                if let Err(e) = handle_connection(stream).await {
                    eprintln!("Error: {}", e);
                }
            });
        }
    })
}</div>
      </div>

      <div class="card">
        <h3>Streaming Inference Microservice</h3>
        <p>Real-time AI inference service with async I/O.</p>
        <div class="code-block">import std.io;
import std.net;

async fn main() {
    let port = 8080;
    serve(port, handler).await;
}

async fn handler(req: Request) -> Response {
    // Tokenize input
    let tokens = tokenize(req.body).await;
    
    // Run inference
    let scores = classify(tokens).await;
    
    // Return JSON response
    return json({ 
        status: "ok", 
        scores: scores,
        latency_ms: req.elapsed()
    });
}

async fn classify(tokens: Vec<Token>) -> Vec<f32> {
    // Load model (cached)
    let model = Model::load("classifier.onnx").await?;
    
    // Run inference on GPU
    let logits = model.forward(tokens).await?;
    
    // Apply softmax
    return softmax(&logits);
}</div>
      </div>

      <h3 id="systems-examples">üîß Systems Programming</h3>

      <div class="card">
        <h3>Memory-Safe File System Operations</h3>
        <p>Safe file I/O with automatic resource management.</p>
        <div class="code-block">import std.io.file;
import std.io.path;

fn process_files(directory: &Path) -> Result<(), Error> {
    // Iterate over directory entries
    for entry in directory.read_dir()? {
        let path = entry.path();
        
        if path.is_file() {
            // Automatic resource cleanup
            let content = File::read_to_string(&path)?;
            let lines = content.lines().count();
            
            println!("{}: {} lines", path.display(), lines);
        }
    }
    
    Ok(())
}

fn safe_write(path: &Path, data: &[u8]) -> Result<(), Error> {
    // Atomic write with temporary file
    let temp = path.with_extension("tmp");
    
    {
        let mut file = File::create(&temp)?;
        file.write_all(data)?;
        file.sync_all()?;  // Ensure data is on disk
    }  // File automatically closed here
    
    // Atomic rename
    std::fs::rename(&temp, path)?;
    Ok(())
}</div>
      </div>

      <div class="card">
        <h3>Concurrent Data Processing</h3>
        <p>Thread-safe parallel data processing with channels.</p>
        <div class="code-block">import std.thread;
import std.sync::{Arc, Mutex, channel};

fn parallel_process(data: Vec<Item>) -> Vec<Result> {
    let (tx, rx) = channel();
    let data = Arc::new(Mutex::new(data));
    
    // Spawn worker threads
    let mut handles = vec![];
    for _ in 0..num_cpus() {
        let tx = tx.clone();
        let data = data.clone();
        
        let handle = thread::spawn(move || {
            loop {
                // Get next item
                let item = {
                    let mut data = data.lock().unwrap();
                    data.pop()
                };
                
                match item {
                    Some(item) => {
                        let result = process_item(item);
                        tx.send(result).unwrap();
                    }
                    None => break,
                }
            }
        });
        
        handles.push(handle);
    }
    
    // Close sender
    drop(tx);
    
    // Collect results
    let results: Vec<Result> = rx.iter().collect();
    
    // Wait for all threads
    for handle in handles {
        handle.join().unwrap();
    }
    
    results
}</div>
      </div>

      <h3 id="ai-examples">ü§ñ AI/ML Pipelines</h3>

      <div class="card">
        <h3>Transformer Attention Mechanism</h3>
        <p>GPU-accelerated multi-head attention for transformer models.</p>
        <div class="code-block">fn multi_head_attention(
    query: &Tensor,
    key: &Tensor,
    value: &Tensor,
    num_heads: usize
) -> Tensor {
    let batch_size = query.shape[0];
    let seq_len = query.shape[1];
    let d_model = query.shape[2];
    let d_k = d_model / num_heads;
    
    // Split into multiple heads
    let q = query.reshape([batch_size, seq_len, num_heads, d_k]);
    let k = key.reshape([batch_size, seq_len, num_heads, d_k]);
    let v = value.reshape([batch_size, seq_len, num_heads, d_k]);
    
    // Compute attention scores (GPU-accelerated)
    parallel for h in 0..num_heads {
        let scores = matmul(&q[.., .., h, ..], &k[.., .., h, ..].transpose());
        let scores = scores / sqrt(d_k as f32);
        let attn = softmax(&scores);
        let output = matmul(&attn, &v[.., .., h, ..]);
    }
    
    // Concatenate heads
    return output.reshape([batch_size, seq_len, d_model]);
}</div>
      </div>

      <div class="card">
        <h3>Data Pipeline with Batching</h3>
        <p>Efficient data loading and preprocessing pipeline.</p>
        <div class="code-block">struct DataLoader {
    dataset: Vec<Sample>,
    batch_size: usize,
    shuffle: bool,
}

impl DataLoader {
    fn new(dataset: Vec<Sample>, batch_size: usize) -> Self {
        DataLoader { dataset, batch_size, shuffle: true }
    }
    
    fn iter(&mut self) -> DataIterator {
        if self.shuffle {
            self.dataset.shuffle();
        }
        DataIterator::new(&self.dataset, self.batch_size)
    }
}

async fn train_epoch(model: &mut Model, loader: &mut DataLoader) {
    for batch in loader.iter() {
        // Preprocess on CPU
        let inputs = preprocess_batch(&batch);
        
        // Transfer to GPU
        let inputs_gpu = inputs.to_gpu().await;
        
        // Forward pass
        let outputs = model.forward(inputs_gpu).await;
        
        // Compute loss
        let loss = compute_loss(&outputs, &batch.labels);
        
        // Backward pass
        loss.backward().await;
        
        // Update weights
        model.step();
    }
}</div>
      </div>
    </section>

    <section id="guides" class="reveal">
      <div class="tag">Developer Guides</div>
      <h2>In-Depth Developer Guides</h2>
      <p>Comprehensive tutorials and best practices for mastering VeZ.</p>

      <div class="grid">
        <div class="card">
          <h3>üìò Language Fundamentals</h3>
          <ul>
            <li><a href="../docs/SPECIFICATION.md">Language Specification</a></li>
            <li>Ownership & Borrowing</li>
            <li>Type System & Inference</li>
            <li>Pattern Matching</li>
            <li>Error Handling</li>
          </ul>
        </div>
        <div class="card">
          <h3>üöÄ Performance Optimization</h3>
          <ul>
            <li>Zero-Cost Abstractions</li>
            <li>GPU Optimization Techniques</li>
            <li>Memory Layout Control</li>
            <li>SIMD Vectorization</li>
            <li>Profiling & Benchmarking</li>
          </ul>
        </div>
        <div class="card">
          <h3>üîí Safety & Correctness</h3>
          <ul>
            <li>Memory Safety Guarantees</li>
            <li>Thread Safety Patterns</li>
            <li>Unsafe Code Guidelines</li>
            <li>Testing Strategies</li>
            <li>Formal Verification</li>
          </ul>
        </div>
        <div class="card">
          <h3>üéØ Advanced Topics</h3>
          <ul>
            <li><a href="../docs/ARCHITECTURE.md">Compiler Architecture</a></li>
            <li>Macro System</li>
            <li>FFI & Interoperability</li>
            <li>Custom Allocators</li>
            <li>Embedded Systems</li>
          </ul>
        </div>
      </div>

      <h3>GPU Programming Guide</h3>
      <div class="card">
        <p>VeZ provides first-class GPU support with automatic memory management and kernel optimization.</p>
        
        <h3>Parallel Loops</h3>
        <div class="code-block">// Automatic GPU dispatch
parallel for i in 0..n {
    output[i] = compute(input[i]);
}

// Explicit GPU kernel
@gpu(threads=1024)
fn kernel(data: &[f32]) -> Vec<f32> {
    let idx = thread_id();
    if idx < data.len {
        data[idx] * 2.0
    }
}</div>

        <h3>Memory Management</h3>
        <div class="code-block">// Automatic GPU memory allocation
let gpu_data = data.to_gpu();

// Explicit control
let gpu_buffer = GpuBuffer::alloc(size);
gpu_buffer.copy_from_host(&host_data);

// Automatic cleanup on drop
// No manual cudaFree needed!</div>

        <div class="note">
          <strong>Best Practice:</strong> Use <span class="code-inline">parallel for</span> for automatic optimization. The compiler chooses the best execution strategy (CPU/GPU) based on data size and complexity.
        </div>
      </div>
    </section>

    <section id="api" class="reveal">
      <div class="tag">API Reference</div>
      <h2>Standard Library API Reference</h2>
      <p>Complete reference for VeZ's standard library modules.</p>

      <div class="grid">
        <div class="card">
          <h3>std::core</h3>
          <p>Core types and traits</p>
          <ul>
            <li><span class="code-inline">Option<T></span> - Optional values</li>
            <li><span class="code-inline">Result<T, E></span> - Error handling</li>
            <li><span class="code-inline">Iterator</span> - Iteration trait</li>
            <li><span class="code-inline">Clone</span>, <span class="code-inline">Copy</span> - Value semantics</li>
          </ul>
        </div>
        <div class="card">
          <h3>std::collections</h3>
          <p>Data structures</p>
          <ul>
            <li><span class="code-inline">Vec<T></span> - Dynamic array</li>
            <li><span class="code-inline">String</span> - UTF-8 string</li>
            <li><span class="code-inline">HashMap<K, V></span> - Hash map</li>
            <li><span class="code-inline">HashSet<T></span> - Hash set</li>
          </ul>
        </div>
        <div class="card">
          <h3>std::io</h3>
          <p>Input/output operations</p>
          <ul>
            <li><span class="code-inline">File</span> - File operations</li>
            <li><span class="code-inline">BufReader</span> - Buffered reading</li>
            <li><span class="code-inline">stdin()</span>, <span class="code-inline">stdout()</span> - Standard I/O</li>
            <li><span class="code-inline">println!</span> - Print macro</li>
          </ul>
        </div>
        <div class="card">
          <h3>std::async</h3>
          <p>Asynchronous programming</p>
          <ul>
            <li><span class="code-inline">Future</span> - Async computation</li>
            <li><span class="code-inline">Runtime</span> - Async executor</li>
            <li><span class="code-inline">spawn()</span> - Task spawning</li>
            <li><span class="code-inline">join()</span>, <span class="code-inline">select()</span> - Combinators</li>
          </ul>
        </div>
        <div class="card">
          <h3>std::thread</h3>
          <p>Threading primitives</p>
          <ul>
            <li><span class="code-inline">spawn()</span> - Thread creation</li>
            <li><span class="code-inline">JoinHandle</span> - Thread handle</li>
            <li><span class="code-inline">sleep()</span> - Thread sleep</li>
            <li><span class="code-inline">yield_now()</span> - Yield execution</li>
          </ul>
        </div>
        <div class="card">
          <h3>std::sync</h3>
          <p>Synchronization primitives</p>
          <ul>
            <li><span class="code-inline">Mutex<T></span> - Mutual exclusion</li>
            <li><span class="code-inline">Arc<T></span> - Atomic reference counting</li>
            <li><span class="code-inline">channel()</span> - Message passing</li>
            <li><span class="code-inline">Barrier</span> - Thread barrier</li>
          </ul>
        </div>
      </div>
    </section>

    <section id="spec" class="reveal">
      <div class="tag">Language Specification</div>
      <h2>Formal Language Specification</h2>
      <p>Complete formal specification of VeZ's syntax, semantics, and type system.</p>

      <div class="split">
        <div class="card">
          <h3>Grammar & Syntax</h3>
          <ul>
            <li><a href="../spec/grammar/lexical.ebnf">Lexical Grammar (EBNF)</a></li>
            <li><a href="../spec/grammar/syntax.ebnf">Syntax Grammar (EBNF)</a></li>
            <li>Token Definitions</li>
            <li>Operator Precedence</li>
          </ul>
        </div>
        <div class="card">
          <h3>Type System</h3>
          <ul>
            <li><a href="../spec/type-system/primitives.md">Primitive Types</a></li>
            <li><a href="../spec/type-system/inference.md">Type Inference</a></li>
            <li>Generic Types</li>
            <li>Trait System</li>
          </ul>
        </div>
      </div>

      <div class="card">
        <h3>Memory Model</h3>
        <p>VeZ's memory model ensures safety without garbage collection.</p>
        <ul>
          <li><a href="../spec/memory-model.md">Memory Model Specification</a></li>
          <li>Ownership Rules</li>
          <li>Borrowing & Lifetimes</li>
          <li>Drop & RAII</li>
          <li>Smart Pointers</li>
          <li>GPU Memory Model</li>
        </ul>
      </div>
    </section>

    <section id="llm-integration" class="reveal">
      <div class="tag">LLM Integration</div>
      <h2>AI & LLM Integration Guide</h2>
      <p>Comprehensive guide for using VeZ with AI code generation systems.</p>

      <div class="card">
        <h3>AI Playbook for Agents</h3>
        <p>Best practices for LLM-generated VeZ code:</p>
        <div class="code-block">// System prompt excerpt for VeZ agents
You are compiling VeZ code. Prioritize:
- deterministic control flow
- explicit memory bounds
- parallel kernels when loops are independent
- avoid hidden allocations; pre-size buffers
Return code only, no prose.</div>

        <h3>Structured Context</h3>
        <ul>
          <li>Prefix with allowed imports and target architecture (CPU/GPU)</li>
          <li>Ask for deterministic loops and explicit bounds checks</li>
          <li>Reward minimal heap allocations; prefer stack and pre-sized buffers</li>
          <li>Parse compiler diagnostics programmatically; retry with fixes</li>
        </ul>

        <h3>Compilation Feedback Loop</h3>
        <div class="code-block"># Pseudocode orchestration
plan = "optimize saxpy kernel for GPU"
code = llm.generate(prompt + plan)
result = vezc.compile(code)

if result.errors:
    # Structured diagnostics for easy parsing
    llm.learn(result.errors)
    iterate()
else:
    # Benchmark and validate
    perf = benchmark(result.binary)
    if perf.meets_requirements():
        deploy(result.binary)</div>

        <div class="note">
          <strong>Full Guide:</strong> See <a href="../docs/AI_INTEGRATION.md">AI Integration Documentation</a> for complete details on training, prompting, and evaluation strategies.
        </div>
      </div>

      <div class="split">
        <div class="card">
          <h3>Design Principles for Models</h3>
          <ul>
            <li>Low-entropy grammar reduces decoding ambiguity</li>
            <li>Deterministic compilation feedback for RL loops</li>
            <li>Structured errors for fast agent fine-tuning</li>
            <li>Parallel-first keywords bias toward high-throughput</li>
          </ul>
        </div>
        <div class="card">
          <h3>Token Optimization</h3>
          <div class="pill-row">
            <div class="pill">Token-stable keywords</div>
            <div class="pill">Explicit lifetimes</div>
            <div class="pill">Structured diagnostics</div>
            <div class="pill">GPU-first loops</div>
          </div>
          <p class="mini">VeZ's syntax is optimized for transformer tokenization, reducing hallucinations and improving model reward signals.</p>
        </div>
      </div>
    </section>

    <section id="resources" class="reveal">
      <div class="tag">Additional Resources</div>
      <h2>Learning Resources & Community</h2>
      
      <div class="grid">
        <div class="card">
          <h3>üìö Documentation</h3>
          <ul>
            <li><a href="../README.md">Project README</a></li>
            <li><a href="../docs/VISION.md">Vision & Goals</a></li>
            <li><a href="../TECHNICAL_SUMMARY.md">Technical Summary</a></li>
            <li><a href="../ADVANCED_FEATURES.md">Advanced Features</a></li>
          </ul>
        </div>
        <div class="card">
          <h3>üî¨ Examples</h3>
          <ul>
            <li><a href="../examples/fibonacci.zari">Fibonacci</a></li>
            <li><a href="../examples/gpu_kernel.zari">GPU Kernel</a></li>
            <li><a href="../examples/async_example.zari">Async Example</a></li>
            <li><a href="../examples/complete_example.zari">Complete Example</a></li>
          </ul>
        </div>
        <div class="card">
          <h3>üõ†Ô∏è Tools</h3>
          <ul>
            <li>VeZ Compiler (<span class="code-inline">vezc</span>)</li>
            <li>Language Server (<span class="code-inline">vez-lsp</span>)</li>
            <li>Package Manager (<span class="code-inline">vpm</span>)</li>
            <li>Testing Framework</li>
          </ul>
        </div>
        <div class="card">
          <h3>üåê Community</h3>
          <ul>
            <li><a href="https://github.com/zarigata/ArtificialProgramingLanguage" target="_blank">GitHub Repository</a></li>
            <li><a href="mailto:hello@vez-lang.org">General Inquiries</a></li>
            <li><a href="mailto:enterprise@vez-lang.org">Enterprise Support</a></li>
            <li><a href="./comparison.html">Performance Benchmarks</a></li>
          </ul>
        </div>
      </div>

      <div class="warning">
        <strong>‚ö†Ô∏è Development Status:</strong> VeZ is currently in active development (v0.1.0-alpha). APIs may change. Production use should be evaluated carefully. See <a href="../roadmap/ROADMAP.md">roadmap</a> for details.
      </div>
    </section>
  </main>

  <footer>
    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(240px, 1fr)); gap: 24px; margin-bottom: 24px;">
      <div>
        <div style="font-weight: 700; margin-bottom: 8px;">VeZ Language</div>
        <div class="mini">AI-first programming language for enterprise systems. Hardware-native ‚Ä¢ Deterministic ‚Ä¢ Safe.</div>
      </div>
      <div>
        <div style="font-weight: 700; margin-bottom: 8px;">Documentation</div>
        <div><a href="#examples">Examples</a></div>
        <div><a href="#guides">Guides</a></div>
        <div><a href="#api">API Reference</a></div>
        <div><a href="#spec">Specification</a></div>
      </div>
      <div>
        <div style="font-weight: 700; margin-bottom: 8px;">Resources</div>
        <div><a href="./index.html">Home</a></div>
        <div><a href="./comparison.html">Benchmarks</a></div>
        <div><a href="../docs/ARCHITECTURE.md">Architecture</a></div>
        <div><a href="../docs/AI_INTEGRATION.md">AI Integration</a></div>
      </div>
      <div>
        <div style="font-weight: 700; margin-bottom: 8px;">Community</div>
        <div><a href="https://github.com/zarigata/ArtificialProgramingLanguage" target="_blank">GitHub</a></div>
        <div><a href="mailto:hello@vez-lang.org">Contact</a></div>
      </div>
    </div>
    <div style="padding-top: 16px; border-top: 1px solid rgba(255,255,255,0.06);" class="mini">
      ¬© 2026 VeZ Language. Built for developers who demand performance, safety, and innovation.
    </div>
  </footer>

  <script>
    const observer = new IntersectionObserver((entries)=> {
      entries.forEach(e => {
        if (e.isIntersecting) { e.target.classList.add('visible'); }
      });
    }, { threshold: 0.12 });
    document.querySelectorAll('.reveal').forEach(el => observer.observe(el));
  </script>
</body>
</html>
