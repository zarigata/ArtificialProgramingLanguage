==========================================
VeZ Comprehensive Test Suite
==========================================


==========================================
1. Environment Check
==========================================
[1;33mâ†’[0m Checking Rust installation...
[0;32mâœ“[0m Rust installed: rustc 1.92.0 (ded5c06cf 2025-12-08) (Fedora 1.92.0-1.fc43)
[1;33mâ†’[0m Checking Cargo installation...
[0;32mâœ“[0m Cargo installed: cargo 1.92.0 (344c4567c 2025-10-21) (Fedora 1.92.0-1.fc43)

==========================================
2. Workspace Structure
==========================================
[1;33mâ†’[0m Checking workspace Cargo.toml...
[0;32mâœ“[0m Workspace Cargo.toml exists
[1;33mâ†’[0m Checking compiler package...
[0;32mâœ“[0m Compiler package exists
[1;33mâ†’[0m Checking tools packages...
[0;32mâœ“[0m Tool 'vpm' package exists
[0;32mâœ“[0m Tool 'lsp' package exists
[0;32mâœ“[0m Tool 'testing' package exists

==========================================
3. Build Tests
==========================================
[1;33mâ†’[0m Cleaning previous builds...
warning: profiles for the non root package will be ignored, specify profiles at the workspace root:
package:   /run/media/zarigata/42A0B8BDA0B8B8AD/ARTIFICIAL-INTELIGENCE/ArtificialProgramingLanguage/compiler/Cargo.toml
workspace: /run/media/zarigata/42A0B8BDA0B8B8AD/ARTIFICIAL-INTELIGENCE/ArtificialProgramingLanguage/Cargo.toml
     Removed 493 files, 364.9MiB total
[0;32mâœ“[0m Build directory cleaned
[1;33mâ†’[0m Building compiler library...
warning: profiles for the non root package will be ignored, specify profiles at the workspace root:
package:   /run/media/zarigata/42A0B8BDA0B8B8AD/ARTIFICIAL-INTELIGENCE/ArtificialProgramingLanguage/compiler/Cargo.toml
workspace: /run/media/zarigata/42A0B8BDA0B8B8AD/ARTIFICIAL-INTELIGENCE/ArtificialProgramingLanguage/Cargo.toml
   Compiling proc-macro2 v1.0.105
   Compiling unicode-ident v1.0.22
   Compiling memchr v2.7.6
   Compiling utf8parse v0.2.2
   Compiling quote v1.0.43
   Compiling regex-syntax v0.8.8
   Compiling anstyle-query v1.1.5
   Compiling anstyle v1.0.13
   Compiling is_terminal_polyfill v1.70.2
   Compiling colorchoice v1.0.4
   Compiling heck v0.5.0
   Compiling strsim v0.11.1
   Compiling clap_lex v0.7.6
   Compiling log v0.4.29
   Compiling jiff v0.2.18
   Compiling anstyle-parse v0.2.7
   Compiling anstream v0.6.21
   Compiling clap_builder v4.5.54
   Compiling aho-corasick v1.1.4
   Compiling syn v2.0.114
   Compiling regex-automata v0.4.13
   Compiling regex v1.12.2
   Compiling env_filter v0.1.4
   Compiling clap_derive v4.5.49
   Compiling env_logger v0.11.8
   Compiling clap v4.5.54
   Compiling vez_compiler v0.1.0 (/run/media/zarigata/42A0B8BDA0B8B8AD/ARTIFICIAL-INTELIGENCE/ArtificialProgramingLanguage/compiler)
error[E0583]: file not found for module `hygiene`
 --> compiler/src/macro_system/mod.rs:5:1
  |
5 | pub mod hygiene;
  | ^^^^^^^^^^^^^^^^
  |
  = help: to create the module `hygiene`, create file "compiler/src/macro_system/hygiene.rs" or "compiler/src/macro_system/hygiene/mod.rs"
  = note: if there is a `mod hygiene` elsewhere in the crate already, import it with `use crate::...` instead

error[E0583]: file not found for module `parser`
 --> compiler/src/macro_system/mod.rs:6:1
  |
6 | pub mod parser;
  | ^^^^^^^^^^^^^^^
  |
  = help: to create the module `parser`, create file "compiler/src/macro_system/parser.rs" or "compiler/src/macro_system/parser/mod.rs"
  = note: if there is a `mod parser` elsewhere in the crate already, import it with `use crate::...` instead

error[E0583]: file not found for module `builtin`
 --> compiler/src/macro_system/mod.rs:7:1
  |
7 | pub mod builtin;
  | ^^^^^^^^^^^^^^^^
  |
  = help: to create the module `builtin`, create file "compiler/src/macro_system/builtin.rs" or "compiler/src/macro_system/builtin/mod.rs"
  = note: if there is a `mod builtin` elsewhere in the crate already, import it with `use crate::...` instead

error[E0583]: file not found for module `future`
 --> compiler/src/async_runtime/mod.rs:4:1
  |
4 | pub mod future;
  | ^^^^^^^^^^^^^^^
  |
  = help: to create the module `future`, create file "compiler/src/async_runtime/future.rs" or "compiler/src/async_runtime/future/mod.rs"
  = note: if there is a `mod future` elsewhere in the crate already, import it with `use crate::...` instead

error[E0583]: file not found for module `task`
 --> compiler/src/async_runtime/mod.rs:6:1
  |
6 | pub mod task;
  | ^^^^^^^^^^^^^
  |
  = help: to create the module `task`, create file "compiler/src/async_runtime/task.rs" or "compiler/src/async_runtime/task/mod.rs"
  = note: if there is a `mod task` elsewhere in the crate already, import it with `use crate::...` instead

error[E0583]: file not found for module `waker`
 --> compiler/src/async_runtime/mod.rs:7:1
  |
7 | pub mod waker;
  | ^^^^^^^^^^^^^^
  |
  = help: to create the module `waker`, create file "compiler/src/async_runtime/waker.rs" or "compiler/src/async_runtime/waker/mod.rs"
  = note: if there is a `mod waker` elsewhere in the crate already, import it with `use crate::...` instead

error[E0583]: file not found for module `proof_engine`
 --> compiler/src/verification/mod.rs:5:1
  |
5 | pub mod proof_engine;
  | ^^^^^^^^^^^^^^^^^^^^^
  |
  = help: to create the module `proof_engine`, create file "compiler/src/verification/proof_engine.rs" or "compiler/src/verification/proof_engine/mod.rs"
  = note: if there is a `mod proof_engine` elsewhere in the crate already, import it with `use crate::...` instead

error[E0583]: file not found for module `safety_checker`
 --> compiler/src/verification/mod.rs:6:1
  |
6 | pub mod safety_checker;
  | ^^^^^^^^^^^^^^^^^^^^^^^
  |
  = help: to create the module `safety_checker`, create file "compiler/src/verification/safety_checker.rs" or "compiler/src/verification/safety_checker/mod.rs"
  = note: if there is a `mod safety_checker` elsewhere in the crate already, import it with `use crate::...` instead

error[E0583]: file not found for module `contracts`
 --> compiler/src/verification/mod.rs:7:1
  |
7 | pub mod contracts;
  | ^^^^^^^^^^^^^^^^^^
  |
  = help: to create the module `contracts`, create file "compiler/src/verification/contracts.rs" or "compiler/src/verification/contracts/mod.rs"
  = note: if there is a `mod contracts` elsewhere in the crate already, import it with `use crate::...` instead

error[E0583]: file not found for module `cuda`
 --> compiler/src/gpu/mod.rs:4:1
  |
4 | pub mod cuda;
  | ^^^^^^^^^^^^^
  |
  = help: to create the module `cuda`, create file "compiler/src/gpu/cuda.rs" or "compiler/src/gpu/cuda/mod.rs"
  = note: if there is a `mod cuda` elsewhere in the crate already, import it with `use crate::...` instead

error[E0583]: file not found for module `metal`
 --> compiler/src/gpu/mod.rs:5:1
  |
5 | pub mod metal;
  | ^^^^^^^^^^^^^^
  |
  = help: to create the module `metal`, create file "compiler/src/gpu/metal.rs" or "compiler/src/gpu/metal/mod.rs"
  = note: if there is a `mod metal` elsewhere in the crate already, import it with `use crate::...` instead

error[E0583]: file not found for module `vulkan`
 --> compiler/src/gpu/mod.rs:6:1
  |
6 | pub mod vulkan;
  | ^^^^^^^^^^^^^^^
  |
  = help: to create the module `vulkan`, create file "compiler/src/gpu/vulkan.rs" or "compiler/src/gpu/vulkan/mod.rs"
  = note: if there is a `mod vulkan` elsewhere in the crate already, import it with `use crate::...` instead

error[E0583]: file not found for module `kernel`
 --> compiler/src/gpu/mod.rs:7:1
  |
7 | pub mod kernel;
  | ^^^^^^^^^^^^^^^
  |
  = help: to create the module `kernel`, create file "compiler/src/gpu/kernel.rs" or "compiler/src/gpu/kernel/mod.rs"
  = note: if there is a `mod kernel` elsewhere in the crate already, import it with `use crate::...` instead

error[E0432]: unresolved import `crate::semantic::types`
  --> compiler/src/verification/mod.rs:10:22
   |
10 | use crate::semantic::types::Type;
   |                      ^^^^^ could not find `types` in `semantic`

error[E0432]: unresolved import `crate::semantic::types`
 --> compiler/src/consteval/mod.rs:5:22
  |
5 | use crate::semantic::types::Type;
  |                      ^^^^^ could not find `types` in `semantic`

error[E0432]: unresolved import `crate::error::CompilerError`
 --> compiler/src/codegen/llvm_backend.rs:6:28
  |
6 | use crate::error::{Result, CompilerError};
  |                            ^^^^^^^^^^^^^ no `CompilerError` in `error`

error[E0432]: unresolved import `crate::error::CompilerError`
 --> compiler/src/codegen/target.rs:3:28
  |
3 | use crate::error::{Result, CompilerError};
  |                            ^^^^^^^^^^^^^ no `CompilerError` in `error`

error[E0432]: unresolved import `crate::error::CompilerError`
 --> compiler/src/codegen/linker.rs:3:28
  |
3 | use crate::error::{Result, CompilerError};
  |                            ^^^^^^^^^^^^^ no `CompilerError` in `error`

error[E0532]: expected tuple struct or tuple variant, found unit variant `Constant::Null`
   --> compiler/src/codegen/llvm_backend.rs:129:13
    |
129 |             Constant::Null(ty) => format!("{} null", self.type_to_llvm(ty)),
    |             ^^^^^^^^^^^^^^^^^^ help: use this syntax instead: `Constant::Null`
    |
   ::: compiler/src/ir/ssa.rs:30:5
    |
 30 |     Null,
    |     ---- `Constant::Null` defined here

error[E0532]: expected tuple struct or tuple variant, found unit variant `Constant::Undef`
   --> compiler/src/codegen/llvm_backend.rs:130:13
    |
130 |             Constant::Undef(ty) => format!("{} undef", self.type_to_llvm(ty)),
    |             ^^^^^^^^^^^^^^^^^^^ help: use this syntax instead: `Constant::Undef`
    |
   ::: compiler/src/ir/ssa.rs:31:5
    |
 31 |     Undef,
    |     ----- `Constant::Undef` defined here

error[E0433]: failed to resolve: use of undeclared type `Pin`
  --> compiler/src/async_runtime/executor.rs:64:19
   |
64 |             match Pin::new(&mut future).poll(&waker) {
   |                   ^^^ use of undeclared type `Pin`
   |
help: consider importing this struct
   |
 4 + use std::pin::Pin;
   |

error[E0412]: cannot find type `Thread` in this scope
   --> compiler/src/async_runtime/executor.rs:112:18
    |
112 |     threads: Vec<Thread>,
    |                  ^^^^^^ not found in this scope
    |
help: consider importing this struct
    |
  4 + use std::thread::Thread;
    |

error[E0412]: cannot find type `Arc` in this scope
   --> compiler/src/async_runtime/executor.rs:113:17
    |
113 |     task_queue: Arc<Mutex<VecDeque<Box<dyn Task>>>>,
    |                 ^^^ not found in this scope
    |
help: consider importing this struct
    |
  4 + use std::sync::Arc;
    |

error[E0412]: cannot find type `Mutex` in this scope
   --> compiler/src/async_runtime/executor.rs:113:21
    |
113 |     task_queue: Arc<Mutex<VecDeque<Box<dyn Task>>>>,
    |                     ^^^^^ not found in this scope
    |
help: consider importing one of these structs
    |
  4 + use std::sync::Mutex;
    |
  4 + use std::sync::nonpoison::Mutex;
    |

error[E0433]: failed to resolve: use of undeclared type `Arc`
   --> compiler/src/async_runtime/executor.rs:118:26
    |
118 |         let task_queue = Arc::new(Mutex::new(VecDeque::new()));
    |                          ^^^ use of undeclared type `Arc`
    |
help: consider importing this struct
    |
  4 + use std::sync::Arc;
    |

error[E0433]: failed to resolve: use of undeclared type `Mutex`
   --> compiler/src/async_runtime/executor.rs:118:35
    |
118 |         let task_queue = Arc::new(Mutex::new(VecDeque::new()));
    |                                   ^^^^^ use of undeclared type `Mutex`
    |
help: consider importing one of these structs
    |
  4 + use std::sync::Mutex;
    |
  4 + use std::sync::nonpoison::Mutex;
    |

error[E0433]: failed to resolve: use of undeclared type `Thread`
   --> compiler/src/async_runtime/executor.rs:123:26
    |
123 |             let thread = Thread::spawn(move || {
    |                          ^^^^^^ use of undeclared type `Thread`
    |
help: consider importing this struct
    |
  4 + use std::thread::Thread;
    |

error[E0433]: failed to resolve: use of undeclared type `Thread`
   --> compiler/src/async_runtime/executor.rs:135:25
    |
135 |                         Thread::sleep(Duration::from_millis(10));
    |                         ^^^^^^ use of undeclared type `Thread`
    |
help: consider importing this struct
    |
  4 + use std::thread::Thread;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/verification/smt_solver.rs:113:77
    |
113 |                     _ => Err(Error::new("Unsupported literal type for SMT", Span::dummy())),
    |                                                                             ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/verification/smt_solver.rs:122:21
    |
122 |                     BinaryOp::Add => "+",
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/verification/smt_solver.rs:123:21
    |
123 |                     BinaryOp::Sub => "-",
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/verification/smt_solver.rs:124:21
    |
124 |                     BinaryOp::Mul => "*",
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/verification/smt_solver.rs:125:21
    |
125 |                     BinaryOp::Div => "div",
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/verification/smt_solver.rs:126:21
    |
126 |                     BinaryOp::Eq => "=",
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/verification/smt_solver.rs:127:21
    |
127 |                     BinaryOp::Ne => "distinct",
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/verification/smt_solver.rs:128:21
    |
128 |                     BinaryOp::Lt => "<",
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/verification/smt_solver.rs:129:21
    |
129 |                     BinaryOp::Le => "<=",
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/verification/smt_solver.rs:130:21
    |
130 |                     BinaryOp::Gt => ">",
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/verification/smt_solver.rs:131:21
    |
131 |                     BinaryOp::Ge => ">=",
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/verification/smt_solver.rs:132:21
    |
132 |                     BinaryOp::And => "and",
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/verification/smt_solver.rs:133:21
    |
133 |                     BinaryOp::Or => "or",
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/verification/smt_solver.rs:134:87
    |
134 |                     _ => return Err(Error::new("Unsupported binary operator for SMT", Span::dummy())),
    |                                                                                       ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0433]: failed to resolve: use of undeclared type `UnaryOp`
   --> compiler/src/verification/smt_solver.rs:143:21
    |
143 |                     UnaryOp::Not => "not",
    |                     ^^^^^^^ use of undeclared type `UnaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::UnaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `UnaryOp`
   --> compiler/src/verification/smt_solver.rs:144:21
    |
144 |                     UnaryOp::Neg => "-",
    |                     ^^^^^^^ use of undeclared type `UnaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::UnaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/verification/smt_solver.rs:145:86
    |
145 |                     _ => return Err(Error::new("Unsupported unary operator for SMT", Span::dummy())),
    |                                                                                      ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/verification/smt_solver.rs:150:72
    |
150 |             _ => Err(Error::new("Unsupported expression type for SMT", Span::dummy())),
    |                                                                        ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/verification/smt_solver.rs:195:83
    |
195 |             .map_err(|e| Error::new(format!("Failed to spawn SMT solver: {}", e), Span::dummy()))?;
    |                                                                                   ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/verification/smt_solver.rs:199:90
    |
199 |                 .map_err(|e| Error::new(format!("Failed to write to SMT solver: {}", e), Span::dummy()))?;
    |                                                                                          ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/verification/smt_solver.rs:203:89
    |
203 |             .map_err(|e| Error::new(format!("Failed to read SMT solver output: {}", e), Span::dummy()))?;
    |                                                                                         ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0412]: cannot find type `BinaryOp` in this scope
   --> compiler/src/gpu/mod.rs:285:34
    |
285 |     fn binary_op_str(&self, op: &BinaryOp) -> &str {
    |                                  ^^^^^^^^ not found in this scope
    |
help: consider importing this enum
    |
  9 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/gpu/mod.rs:287:13
    |
287 |             BinaryOp::Add => "+",
    |             ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  9 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/gpu/mod.rs:288:13
    |
288 |             BinaryOp::Sub => "-",
    |             ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  9 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/gpu/mod.rs:289:13
    |
289 |             BinaryOp::Mul => "*",
    |             ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  9 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/gpu/mod.rs:290:13
    |
290 |             BinaryOp::Div => "/",
    |             ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  9 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/gpu/mod.rs:291:13
    |
291 |             BinaryOp::Mod => "%",
    |             ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  9 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/gpu/mod.rs:292:13
    |
292 |             BinaryOp::Eq => "==",
    |             ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  9 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/gpu/mod.rs:293:13
    |
293 |             BinaryOp::Ne => "!=",
    |             ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  9 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/gpu/mod.rs:294:13
    |
294 |             BinaryOp::Lt => "<",
    |             ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  9 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/gpu/mod.rs:295:13
    |
295 |             BinaryOp::Le => "<=",
    |             ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  9 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/gpu/mod.rs:296:13
    |
296 |             BinaryOp::Gt => ">",
    |             ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  9 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/gpu/mod.rs:297:13
    |
297 |             BinaryOp::Ge => ">=",
    |             ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  9 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
  --> compiler/src/consteval/mod.rs:68:25
   |
68 |                         Span::dummy()
   |                         ^^^^ use of undeclared type `Span`
   |
help: consider importing this struct through its public re-export
   |
 4 + use crate::prelude::Span;
   |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/consteval/mod.rs:108:17
    |
108 |                 Span::dummy()
    |                 ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0412]: cannot find type `BinaryOp` in this scope
   --> compiler/src/consteval/mod.rs:123:34
    |
123 |     fn eval_binary_op(&self, op: BinaryOp, left: &ConstValue, right: &ConstValue) -> Result<ConstValue> {
    |                                  ^^^^^^^^ not found in this scope
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:127:21
    |
127 |                     BinaryOp::Add => ConstValue::Int(l + r),
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:128:21
    |
128 |                     BinaryOp::Sub => ConstValue::Int(l - r),
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:129:21
    |
129 |                     BinaryOp::Mul => ConstValue::Int(l * r),
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:130:21
    |
130 |                     BinaryOp::Div => {
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/consteval/mod.rs:132:71
    |
132 | ...                   return Err(Error::new("Division by zero", Span::dummy()));
    |                                                                 ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:136:21
    |
136 |                     BinaryOp::Mod => ConstValue::Int(l % r),
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:137:21
    |
137 |                     BinaryOp::Eq => ConstValue::Bool(l == r),
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:138:21
    |
138 |                     BinaryOp::Ne => ConstValue::Bool(l != r),
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:139:21
    |
139 |                     BinaryOp::Lt => ConstValue::Bool(l < r),
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:140:21
    |
140 |                     BinaryOp::Le => ConstValue::Bool(l <= r),
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:141:21
    |
141 |                     BinaryOp::Gt => ConstValue::Bool(l > r),
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:142:21
    |
142 |                     BinaryOp::Ge => ConstValue::Bool(l >= r),
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:143:21
    |
143 |                     BinaryOp::BitAnd => ConstValue::Int(l & r),
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:144:21
    |
144 |                     BinaryOp::BitOr => ConstValue::Int(l | r),
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:145:21
    |
145 |                     BinaryOp::BitXor => ConstValue::Int(l ^ r),
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:146:21
    |
146 |                     BinaryOp::Shl => ConstValue::Int(l << r),
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:147:21
    |
147 |                     BinaryOp::Shr => ConstValue::Int(l >> r),
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/consteval/mod.rs:148:80
    |
148 |                     _ => return Err(Error::new("Unsupported binary operation", Span::dummy())),
    |                                                                                ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:155:21
    |
155 |                     BinaryOp::Add => ConstValue::Float(l + r),
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:156:21
    |
156 |                     BinaryOp::Sub => ConstValue::Float(l - r),
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:157:21
    |
157 |                     BinaryOp::Mul => ConstValue::Float(l * r),
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:158:21
    |
158 |                     BinaryOp::Div => ConstValue::Float(l / r),
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:159:21
    |
159 |                     BinaryOp::Eq => ConstValue::Bool(l == r),
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:160:21
    |
160 |                     BinaryOp::Ne => ConstValue::Bool(l != r),
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:161:21
    |
161 |                     BinaryOp::Lt => ConstValue::Bool(l < r),
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:162:21
    |
162 |                     BinaryOp::Le => ConstValue::Bool(l <= r),
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:163:21
    |
163 |                     BinaryOp::Gt => ConstValue::Bool(l > r),
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:164:21
    |
164 |                     BinaryOp::Ge => ConstValue::Bool(l >= r),
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/consteval/mod.rs:165:80
    |
165 |                     _ => return Err(Error::new("Unsupported binary operation", Span::dummy())),
    |                                                                                ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:172:21
    |
172 |                     BinaryOp::And => ConstValue::Bool(*l && *r),
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:173:21
    |
173 |                     BinaryOp::Or => ConstValue::Bool(*l || *r),
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:174:21
    |
174 |                     BinaryOp::Eq => ConstValue::Bool(l == r),
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:175:21
    |
175 |                     BinaryOp::Ne => ConstValue::Bool(l != r),
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/consteval/mod.rs:176:80
    |
176 |                     _ => return Err(Error::new("Unsupported binary operation", Span::dummy())),
    |                                                                                ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/consteval/mod.rs:181:70
    |
181 |             _ => Err(Error::new("Type mismatch in binary operation", Span::dummy())),
    |                                                                      ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0412]: cannot find type `UnaryOp` in this scope
   --> compiler/src/consteval/mod.rs:185:33
    |
185 |     fn eval_unary_op(&self, op: UnaryOp, val: &ConstValue) -> Result<ConstValue> {
    |                                 ^^^^^^^ not found in this scope
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::UnaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `UnaryOp`
   --> compiler/src/consteval/mod.rs:189:21
    |
189 |                     UnaryOp::Neg => ConstValue::Int(-n),
    |                     ^^^^^^^ use of undeclared type `UnaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::UnaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `UnaryOp`
   --> compiler/src/consteval/mod.rs:190:21
    |
190 |                     UnaryOp::Not => ConstValue::Bool(*n == 0),
    |                     ^^^^^^^ use of undeclared type `UnaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::UnaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `UnaryOp`
   --> compiler/src/consteval/mod.rs:191:21
    |
191 |                     UnaryOp::BitNot => ConstValue::Int(!n),
    |                     ^^^^^^^ use of undeclared type `UnaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::UnaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/consteval/mod.rs:192:79
    |
192 |                     _ => return Err(Error::new("Unsupported unary operation", Span::dummy())),
    |                                                                               ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0433]: failed to resolve: use of undeclared type `UnaryOp`
   --> compiler/src/consteval/mod.rs:199:21
    |
199 |                     UnaryOp::Neg => ConstValue::Float(-f),
    |                     ^^^^^^^ use of undeclared type `UnaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::UnaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/consteval/mod.rs:200:79
    |
200 |                     _ => return Err(Error::new("Unsupported unary operation", Span::dummy())),
    |                                                                               ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0433]: failed to resolve: use of undeclared type `UnaryOp`
   --> compiler/src/consteval/mod.rs:207:21
    |
207 |                     UnaryOp::Not => ConstValue::Bool(!b),
    |                     ^^^^^^^ use of undeclared type `UnaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::UnaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/consteval/mod.rs:208:79
    |
208 |                     _ => return Err(Error::new("Unsupported unary operation", Span::dummy())),
    |                                                                               ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/consteval/mod.rs:213:69
    |
213 |             _ => Err(Error::new("Type mismatch in unary operation", Span::dummy())),
    |                                                                     ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/consteval/mod.rs:221:65
    |
221 |             _ => return Err(Error::new("Invalid function call", Span::dummy())),
    |                                                                 ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/consteval/mod.rs:239:17
    |
239 |                 Span::dummy()
    |                 ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/consteval/mod.rs:246:61
    |
246 |             return Err(Error::new("abs expects 1 argument", Span::dummy()));
    |                                                             ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/consteval/mod.rs:252:65
    |
252 |             _ => Err(Error::new("abs expects numeric argument", Span::dummy())),
    |                                                                 ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/consteval/mod.rs:258:62
    |
258 |             return Err(Error::new("min expects 2 arguments", Span::dummy()));
    |                                                              ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/consteval/mod.rs:264:66
    |
264 |             _ => Err(Error::new("min expects numeric arguments", Span::dummy())),
    |                                                                  ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/consteval/mod.rs:270:62
    |
270 |             return Err(Error::new("max expects 2 arguments", Span::dummy()));
    |                                                              ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/consteval/mod.rs:276:66
    |
276 |             _ => Err(Error::new("max expects numeric arguments", Span::dummy())),
    |                                                                  ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/consteval/mod.rs:282:62
    |
282 |             return Err(Error::new("pow expects 2 arguments", Span::dummy()));
    |                                                              ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/consteval/mod.rs:291:80
    |
291 |                     return Err(Error::new("Negative exponent for integer pow", Span::dummy()));
    |                                                                                ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/consteval/mod.rs:295:66
    |
295 |             _ => Err(Error::new("pow expects numeric arguments", Span::dummy())),
    |                                                                  ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/consteval/mod.rs:301:62
    |
301 |             return Err(Error::new("sqrt expects 1 argument", Span::dummy()));
    |                                                              ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/consteval/mod.rs:307:70
    |
307 |                     return Err(Error::new("sqrt of negative number", Span::dummy()));
    |                                                                      ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/consteval/mod.rs:311:64
    |
311 |             _ => Err(Error::new("sqrt expects float argument", Span::dummy())),
    |                                                                ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0412]: cannot find type `BinaryOp` in this scope
  --> compiler/src/plugin/api.rs:60:40
   |
60 |     pub fn create_binary_op(&self, op: BinaryOp, left: Expr, right: Expr) -> Expr {
   |                                        ^^^^^^^^ not found in this scope
   |
help: consider importing this enum
   |
 4 + use crate::ir::instructions::BinaryOp;
   |

error[E0412]: cannot find type `Span` in this scope
   --> compiler/src/plugin/mod.rs:151:19
    |
151 |     pub location: Span,
    |                   ^^^^ not found in this scope
    |
help: consider importing this struct through its public re-export
    |
  9 + use crate::prelude::Span;
    |

error[E0659]: `Function` is ambiguous
  --> compiler/src/gpu/mod.rs:78:42
   |
78 |     pub fn generate_kernel(&self, func: &Function) -> Result<String> {
   |                                          ^^^^^^^^ ambiguous name
   |
   = note: ambiguous because of multiple glob imports of a name in the same module
note: `Function` could refer to the struct imported here
  --> compiler/src/gpu/mod.rs:9:5
   |
 9 | use crate::parser::ast::*;
   |     ^^^^^^^^^^^^^^^^^^^^^
   = help: consider adding an explicit import of `Function` to disambiguate
note: `Function` could also refer to the struct imported here
  --> compiler/src/gpu/mod.rs:10:5
   |
10 | use crate::ir::ssa::*;
   |     ^^^^^^^^^^^^^^^^^
   = help: consider adding an explicit import of `Function` to disambiguate

error[E0659]: `Function` is ambiguous
  --> compiler/src/gpu/mod.rs:87:43
   |
87 |     fn generate_cuda_kernel(&self, func: &Function) -> Result<String> {
   |                                           ^^^^^^^^ ambiguous name
   |
   = note: ambiguous because of multiple glob imports of a name in the same module
note: `Function` could refer to the struct imported here
  --> compiler/src/gpu/mod.rs:9:5
   |
 9 | use crate::parser::ast::*;
   |     ^^^^^^^^^^^^^^^^^^^^^
   = help: consider adding an explicit import of `Function` to disambiguate
note: `Function` could also refer to the struct imported here
  --> compiler/src/gpu/mod.rs:10:5
   |
10 | use crate::ir::ssa::*;
   |     ^^^^^^^^^^^^^^^^^
   = help: consider adding an explicit import of `Function` to disambiguate

error[E0659]: `Function` is ambiguous
   --> compiler/src/gpu/mod.rs:120:44
    |
120 |     fn generate_metal_kernel(&self, func: &Function) -> Result<String> {
    |                                            ^^^^^^^^ ambiguous name
    |
    = note: ambiguous because of multiple glob imports of a name in the same module
note: `Function` could refer to the struct imported here
   --> compiler/src/gpu/mod.rs:9:5
    |
  9 | use crate::parser::ast::*;
    |     ^^^^^^^^^^^^^^^^^^^^^
    = help: consider adding an explicit import of `Function` to disambiguate
note: `Function` could also refer to the struct imported here
   --> compiler/src/gpu/mod.rs:10:5
    |
 10 | use crate::ir::ssa::*;
    |     ^^^^^^^^^^^^^^^^^
    = help: consider adding an explicit import of `Function` to disambiguate

error[E0659]: `Function` is ambiguous
   --> compiler/src/gpu/mod.rs:157:45
    |
157 |     fn generate_vulkan_kernel(&self, func: &Function) -> Result<String> {
    |                                             ^^^^^^^^ ambiguous name
    |
    = note: ambiguous because of multiple glob imports of a name in the same module
note: `Function` could refer to the struct imported here
   --> compiler/src/gpu/mod.rs:9:5
    |
  9 | use crate::parser::ast::*;
    |     ^^^^^^^^^^^^^^^^^^^^^
    = help: consider adding an explicit import of `Function` to disambiguate
note: `Function` could also refer to the struct imported here
   --> compiler/src/gpu/mod.rs:10:5
    |
 10 | use crate::ir::ssa::*;
    |     ^^^^^^^^^^^^^^^^^
    = help: consider adding an explicit import of `Function` to disambiguate

error[E0659]: `Function` is ambiguous
   --> compiler/src/gpu/mod.rs:193:45
    |
193 |     fn generate_opencl_kernel(&self, func: &Function) -> Result<String> {
    |                                             ^^^^^^^^ ambiguous name
    |
    = note: ambiguous because of multiple glob imports of a name in the same module
note: `Function` could refer to the struct imported here
   --> compiler/src/gpu/mod.rs:9:5
    |
  9 | use crate::parser::ast::*;
    |     ^^^^^^^^^^^^^^^^^^^^^
    = help: consider adding an explicit import of `Function` to disambiguate
note: `Function` could also refer to the struct imported here
   --> compiler/src/gpu/mod.rs:10:5
    |
 10 | use crate::ir::ssa::*;
    |     ^^^^^^^^^^^^^^^^^
    = help: consider adding an explicit import of `Function` to disambiguate

error[E0659]: `Function` is ambiguous
   --> compiler/src/gpu/mod.rs:227:43
    |
227 |     fn generate_kernel_body(&self, func: &Function) -> Result<String> {
    |                                           ^^^^^^^^ ambiguous name
    |
    = note: ambiguous because of multiple glob imports of a name in the same module
note: `Function` could refer to the struct imported here
   --> compiler/src/gpu/mod.rs:9:5
    |
  9 | use crate::parser::ast::*;
    |     ^^^^^^^^^^^^^^^^^^^^^
    = help: consider adding an explicit import of `Function` to disambiguate
note: `Function` could also refer to the struct imported here
   --> compiler/src/gpu/mod.rs:10:5
    |
 10 | use crate::ir::ssa::*;
    |     ^^^^^^^^^^^^^^^^^
    = help: consider adding an explicit import of `Function` to disambiguate

warning: unused import: `TypeVar`
 --> compiler/src/semantic/type_checker.rs:6:69
  |
6 | use super::type_env::{TypeEnv, InferredType, Substitution, Unifier, TypeVar};
  |                                                                     ^^^^^^^
  |
  = note: `#[warn(unused_imports)]` (part of `#[warn(unused)]`) on by default

warning: unused import: `BasicBlock`
 --> compiler/src/ir/builder.rs:5:42
  |
5 | use super::ssa::{Function as IrFunction, BasicBlock, Value, ValueId, Constant, Module};
  |                                          ^^^^^^^^^^

warning: unused import: `crate::ir::types::IrType`
 --> compiler/src/optimizer/constant_folding.rs:5:5
  |
5 | use crate::ir::types::IrType;
  |     ^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `ValueId`
 --> compiler/src/optimizer/inline.rs:3:54
  |
3 | use crate::ir::ssa::{Module, Function as IrFunction, ValueId};
  |                                                      ^^^^^^^

warning: unused import: `Path`
 --> compiler/src/codegen/linker.rs:5:17
  |
5 | use std::path::{Path, PathBuf};
  |                 ^^^^

warning: unused import: `crate::parser::ast::*`
 --> compiler/src/macro_system/mod.rs:9:5
  |
9 | use crate::parser::ast::*;
  |     ^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `std::prelude::*`
 --> compiler/src/async_runtime/mod.rs:9:5
  |
9 | use std::prelude::*;
  |     ^^^^^^^^^^^^^^^

warning: unused import: `Error`
  --> compiler/src/verification/mod.rs:11:20
   |
11 | use crate::error::{Error, Result};
   |                    ^^^^^

warning: unused import: `std::collections::HashMap`
  --> compiler/src/verification/mod.rs:12:5
   |
12 | use std::collections::HashMap;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `crate::ir::ssa::*`
  --> compiler/src/gpu/mod.rs:10:5
   |
10 | use crate::ir::ssa::*;
   |     ^^^^^^^^^^^^^^^^^

warning: unused import: `Error`
  --> compiler/src/gpu/mod.rs:11:20
   |
11 | use crate::error::{Error, Result};
   |                    ^^^^^

error[E0277]: `F1` is not a future
   --> compiler/src/async_runtime/mod.rs:113:17
    |
113 |     let r1 = f1.await;
    |                 ^^^^^ `F1` is not a future
    |
    = note: F1 must be a future or must implement `IntoFuture` to be awaited
    = note: required for `F1` to implement `IntoFuture`
help: remove the `.await`
    |
113 -     let r1 = f1.await;
113 +     let r1 = f1;
    |
help: consider further restricting type parameter `F1` with trait `Future`
    |
110 |     F1: Future + std::future::Future,
    |                +++++++++++++++++++++

error[E0277]: `F2` is not a future
   --> compiler/src/async_runtime/mod.rs:114:17
    |
114 |     let r2 = f2.await;
    |                 ^^^^^ `F2` is not a future
    |
    = note: F2 must be a future or must implement `IntoFuture` to be awaited
    = note: required for `F2` to implement `IntoFuture`
help: remove the `.await`
    |
114 -     let r2 = f2.await;
114 +     let r2 = f2;
    |
help: consider further restricting type parameter `F2` with trait `Future`
    |
111 |     F2: Future + std::future::Future,
    |                +++++++++++++++++++++

error[E0023]: this pattern has 1 field, but the corresponding tuple variant has 2 fields
  --> compiler/src/lexer/token.rs:66:35
   |
26 |     IntLiteral(String, Option<String>),   // value, optional suffix (i32, u64, etc.)
   |                ------  -------------- tuple variant has 2 fields
...
66 |             TokenKind::IntLiteral(_) | TokenKind::FloatLiteral(_) |
   |                                   ^ expected 2 fields, found 1
   |
help: use `_` to explicitly ignore each field
   |
66 |             TokenKind::IntLiteral(_, _) | TokenKind::FloatLiteral(_) |
   |                                    +++
help: use `..` to ignore all fields
   |
66 -             TokenKind::IntLiteral(_) | TokenKind::FloatLiteral(_) |
66 +             TokenKind::IntLiteral(..) | TokenKind::FloatLiteral(_) |
   |

error[E0023]: this pattern has 1 field, but the corresponding tuple variant has 2 fields
  --> compiler/src/lexer/token.rs:66:64
   |
27 |     FloatLiteral(String, Option<String>), // value, optional suffix (f32, f64)
   |                  ------  -------------- tuple variant has 2 fields
...
66 |             TokenKind::IntLiteral(_) | TokenKind::FloatLiteral(_) |
   |                                                                ^ expected 2 fields, found 1
   |
help: use `_` to explicitly ignore each field
   |
66 |             TokenKind::IntLiteral(_) | TokenKind::FloatLiteral(_, _) |
   |                                                                 +++
help: use `..` to ignore all fields
   |
66 -             TokenKind::IntLiteral(_) | TokenKind::FloatLiteral(_) |
66 +             TokenKind::IntLiteral(_) | TokenKind::FloatLiteral(..) |
   |

error[E0308]: mismatched types
   --> compiler/src/lexer/mod.rs:689:13
    |
682 |     fn lex_slash(&mut self) -> Result<TokenKind> {
    |                                ----------------- expected `std::result::Result<TokenKind, error::Error>` because of return type
...
689 |             self.next_token() // Skip comment and get next token
    |             ^^^^^^^^^^^^^^^^^ expected `Result<TokenKind, Error>`, found `Result<Token, Error>`
    |
    = note: expected enum `std::result::Result<TokenKind, _>`
               found enum `std::result::Result<Token, _>`

error[E0308]: mismatched types
   --> compiler/src/lexer/mod.rs:698:32
    |
682 |     fn lex_slash(&mut self) -> Result<TokenKind> {
    |                                ----------------- expected `std::result::Result<TokenKind, error::Error>` because of return type
...
698 |                         return self.next_token(); // Skip comment
    |                                ^^^^^^^^^^^^^^^^^ expected `Result<TokenKind, Error>`, found `Result<Token, Error>`
    |
    = note: expected enum `std::result::Result<TokenKind, _>`
               found enum `std::result::Result<Token, _>`

error[E0599]: no function or associated item named `default` found for struct `span::Span` in the current scope
  --> compiler/src/semantic/resolver.rs:66:19
   |
66 |             Span::default(),
   |                   ^^^^^^^ function or associated item not found in `span::Span`
   |
  ::: compiler/src/span.rs:31:1
   |
31 | pub struct Span {
   | --------------- function or associated item `default` not found for this struct
   |
note: if you're trying to build a new `span::Span`, consider using `span::Span::new` which returns `span::Span`
  --> compiler/src/span.rs:37:5
   |
37 |     pub fn new(start: Position, end: Position) -> Self {
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   = help: items from traits can only be used if the trait is implemented and in scope
   = note: the following trait defines an item `default`, perhaps you need to implement it:
           candidate #1: `Default`

error[E0599]: no variant or associated item named `DuplicateSymbol` found for enum `error::ErrorKind` in the current scope
  --> compiler/src/semantic/resolver.rs:71:50
   |
71 |             self.add_error(Error::new(ErrorKind::DuplicateSymbol, e));
   |                                                  ^^^^^^^^^^^^^^^ variant or associated item not found in `error::ErrorKind`
   |
  ::: compiler/src/error.rs:18:1
   |
18 | pub enum ErrorKind {
   | ------------------ variant or associated item `DuplicateSymbol` not found for this enum

error[E0599]: no function or associated item named `default` found for struct `span::Span` in the current scope
  --> compiler/src/semantic/resolver.rs:84:23
   |
84 |                 Span::default(),
   |                       ^^^^^^^ function or associated item not found in `span::Span`
   |
  ::: compiler/src/span.rs:31:1
   |
31 | pub struct Span {
   | --------------- function or associated item `default` not found for this struct
   |
note: if you're trying to build a new `span::Span`, consider using `span::Span::new` which returns `span::Span`
  --> compiler/src/span.rs:37:5
   |
37 |     pub fn new(start: Position, end: Position) -> Self {
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   = help: items from traits can only be used if the trait is implemented and in scope
   = note: the following trait defines an item `default`, perhaps you need to implement it:
           candidate #1: `Default`

error[E0599]: no variant or associated item named `DuplicateSymbol` found for enum `error::ErrorKind` in the current scope
  --> compiler/src/semantic/resolver.rs:89:54
   |
89 |                 self.add_error(Error::new(ErrorKind::DuplicateSymbol, e));
   |                                                      ^^^^^^^^^^^^^^^ variant or associated item not found in `error::ErrorKind`
   |
  ::: compiler/src/error.rs:18:1
   |
18 | pub enum ErrorKind {
   | ------------------ variant or associated item `DuplicateSymbol` not found for this enum

error[E0599]: no function or associated item named `default` found for struct `span::Span` in the current scope
  --> compiler/src/semantic/resolver.rs:99:23
   |
99 |                 Span::default(),
   |                       ^^^^^^^ function or associated item not found in `span::Span`
   |
  ::: compiler/src/span.rs:31:1
   |
31 | pub struct Span {
   | --------------- function or associated item `default` not found for this struct
   |
note: if you're trying to build a new `span::Span`, consider using `span::Span::new` which returns `span::Span`
  --> compiler/src/span.rs:37:5
   |
37 |     pub fn new(start: Position, end: Position) -> Self {
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   = help: items from traits can only be used if the trait is implemented and in scope
   = note: the following trait defines an item `default`, perhaps you need to implement it:
           candidate #1: `Default`

error[E0599]: no variant or associated item named `DuplicateSymbol` found for enum `error::ErrorKind` in the current scope
   --> compiler/src/semantic/resolver.rs:104:54
    |
104 |                 self.add_error(Error::new(ErrorKind::DuplicateSymbol, e));
    |                                                      ^^^^^^^^^^^^^^^ variant or associated item not found in `error::ErrorKind`
    |
   ::: compiler/src/error.rs:18:1
    |
 18 | pub enum ErrorKind {
    | ------------------ variant or associated item `DuplicateSymbol` not found for this enum

error[E0599]: no function or associated item named `default` found for struct `span::Span` in the current scope
   --> compiler/src/semantic/resolver.rs:122:19
    |
122 |             Span::default(),
    |                   ^^^^^^^ function or associated item not found in `span::Span`
    |
   ::: compiler/src/span.rs:31:1
    |
 31 | pub struct Span {
    | --------------- function or associated item `default` not found for this struct
    |
note: if you're trying to build a new `span::Span`, consider using `span::Span::new` which returns `span::Span`
   --> compiler/src/span.rs:37:5
    |
 37 |     pub fn new(start: Position, end: Position) -> Self {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    = help: items from traits can only be used if the trait is implemented and in scope
    = note: the following trait defines an item `default`, perhaps you need to implement it:
            candidate #1: `Default`

error[E0599]: no variant or associated item named `DuplicateSymbol` found for enum `error::ErrorKind` in the current scope
   --> compiler/src/semantic/resolver.rs:127:50
    |
127 |             self.add_error(Error::new(ErrorKind::DuplicateSymbol, e));
    |                                                  ^^^^^^^^^^^^^^^ variant or associated item not found in `error::ErrorKind`
    |
   ::: compiler/src/error.rs:18:1
    |
 18 | pub enum ErrorKind {
    | ------------------ variant or associated item `DuplicateSymbol` not found for this enum

error[E0599]: no function or associated item named `default` found for struct `span::Span` in the current scope
   --> compiler/src/semantic/resolver.rs:136:19
    |
136 |             Span::default(),
    |                   ^^^^^^^ function or associated item not found in `span::Span`
    |
   ::: compiler/src/span.rs:31:1
    |
 31 | pub struct Span {
    | --------------- function or associated item `default` not found for this struct
    |
note: if you're trying to build a new `span::Span`, consider using `span::Span::new` which returns `span::Span`
   --> compiler/src/span.rs:37:5
    |
 37 |     pub fn new(start: Position, end: Position) -> Self {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    = help: items from traits can only be used if the trait is implemented and in scope
    = note: the following trait defines an item `default`, perhaps you need to implement it:
            candidate #1: `Default`

error[E0599]: no variant or associated item named `DuplicateSymbol` found for enum `error::ErrorKind` in the current scope
   --> compiler/src/semantic/resolver.rs:141:50
    |
141 |             self.add_error(Error::new(ErrorKind::DuplicateSymbol, e));
    |                                                  ^^^^^^^^^^^^^^^ variant or associated item not found in `error::ErrorKind`
    |
   ::: compiler/src/error.rs:18:1
    |
 18 | pub enum ErrorKind {
    | ------------------ variant or associated item `DuplicateSymbol` not found for this enum

error[E0599]: no function or associated item named `default` found for struct `span::Span` in the current scope
   --> compiler/src/semantic/resolver.rs:151:23
    |
151 |                 Span::default(),
    |                       ^^^^^^^ function or associated item not found in `span::Span`
    |
   ::: compiler/src/span.rs:31:1
    |
 31 | pub struct Span {
    | --------------- function or associated item `default` not found for this struct
    |
note: if you're trying to build a new `span::Span`, consider using `span::Span::new` which returns `span::Span`
   --> compiler/src/span.rs:37:5
    |
 37 |     pub fn new(start: Position, end: Position) -> Self {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    = help: items from traits can only be used if the trait is implemented and in scope
    = note: the following trait defines an item `default`, perhaps you need to implement it:
            candidate #1: `Default`

error[E0599]: no variant or associated item named `DuplicateSymbol` found for enum `error::ErrorKind` in the current scope
   --> compiler/src/semantic/resolver.rs:156:54
    |
156 |                 self.add_error(Error::new(ErrorKind::DuplicateSymbol, e));
    |                                                      ^^^^^^^^^^^^^^^ variant or associated item not found in `error::ErrorKind`
    |
   ::: compiler/src/error.rs:18:1
    |
 18 | pub enum ErrorKind {
    | ------------------ variant or associated item `DuplicateSymbol` not found for this enum

error[E0599]: no function or associated item named `default` found for struct `span::Span` in the current scope
   --> compiler/src/semantic/resolver.rs:166:19
    |
166 |             Span::default(),
    |                   ^^^^^^^ function or associated item not found in `span::Span`
    |
   ::: compiler/src/span.rs:31:1
    |
 31 | pub struct Span {
    | --------------- function or associated item `default` not found for this struct
    |
note: if you're trying to build a new `span::Span`, consider using `span::Span::new` which returns `span::Span`
   --> compiler/src/span.rs:37:5
    |
 37 |     pub fn new(start: Position, end: Position) -> Self {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    = help: items from traits can only be used if the trait is implemented and in scope
    = note: the following trait defines an item `default`, perhaps you need to implement it:
            candidate #1: `Default`

error[E0599]: no variant or associated item named `DuplicateSymbol` found for enum `error::ErrorKind` in the current scope
   --> compiler/src/semantic/resolver.rs:171:50
    |
171 |             self.add_error(Error::new(ErrorKind::DuplicateSymbol, e));
    |                                                  ^^^^^^^^^^^^^^^ variant or associated item not found in `error::ErrorKind`
    |
   ::: compiler/src/error.rs:18:1
    |
 18 | pub enum ErrorKind {
    | ------------------ variant or associated item `DuplicateSymbol` not found for this enum

error[E0599]: no function or associated item named `default` found for struct `span::Span` in the current scope
   --> compiler/src/semantic/resolver.rs:185:23
    |
185 |                 Span::default(),
    |                       ^^^^^^^ function or associated item not found in `span::Span`
    |
   ::: compiler/src/span.rs:31:1
    |
 31 | pub struct Span {
    | --------------- function or associated item `default` not found for this struct
    |
note: if you're trying to build a new `span::Span`, consider using `span::Span::new` which returns `span::Span`
   --> compiler/src/span.rs:37:5
    |
 37 |     pub fn new(start: Position, end: Position) -> Self {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    = help: items from traits can only be used if the trait is implemented and in scope
    = note: the following trait defines an item `default`, perhaps you need to implement it:
            candidate #1: `Default`

error[E0599]: no variant or associated item named `DuplicateSymbol` found for enum `error::ErrorKind` in the current scope
   --> compiler/src/semantic/resolver.rs:190:54
    |
190 |                 self.add_error(Error::new(ErrorKind::DuplicateSymbol, e));
    |                                                      ^^^^^^^^^^^^^^^ variant or associated item not found in `error::ErrorKind`
    |
   ::: compiler/src/error.rs:18:1
    |
 18 | pub enum ErrorKind {
    | ------------------ variant or associated item `DuplicateSymbol` not found for this enum

error[E0599]: no function or associated item named `default` found for struct `span::Span` in the current scope
   --> compiler/src/semantic/resolver.rs:217:19
    |
217 |             Span::default(),
    |                   ^^^^^^^ function or associated item not found in `span::Span`
    |
   ::: compiler/src/span.rs:31:1
    |
 31 | pub struct Span {
    | --------------- function or associated item `default` not found for this struct
    |
note: if you're trying to build a new `span::Span`, consider using `span::Span::new` which returns `span::Span`
   --> compiler/src/span.rs:37:5
    |
 37 |     pub fn new(start: Position, end: Position) -> Self {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    = help: items from traits can only be used if the trait is implemented and in scope
    = note: the following trait defines an item `default`, perhaps you need to implement it:
            candidate #1: `Default`

error[E0599]: no variant or associated item named `DuplicateSymbol` found for enum `error::ErrorKind` in the current scope
   --> compiler/src/semantic/resolver.rs:222:50
    |
222 |             self.add_error(Error::new(ErrorKind::DuplicateSymbol, e));
    |                                                  ^^^^^^^^^^^^^^^ variant or associated item not found in `error::ErrorKind`
    |
   ::: compiler/src/error.rs:18:1
    |
 18 | pub enum ErrorKind {
    | ------------------ variant or associated item `DuplicateSymbol` not found for this enum

error[E0599]: no function or associated item named `default` found for struct `span::Span` in the current scope
   --> compiler/src/semantic/resolver.rs:250:27
    |
250 |                     Span::default(),
    |                           ^^^^^^^ function or associated item not found in `span::Span`
    |
   ::: compiler/src/span.rs:31:1
    |
 31 | pub struct Span {
    | --------------- function or associated item `default` not found for this struct
    |
note: if you're trying to build a new `span::Span`, consider using `span::Span::new` which returns `span::Span`
   --> compiler/src/span.rs:37:5
    |
 37 |     pub fn new(start: Position, end: Position) -> Self {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    = help: items from traits can only be used if the trait is implemented and in scope
    = note: the following trait defines an item `default`, perhaps you need to implement it:
            candidate #1: `Default`

error[E0599]: no variant or associated item named `DuplicateSymbol` found for enum `error::ErrorKind` in the current scope
   --> compiler/src/semantic/resolver.rs:259:58
    |
259 |                     self.add_error(Error::new(ErrorKind::DuplicateSymbol, e));
    |                                                          ^^^^^^^^^^^^^^^ variant or associated item not found in `error::ErrorKind`
    |
   ::: compiler/src/error.rs:18:1
    |
 18 | pub enum ErrorKind {
    | ------------------ variant or associated item `DuplicateSymbol` not found for this enum

error[E0599]: no function or associated item named `default` found for struct `span::Span` in the current scope
   --> compiler/src/semantic/resolver.rs:357:27
    |
357 |                     Span::default(),
    |                           ^^^^^^^ function or associated item not found in `span::Span`
    |
   ::: compiler/src/span.rs:31:1
    |
 31 | pub struct Span {
    | --------------- function or associated item `default` not found for this struct
    |
note: if you're trying to build a new `span::Span`, consider using `span::Span::new` which returns `span::Span`
   --> compiler/src/span.rs:37:5
    |
 37 |     pub fn new(start: Position, end: Position) -> Self {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    = help: items from traits can only be used if the trait is implemented and in scope
    = note: the following trait defines an item `default`, perhaps you need to implement it:
            candidate #1: `Default`

error[E0599]: no variant or associated item named `DuplicateSymbol` found for enum `error::ErrorKind` in the current scope
   --> compiler/src/semantic/resolver.rs:362:58
    |
362 |                     self.add_error(Error::new(ErrorKind::DuplicateSymbol, e));
    |                                                          ^^^^^^^^^^^^^^^ variant or associated item not found in `error::ErrorKind`
    |
   ::: compiler/src/error.rs:18:1
    |
 18 | pub enum ErrorKind {
    | ------------------ variant or associated item `DuplicateSymbol` not found for this enum

error[E0599]: no function or associated item named `default` found for struct `span::Span` in the current scope
   --> compiler/src/semantic/resolver.rs:407:27
    |
407 |                     Span::default(),
    |                           ^^^^^^^ function or associated item not found in `span::Span`
    |
   ::: compiler/src/span.rs:31:1
    |
 31 | pub struct Span {
    | --------------- function or associated item `default` not found for this struct
    |
note: if you're trying to build a new `span::Span`, consider using `span::Span::new` which returns `span::Span`
   --> compiler/src/span.rs:37:5
    |
 37 |     pub fn new(start: Position, end: Position) -> Self {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    = help: items from traits can only be used if the trait is implemented and in scope
    = note: the following trait defines an item `default`, perhaps you need to implement it:
            candidate #1: `Default`

error[E0599]: no variant or associated item named `DuplicateSymbol` found for enum `error::ErrorKind` in the current scope
   --> compiler/src/semantic/resolver.rs:412:58
    |
412 |                     self.add_error(Error::new(ErrorKind::DuplicateSymbol, e));
    |                                                          ^^^^^^^^^^^^^^^ variant or associated item not found in `error::ErrorKind`
    |
   ::: compiler/src/error.rs:18:1
    |
 18 | pub enum ErrorKind {
    | ------------------ variant or associated item `DuplicateSymbol` not found for this enum

error[E0599]: no variant or associated item named `TypeError` found for enum `error::ErrorKind` in the current scope
   --> compiler/src/semantic/type_env.rs:239:36
    |
239 |                         ErrorKind::TypeError,
    |                                    ^^^^^^^^^ variant or associated item not found in `error::ErrorKind`
    |
   ::: compiler/src/error.rs:18:1
    |
 18 | pub enum ErrorKind {
    | ------------------ variant or associated item `TypeError` not found for this enum
    |
help: there is a variant with a similar name
    |
239 -                         ErrorKind::TypeError,
240 -                         "Occurs check failed: infinite type"
241 -                     ))
239 +                         ErrorKind::MoveError)
    |

error[E0599]: no variant or associated item named `TypeError` found for enum `error::ErrorKind` in the current scope
   --> compiler/src/semantic/type_env.rs:253:36
    |
253 |                         ErrorKind::TypeError,
    |                                    ^^^^^^^^^ variant or associated item not found in `error::ErrorKind`
    |
   ::: compiler/src/error.rs:18:1
    |
 18 | pub enum ErrorKind {
    | ------------------ variant or associated item `TypeError` not found for this enum
    |
help: there is a variant with a similar name
    |
253 -                         ErrorKind::TypeError,
254 -                         format!("Function arity mismatch: {} vs {}", params1.len(), params2.len())
255 -                     ));
253 +                         ErrorKind::MoveError);
    |

error[E0599]: no variant or associated item named `TypeError` found for enum `error::ErrorKind` in the current scope
   --> compiler/src/semantic/type_env.rs:275:36
    |
275 |                         ErrorKind::TypeError,
    |                                    ^^^^^^^^^ variant or associated item not found in `error::ErrorKind`
    |
   ::: compiler/src/error.rs:18:1
    |
 18 | pub enum ErrorKind {
    | ------------------ variant or associated item `TypeError` not found for this enum
    |
help: there is a variant with a similar name
    |
275 -                         ErrorKind::TypeError,
276 -                         format!("Type mismatch: {} vs {}", name1, name2)
277 -                     ));
275 +                         ErrorKind::MoveError);
    |

error[E0599]: no variant or associated item named `TypeError` found for enum `error::ErrorKind` in the current scope
   --> compiler/src/semantic/type_env.rs:282:36
    |
282 |                         ErrorKind::TypeError,
    |                                    ^^^^^^^^^ variant or associated item not found in `error::ErrorKind`
    |
   ::: compiler/src/error.rs:18:1
    |
 18 | pub enum ErrorKind {
    | ------------------ variant or associated item `TypeError` not found for this enum
    |
help: there is a variant with a similar name
    |
282 -                         ErrorKind::TypeError,
283 -                         "Generic argument count mismatch"
284 -                     ));
282 +                         ErrorKind::MoveError);
    |

error[E0599]: no variant or associated item named `TypeError` found for enum `error::ErrorKind` in the current scope
   --> compiler/src/semantic/type_env.rs:300:36
    |
300 |                         ErrorKind::TypeError,
    |                                    ^^^^^^^^^ variant or associated item not found in `error::ErrorKind`
    |
   ::: compiler/src/error.rs:18:1
    |
 18 | pub enum ErrorKind {
    | ------------------ variant or associated item `TypeError` not found for this enum
    |
help: there is a variant with a similar name
    |
300 -                         ErrorKind::TypeError,
301 -                         "Tuple size mismatch"
302 -                     ));
300 +                         ErrorKind::MoveError);
    |

error[E0599]: no variant or associated item named `TypeError` found for enum `error::ErrorKind` in the current scope
   --> compiler/src/semantic/type_env.rs:318:36
    |
318 |                         ErrorKind::TypeError,
    |                                    ^^^^^^^^^ variant or associated item not found in `error::ErrorKind`
    |
   ::: compiler/src/error.rs:18:1
    |
 18 | pub enum ErrorKind {
    | ------------------ variant or associated item `TypeError` not found for this enum
    |
help: there is a variant with a similar name
    |
318 -                         ErrorKind::TypeError,
319 -                         "Array size mismatch"
320 -                     ));
318 +                         ErrorKind::MoveError);
    |

error[E0599]: no variant or associated item named `TypeError` found for enum `error::ErrorKind` in the current scope
   --> compiler/src/semantic/type_env.rs:341:36
    |
341 |                         ErrorKind::TypeError,
    |                                    ^^^^^^^^^ variant or associated item not found in `error::ErrorKind`
    |
   ::: compiler/src/error.rs:18:1
    |
 18 | pub enum ErrorKind {
    | ------------------ variant or associated item `TypeError` not found for this enum
    |
help: there is a variant with a similar name
    |
341 -                         ErrorKind::TypeError,
342 -                         format!("Type mismatch: {} vs {}", n1, n2)
343 -                     ))
341 +                         ErrorKind::MoveError)
    |

error[E0599]: no variant or associated item named `TypeError` found for enum `error::ErrorKind` in the current scope
   --> compiler/src/semantic/type_env.rs:349:28
    |
349 |                 ErrorKind::TypeError,
    |                            ^^^^^^^^^ variant or associated item not found in `error::ErrorKind`
    |
   ::: compiler/src/error.rs:18:1
    |
 18 | pub enum ErrorKind {
    | ------------------ variant or associated item `TypeError` not found for this enum
    |
help: there is a variant with a similar name
    |
349 -                 ErrorKind::TypeError,
350 -                 format!("Cannot unify types: {:?} and {:?}", t1, t2)
351 -             ))
349 +                 ErrorKind::MoveError)
    |

error[E0599]: no variant or associated item named `TypeError` found for enum `error::ErrorKind` in the current scope
   --> compiler/src/semantic/type_checker.rs:144:36
    |
144 |                         ErrorKind::TypeError,
    |                                    ^^^^^^^^^ variant or associated item not found in `error::ErrorKind`
    |
   ::: compiler/src/error.rs:18:1
    |
 18 | pub enum ErrorKind {
    | ------------------ variant or associated item `TypeError` not found for this enum
    |
help: there is a variant with a similar name
    |
144 -                         ErrorKind::TypeError,
145 -                         "Let binding must have type annotation or initializer"
146 -                     ));
144 +                         ErrorKind::MoveError);
    |

warning: unreachable expression
  --> compiler/src/codegen/llvm_backend.rs:46:9
   |
33 |         return "x86_64-unknown-linux-gnu".to_string();
   |         --------------------------------------------- any code following this expression is unreachable
...
46 |         "unknown-unknown-unknown".to_string()
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ unreachable expression
   |
   = note: `#[warn(unreachable_code)]` (part of `#[warn(unused)]`) on by default

error[E0599]: no variant or associated item named `I1` found for enum `IrType` in the current scope
  --> compiler/src/codegen/llvm_backend.rs:60:21
   |
60 |             IrType::I1 => "i1".to_string(),
   |                     ^^ variant or associated item not found in `IrType`
   |
  ::: compiler/src/ir/types.rs:7:1
   |
 7 | pub enum IrType {
   | --------------- variant or associated item `I1` not found for this enum
   |
help: there is a variant with a similar name
   |
60 -             IrType::I1 => "i1".to_string(),
60 +             IrType::I8 => "i1".to_string(),
   |

error[E0599]: no variant or associated item named `Ptr` found for enum `IrType` in the current scope
  --> compiler/src/codegen/llvm_backend.rs:73:21
   |
73 |             IrType::Ptr(inner) => format!("{}*", self.type_to_llvm(inner)),
   |                     ^^^ variant or associated item not found in `IrType`
   |
  ::: compiler/src/ir/types.rs:7:1
   |
 7 | pub enum IrType {
   | --------------- variant or associated item `Ptr` not found for this enum

error[E0026]: variant `Instruction::Branch` does not have fields named `true_bb`, `false_bb`
   --> compiler/src/codegen/llvm_backend.rs:290:41
    |
290 |             Instruction::Branch { cond, true_bb, false_bb } => {
    |                                         ^^^^^^^  ^^^^^^^^ variant `Instruction::Branch` does not have these fields

error[E0027]: pattern does not mention fields `then_block`, `else_block`
   --> compiler/src/codegen/llvm_backend.rs:290:13
    |
290 |             Instruction::Branch { cond, true_bb, false_bb } => {
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ missing fields `then_block`, `else_block`
    |
help: include the missing fields in the pattern
    |
290 |             Instruction::Branch { cond, true_bb, false_bb, then_block, else_block } => {
    |                                                          ++++++++++++++++++++++++
help: if you don't care about these missing fields, you can explicitly ignore them
    |
290 |             Instruction::Branch { cond, true_bb, false_bb, then_block: _, else_block: _ } => {
    |                                                          ++++++++++++++++++++++++++++++
help: or always ignore missing fields here
    |
290 |             Instruction::Branch { cond, true_bb, false_bb, .. } => {
    |                                                          ++++

error[E0609]: no field `0` on type `&usize`
   --> compiler/src/codegen/llvm_backend.rs:295:53
    |
295 |                 Ok(format!("br label %bb{}", target.0))
    |                                                     ^ unknown field

error[E0609]: no field `0` on type `&usize`
   --> compiler/src/codegen/llvm_backend.rs:305:63
    |
305 |                         format!("[ {}, %bb{} ]", val_name, bb.0)
    |                                                               ^ unknown field

error[E0599]: no variant or associated item named `I1` found for enum `IrType` in the current scope
   --> compiler/src/codegen/llvm_backend.rs:337:59
    |
337 |             Value::Constant(Constant::Bool(_)) => IrType::I1,
    |                                                           ^^ variant or associated item not found in `IrType`
    |
   ::: compiler/src/ir/types.rs:7:1
    |
  7 | pub enum IrType {
    | --------------- variant or associated item `I1` not found for this enum
    |
help: there is a variant with a similar name
    |
337 -             Value::Constant(Constant::Bool(_)) => IrType::I1,
337 +             Value::Constant(Constant::Bool(_)) => IrType::I8,
    |

error[E0599]: no variant named `MacroCall` found for enum `ast::Expr`
  --> compiler/src/macro_system/expander.rs:25:19
   |
25 |             Expr::MacroCall { name, args, span } => {
   |                   ^^^^^^^^^ variant not found in `ast::Expr`
   |
  ::: compiler/src/parser/ast.rs:94:1
   |
94 | pub enum Expr {
   | ------------- variant `MacroCall` not found here

error[E0769]: tuple variant `Expr::Binary` written as struct variant
  --> compiler/src/macro_system/expander.rs:28:13
   |
28 |             Expr::Binary { op, left, right, span } => {
   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
help: use the tuple variant pattern syntax instead
   |
28 -             Expr::Binary { op, left, right, span } => {
28 +             Expr::Binary(_, _, _) => {
   |

error[E0769]: tuple variant `Expr::Call` written as struct variant
  --> compiler/src/macro_system/expander.rs:38:13
   |
38 |             Expr::Call { func, args, span } => {
   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
help: use the tuple variant pattern syntax instead
   |
38 -             Expr::Call { func, args, span } => {
38 +             Expr::Call(_, _) => {
   |

error[E0769]: tuple variant `Expr::Block` written as struct variant
  --> compiler/src/macro_system/expander.rs:49:13
   |
49 |             Expr::Block { stmts, span } => {
   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
help: use the tuple variant pattern syntax instead
   |
49 -             Expr::Block { stmts, span } => {
49 +             Expr::Block(_) => {
   |

error[E0559]: variant `ast::Expr::Binary` has no field named `op`
  --> compiler/src/macro_system/expander.rs:32:21
   |
32 |                     op: *op,
   |                     ^^ field does not exist
   |
  ::: compiler/src/parser/ast.rs:97:5
   |
97 |     Binary(Box<Expr>, BinOp, Box<Expr>),
   |     ------ `ast::Expr::Binary` defined here
   |
help: `ast::Expr::Binary` is a tuple variant, use the appropriate syntax
   |
31 -                 Ok(Expr::Binary {
32 -                     op: *op,
33 -                     left,
34 -                     right,
35 -                     span: *span,
36 -                 })
31 +                 Ok(Expr::Binary(/* Box<ast::Expr> */, /* ast::BinOp */, /* Box<ast::Expr> */))
   |

error[E0559]: variant `ast::Expr::Binary` has no field named `left`
  --> compiler/src/macro_system/expander.rs:33:21
   |
33 |                     left,
   |                     ^^^^ field does not exist
   |
  ::: compiler/src/parser/ast.rs:97:5
   |
97 |     Binary(Box<Expr>, BinOp, Box<Expr>),
   |     ------ `ast::Expr::Binary` defined here
   |
help: `ast::Expr::Binary` is a tuple variant, use the appropriate syntax
   |
31 -                 Ok(Expr::Binary {
32 -                     op: *op,
33 -                     left,
34 -                     right,
35 -                     span: *span,
36 -                 })
31 +                 Ok(Expr::Binary(/* Box<ast::Expr> */, /* ast::BinOp */, /* Box<ast::Expr> */))
   |

error[E0559]: variant `ast::Expr::Binary` has no field named `right`
  --> compiler/src/macro_system/expander.rs:34:21
   |
34 |                     right,
   |                     ^^^^^ field does not exist
   |
  ::: compiler/src/parser/ast.rs:97:5
   |
97 |     Binary(Box<Expr>, BinOp, Box<Expr>),
   |     ------ `ast::Expr::Binary` defined here
   |
help: `ast::Expr::Binary` is a tuple variant, use the appropriate syntax
   |
31 -                 Ok(Expr::Binary {
32 -                     op: *op,
33 -                     left,
34 -                     right,
35 -                     span: *span,
36 -                 })
31 +                 Ok(Expr::Binary(/* Box<ast::Expr> */, /* ast::BinOp */, /* Box<ast::Expr> */))
   |

error[E0559]: variant `ast::Expr::Binary` has no field named `span`
  --> compiler/src/macro_system/expander.rs:35:21
   |
35 |                     span: *span,
   |                     ^^^^ field does not exist
   |
  ::: compiler/src/parser/ast.rs:97:5
   |
97 |     Binary(Box<Expr>, BinOp, Box<Expr>),
   |     ------ `ast::Expr::Binary` defined here
   |
help: `ast::Expr::Binary` is a tuple variant, use the appropriate syntax
   |
31 -                 Ok(Expr::Binary {
32 -                     op: *op,
33 -                     left,
34 -                     right,
35 -                     span: *span,
36 -                 })
31 +                 Ok(Expr::Binary(/* Box<ast::Expr> */, /* ast::BinOp */, /* Box<ast::Expr> */))
   |

error[E0559]: variant `ast::Expr::Call` has no field named `func`
  --> compiler/src/macro_system/expander.rs:44:21
   |
44 |                     func,
   |                     ^^^^ field does not exist
   |
  ::: compiler/src/parser/ast.rs:99:5
   |
99 |     Call(Box<Expr>, Vec<Expr>),
   |     ---- `ast::Expr::Call` defined here
   |
help: `ast::Expr::Call` is a tuple variant, use the appropriate syntax
   |
43 -                 Ok(Expr::Call {
44 -                     func,
45 -                     args,
46 -                     span: *span,
47 -                 })
43 +                 Ok(Expr::Call(/* Box<ast::Expr> */, /* Vec<ast::Expr> */))
   |

error[E0559]: variant `ast::Expr::Call` has no field named `args`
  --> compiler/src/macro_system/expander.rs:45:21
   |
45 |                     args,
   |                     ^^^^ field does not exist
   |
  ::: compiler/src/parser/ast.rs:99:5
   |
99 |     Call(Box<Expr>, Vec<Expr>),
   |     ---- `ast::Expr::Call` defined here
   |
help: `ast::Expr::Call` is a tuple variant, use the appropriate syntax
   |
43 -                 Ok(Expr::Call {
44 -                     func,
45 -                     args,
46 -                     span: *span,
47 -                 })
43 +                 Ok(Expr::Call(/* Box<ast::Expr> */, /* Vec<ast::Expr> */))
   |

error[E0559]: variant `ast::Expr::Call` has no field named `span`
  --> compiler/src/macro_system/expander.rs:46:21
   |
46 |                     span: *span,
   |                     ^^^^ field does not exist
   |
  ::: compiler/src/parser/ast.rs:99:5
   |
99 |     Call(Box<Expr>, Vec<Expr>),
   |     ---- `ast::Expr::Call` defined here
   |
help: `ast::Expr::Call` is a tuple variant, use the appropriate syntax
   |
43 -                 Ok(Expr::Call {
44 -                     func,
45 -                     args,
46 -                     span: *span,
47 -                 })
43 +                 Ok(Expr::Call(/* Box<ast::Expr> */, /* Vec<ast::Expr> */))
   |

error[E0559]: variant `ast::Expr::Block` has no field named `stmts`
   --> compiler/src/macro_system/expander.rs:54:21
    |
 54 |                     stmts,
    |                     ^^^^^ field does not exist
    |
   ::: compiler/src/parser/ast.rs:103:5
    |
103 |     Block(Vec<Stmt>),
    |     ----- `ast::Expr::Block` defined here
    |
help: `ast::Expr::Block` is a tuple variant, use the appropriate syntax
    |
 53 -                 Ok(Expr::Block {
 54 -                     stmts,
 55 -                     span: *span,
 56 -                 })
 53 +                 Ok(Expr::Block(/* Vec<ast::Stmt> */))
    |

error[E0559]: variant `ast::Expr::Block` has no field named `span`
   --> compiler/src/macro_system/expander.rs:55:21
    |
 55 |                     span: *span,
    |                     ^^^^ field does not exist
    |
   ::: compiler/src/parser/ast.rs:103:5
    |
103 |     Block(Vec<Stmt>),
    |     ----- `ast::Expr::Block` defined here
    |
help: `ast::Expr::Block` is a tuple variant, use the appropriate syntax
    |
 53 -                 Ok(Expr::Block {
 54 -                     stmts,
 55 -                     span: *span,
 56 -                 })
 53 +                 Ok(Expr::Block(/* Vec<ast::Stmt> */))
    |

error[E0769]: tuple variant `Stmt::Let` written as struct variant
  --> compiler/src/macro_system/expander.rs:67:13
   |
67 |             Stmt::Let { pattern, ty, init, span } => {
   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
help: use the tuple variant pattern syntax instead
   |
67 -             Stmt::Let { pattern, ty, init, span } => {
67 +             Stmt::Let(_, _, _) => {
   |

error[E0559]: variant `ast::Stmt::Let` has no field named `pattern`
  --> compiler/src/macro_system/expander.rs:73:21
   |
73 |                     pattern: pattern.clone(),
   |                     ^^^^^^^ field does not exist
   |
  ::: compiler/src/parser/ast.rs:87:5
   |
87 |     Let(String, Option<Type>, Option<Expr>),
   |     --- `ast::Stmt::Let` defined here
   |
help: `ast::Stmt::Let` is a tuple variant, use the appropriate syntax
   |
72 -                 Ok(Stmt::Let {
73 -                     pattern: pattern.clone(),
74 -                     ty: ty.clone(),
75 -                     init,
76 -                     span: *span,
77 -                 })
72 +                 Ok(Stmt::Let(/* String */, /* Option<ast::Type> */, /* Option<ast::Expr> */))
   |

error[E0559]: variant `ast::Stmt::Let` has no field named `ty`
  --> compiler/src/macro_system/expander.rs:74:21
   |
74 |                     ty: ty.clone(),
   |                     ^^ field does not exist
   |
  ::: compiler/src/parser/ast.rs:87:5
   |
87 |     Let(String, Option<Type>, Option<Expr>),
   |     --- `ast::Stmt::Let` defined here
   |
help: `ast::Stmt::Let` is a tuple variant, use the appropriate syntax
   |
72 -                 Ok(Stmt::Let {
73 -                     pattern: pattern.clone(),
74 -                     ty: ty.clone(),
75 -                     init,
76 -                     span: *span,
77 -                 })
72 +                 Ok(Stmt::Let(/* String */, /* Option<ast::Type> */, /* Option<ast::Expr> */))
   |

error[E0559]: variant `ast::Stmt::Let` has no field named `init`
  --> compiler/src/macro_system/expander.rs:75:21
   |
75 |                     init,
   |                     ^^^^ field does not exist
   |
  ::: compiler/src/parser/ast.rs:87:5
   |
87 |     Let(String, Option<Type>, Option<Expr>),
   |     --- `ast::Stmt::Let` defined here
   |
help: `ast::Stmt::Let` is a tuple variant, use the appropriate syntax
   |
72 -                 Ok(Stmt::Let {
73 -                     pattern: pattern.clone(),
74 -                     ty: ty.clone(),
75 -                     init,
76 -                     span: *span,
77 -                 })
72 +                 Ok(Stmt::Let(/* String */, /* Option<ast::Type> */, /* Option<ast::Expr> */))
   |

error[E0559]: variant `ast::Stmt::Let` has no field named `span`
  --> compiler/src/macro_system/expander.rs:76:21
   |
76 |                     span: *span,
   |                     ^^^^ field does not exist
   |
  ::: compiler/src/parser/ast.rs:87:5
   |
87 |     Let(String, Option<Type>, Option<Expr>),
   |     --- `ast::Stmt::Let` defined here
   |
help: `ast::Stmt::Let` is a tuple variant, use the appropriate syntax
   |
72 -                 Ok(Stmt::Let {
73 -                     pattern: pattern.clone(),
74 -                     ty: ty.clone(),
75 -                     init,
76 -                     span: *span,
77 -                 })
72 +                 Ok(Stmt::Let(/* String */, /* Option<ast::Type> */, /* Option<ast::Expr> */))
   |

error[E0308]: mismatched types
  --> compiler/src/macro_system/expander.rs:86:17
   |
86 |                 format!("macro expansion depth exceeded (max: {})", self.max_depth),
   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `String`
   |
   = note: this error originates in the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0277]: the trait bound `String: From<span::Span>` is not satisfied
  --> compiler/src/macro_system/expander.rs:87:17
   |
85 |             return Err(Error::new(
   |                        ---------- required by a bound introduced by this call
86 |                 format!("macro expansion depth exceeded (max: {})", self.max_depth),
87 |                 span,
   |                 ^^^^ the trait `From<span::Span>` is not implemented for `String`
   |
   = help: the following other types implement trait `From<T>`:
             `String` implements `From<&String>`
             `String` implements `From<&mut str>`
             `String` implements `From<&str>`
             `String` implements `From<Box<str>>`
             `String` implements `From<Cow<'_, str>>`
             `String` implements `From<char>`
             `String` implements `From<clap::Id>`
             `String` implements `From<clap::builder::Str>`
   = note: required for `span::Span` to implement `Into<String>`
note: required by a bound in `error::Error::new`
  --> compiler/src/error.rs:47:47
   |
47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
   |                                               ^^^^^^^^^^^^ required by this bound in `Error::new`

error[E0308]: mismatched types
  --> compiler/src/macro_system/expander.rs:92:39
   |
92 |             .ok_or_else(|| Error::new(format!("undefined macro: {}", name), span))?;
   |                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `String`
   |
   = note: this error originates in the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0277]: the trait bound `String: From<span::Span>` is not satisfied
  --> compiler/src/macro_system/expander.rs:92:77
   |
92 |             .ok_or_else(|| Error::new(format!("undefined macro: {}", name), span))?;
   |                            ----------                                       ^^^^ the trait `From<span::Span>` is not implemented for `String`
   |                            |
   |                            required by a bound introduced by this call
   |
   = help: the following other types implement trait `From<T>`:
             `String` implements `From<&String>`
             `String` implements `From<&mut str>`
             `String` implements `From<&str>`
             `String` implements `From<Box<str>>`
             `String` implements `From<Cow<'_, str>>`
             `String` implements `From<char>`
             `String` implements `From<clap::Id>`
             `String` implements `From<clap::builder::Str>`
   = note: required for `span::Span` to implement `Into<String>`
note: required by a bound in `error::Error::new`
  --> compiler/src/error.rs:47:47
   |
47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
   |                                               ^^^^^^^^^^^^ required by this bound in `Error::new`

error[E0308]: mismatched types
   --> compiler/src/macro_system/expander.rs:110:21
    |
110 |                     format!("no matching macro rule for {}", def.name),
    |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `String`
    |
    = note: this error originates in the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0277]: the trait bound `String: From<span::Span>` is not satisfied
   --> compiler/src/macro_system/expander.rs:111:21
    |
109 |                 Err(Error::new(
    |                     ---------- required by a bound introduced by this call
110 |                     format!("no matching macro rule for {}", def.name),
111 |                     span,
    |                     ^^^^ the trait `From<span::Span>` is not implemented for `String`
    |
    = help: the following other types implement trait `From<T>`:
              `String` implements `From<&String>`
              `String` implements `From<&mut str>`
              `String` implements `From<&str>`
              `String` implements `From<Box<str>>`
              `String` implements `From<Cow<'_, str>>`
              `String` implements `From<char>`
              `String` implements `From<clap::Id>`
              `String` implements `From<clap::builder::Str>`
    = note: required for `span::Span` to implement `Into<String>`
note: required by a bound in `error::Error::new`
   --> compiler/src/error.rs:47:47
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |                                               ^^^^^^^^^^^^ required by this bound in `Error::new`

error[E0277]: the trait bound `String: From<span::Span>` is not satisfied
   --> compiler/src/macro_system/expander.rs:116:73
    |
116 |                 Err(Error::new("procedural macros not yet implemented", span))
    |                     ----------                                          ^^^^ the trait `From<span::Span>` is not implemented for `String`
    |                     |
    |                     required by a bound introduced by this call
    |
    = help: the following other types implement trait `From<T>`:
              `String` implements `From<&String>`
              `String` implements `From<&mut str>`
              `String` implements `From<&str>`
              `String` implements `From<Box<str>>`
              `String` implements `From<Cow<'_, str>>`
              `String` implements `From<char>`
              `String` implements `From<clap::Id>`
              `String` implements `From<clap::builder::Str>`
    = note: required for `span::Span` to implement `Into<String>`
note: required by a bound in `error::Error::new`
   --> compiler/src/error.rs:47:47
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |                                               ^^^^^^^^^^^^ required by this bound in `Error::new`

error[E0308]: mismatched types
   --> compiler/src/macro_system/expander.rs:116:32
    |
116 |                 Err(Error::new("procedural macros not yet implemented", span))
    |                     ---------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `&str`
    |                     |
    |                     arguments to this function are incorrect
    |
note: associated function defined here
   --> compiler/src/error.rs:47:12
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |            ^^^ ---------------

error[E0559]: variant `ast::Expr::Block` has no field named `stmts`
   --> compiler/src/macro_system/expander.rs:224:13
    |
224 |             stmts: vec![],
    |             ^^^^^ field does not exist
    |
   ::: compiler/src/parser/ast.rs:103:5
    |
103 |     Block(Vec<Stmt>),
    |     ----- `ast::Expr::Block` defined here
    |
help: `ast::Expr::Block` is a tuple variant, use the appropriate syntax
    |
223 -         Ok(Expr::Block {
224 -             stmts: vec![],
225 -             span,
226 -         })
223 +         Ok(Expr::Block(/* Vec<ast::Stmt> */))
    |

error[E0559]: variant `ast::Expr::Block` has no field named `span`
   --> compiler/src/macro_system/expander.rs:225:13
    |
225 |             span,
    |             ^^^^ field does not exist
    |
   ::: compiler/src/parser/ast.rs:103:5
    |
103 |     Block(Vec<Stmt>),
    |     ----- `ast::Expr::Block` defined here
    |
help: `ast::Expr::Block` is a tuple variant, use the appropriate syntax
    |
223 -         Ok(Expr::Block {
224 -             stmts: vec![],
225 -             span,
226 -         })
223 +         Ok(Expr::Block(/* Vec<ast::Stmt> */))
    |

error[E0599]: no function or associated item named `dummy` found for struct `span::Span` in the current scope
   --> compiler/src/macro_system/mod.rs:132:29
    |
132 |                 span: Span::dummy(),
    |                             ^^^^^ function or associated item not found in `span::Span`
    |
   ::: compiler/src/span.rs:31:1
    |
 31 | pub struct Span {
    | --------------- function or associated item `dummy` not found for this struct
    |
note: if you're trying to build a new `span::Span`, consider using `span::Span::new` which returns `span::Span`
   --> compiler/src/span.rs:37:5
    |
 37 |     pub fn new(start: Position, end: Position) -> Self {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0599]: no function or associated item named `dummy` found for struct `span::Span` in the current scope
   --> compiler/src/macro_system/mod.rs:187:29
    |
187 |                 span: Span::dummy(),
    |                             ^^^^^ function or associated item not found in `span::Span`
    |
   ::: compiler/src/span.rs:31:1
    |
 31 | pub struct Span {
    | --------------- function or associated item `dummy` not found for this struct
    |
note: if you're trying to build a new `span::Span`, consider using `span::Span::new` which returns `span::Span`
   --> compiler/src/span.rs:37:5
    |
 37 |     pub fn new(start: Position, end: Position) -> Self {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0599]: no function or associated item named `dummy` found for struct `span::Span` in the current scope
   --> compiler/src/macro_system/mod.rs:209:29
    |
209 |                 span: Span::dummy(),
    |                             ^^^^^ function or associated item not found in `span::Span`
    |
   ::: compiler/src/span.rs:31:1
    |
 31 | pub struct Span {
    | --------------- function or associated item `dummy` not found for this struct
    |
note: if you're trying to build a new `span::Span`, consider using `span::Span::new` which returns `span::Span`
   --> compiler/src/span.rs:37:5
    |
 37 |     pub fn new(start: Position, end: Position) -> Self {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0282]: type annotations needed
   --> compiler/src/async_runtime/executor.rs:132:25
    |
132 |                         task.poll(&waker);
    |                         ^^^^ cannot infer type

error[E0599]: no function or associated item named `from_millis` found for struct `async_runtime::Duration` in the current scope
   --> compiler/src/async_runtime/executor.rs:135:49
    |
135 |                         Thread::sleep(Duration::from_millis(10));
    |                                                 ^^^^^^^^^^^ function or associated item not found in `async_runtime::Duration`
    |
   ::: compiler/src/async_runtime/mod.rs:142:1
    |
142 | pub struct Duration {
    | ------------------- function or associated item `from_millis` not found for this struct

error[E0026]: variant `ast::Expr::Literal` does not have a field named `value`
   --> compiler/src/verification/smt_solver.rs:109:29
    |
109 |             Expr::Literal { value, .. } => {
    |                             ^^^^^
    |                             |
    |                             variant `ast::Expr::Literal` does not have this field
    |                             help: `ast::Expr::Literal` has a field named `0`

error[E0599]: no variant named `Variable` found for enum `ast::Expr`
   --> compiler/src/verification/smt_solver.rs:116:19
    |
116 |             Expr::Variable { name, .. } => Ok(name.clone()),
    |                   ^^^^^^^^ variant not found in `ast::Expr`
    |
   ::: compiler/src/parser/ast.rs:94:1
    |
 94 | pub enum Expr {
    | ------------- variant `Variable` not found here

error[E0026]: variant `ast::Expr::Binary` does not have fields named `op`, `left`, `right`
   --> compiler/src/verification/smt_solver.rs:117:28
    |
117 |             Expr::Binary { op, left, right, .. } => {
    |                            ^^  ^^^^  ^^^^^ variant `ast::Expr::Binary` does not have these fields

error[E0026]: variant `ast::Expr::Unary` does not have fields named `op`, `operand`
   --> compiler/src/verification/smt_solver.rs:139:27
    |
139 |             Expr::Unary { op, operand, .. } => {
    |                           ^^  ^^^^^^^ variant `ast::Expr::Unary` does not have these fields

error[E0308]: mismatched types
   --> compiler/src/verification/smt_solver.rs:113:41
    |
113 |                     _ => Err(Error::new("Unsupported literal type for SMT", Span::dummy())),
    |                              ---------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `&str`
    |                              |
    |                              arguments to this function are incorrect
    |
note: associated function defined here
   --> compiler/src/error.rs:47:12
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |            ^^^ ---------------

error[E0308]: mismatched types
   --> compiler/src/verification/smt_solver.rs:134:48
    |
134 |                     _ => return Err(Error::new("Unsupported binary operator for SMT", Span::dummy())),
    |                                     ---------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `&str`
    |                                     |
    |                                     arguments to this function are incorrect
    |
note: associated function defined here
   --> compiler/src/error.rs:47:12
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |            ^^^ ---------------

error[E0308]: mismatched types
   --> compiler/src/verification/smt_solver.rs:145:48
    |
145 |                     _ => return Err(Error::new("Unsupported unary operator for SMT", Span::dummy())),
    |                                     ---------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `&str`
    |                                     |
    |                                     arguments to this function are incorrect
    |
note: associated function defined here
   --> compiler/src/error.rs:47:12
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |            ^^^ ---------------

error[E0308]: mismatched types
   --> compiler/src/verification/smt_solver.rs:150:33
    |
150 |             _ => Err(Error::new("Unsupported expression type for SMT", Span::dummy())),
    |                      ---------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `&str`
    |                      |
    |                      arguments to this function are incorrect
    |
note: associated function defined here
   --> compiler/src/error.rs:47:12
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |            ^^^ ---------------

error[E0599]: no variant named `Variable` found for enum `ast::Expr`
   --> compiler/src/verification/smt_solver.rs:164:19
    |
164 |             Expr::Variable { name, .. } => {
    |                   ^^^^^^^^ variant not found in `ast::Expr`
    |
   ::: compiler/src/parser/ast.rs:94:1
    |
 94 | pub enum Expr {
    | ------------- variant `Variable` not found here

error[E0026]: variant `ast::Expr::Binary` does not have fields named `left`, `right`
   --> compiler/src/verification/smt_solver.rs:167:28
    |
167 |             Expr::Binary { left, right, .. } => {
    |                            ^^^^  ^^^^^ variant `ast::Expr::Binary` does not have these fields

error[E0026]: variant `ast::Expr::Unary` does not have a field named `operand`
   --> compiler/src/verification/smt_solver.rs:171:27
    |
171 |             Expr::Unary { operand, .. } => {
    |                           ^^^^^^^ variant `ast::Expr::Unary` does not have this field

error[E0308]: mismatched types
   --> compiler/src/verification/smt_solver.rs:195:37
    |
195 |             .map_err(|e| Error::new(format!("Failed to spawn SMT solver: {}", e), Span::dummy()))?;
    |                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `String`
    |
    = note: this error originates in the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0308]: mismatched types
   --> compiler/src/verification/smt_solver.rs:199:41
    |
199 |                 .map_err(|e| Error::new(format!("Failed to write to SMT solver: {}", e), Span::dummy()))?;
    |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `String`
    |
    = note: this error originates in the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0308]: mismatched types
   --> compiler/src/verification/smt_solver.rs:203:37
    |
203 |             .map_err(|e| Error::new(format!("Failed to read SMT solver output: {}", e), Span::dummy()))?;
    |                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `String`
    |
    = note: this error originates in the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0599]: no method named `prove_postcondition` found for mutable reference `&mut FormalVerifier` in the current scope
   --> compiler/src/verification/mod.rs:115:30
    |
115 |             let proof = self.prove_postcondition(func, post)?;
    |                              ^^^^^^^^^^^^^^^^^^^
    |
help: there is a method `verify_postcondition` with a similar name
    |
115 -             let proof = self.prove_postcondition(func, post)?;
115 +             let proof = self.verify_postcondition(func, post)?;
    |

error[E0599]: no method named `check_memory_safety` found for mutable reference `&mut FormalVerifier` in the current scope
   --> compiler/src/verification/mod.rs:120:34
    |
120 |         let memory_safety = self.check_memory_safety(func)?;
    |                                  ^^^^^^^^^^^^^^^^^^^
    |
help: there is a method `check_null_safety` with a similar name
    |
120 -         let memory_safety = self.check_memory_safety(func)?;
120 +         let memory_safety = self.check_null_safety(func)?;
    |

error[E0599]: no method named `prove_invariant_init` found for mutable reference `&mut FormalVerifier` in the current scope
   --> compiler/src/verification/mod.rs:136:31
    |
136 |         let init_proof = self.prove_invariant_init(&invariant)?;
    |                               ^^^^^^^^^^^^^^^^^^^^
    |
help: there is a method `verify_invariant_init` with a similar name
    |
136 -         let init_proof = self.prove_invariant_init(&invariant)?;
136 +         let init_proof = self.verify_invariant_init(&invariant)?;
    |

error[E0599]: no method named `prove_invariant_maintained` found for mutable reference `&mut FormalVerifier` in the current scope
   --> compiler/src/verification/mod.rs:142:35
    |
142 |         let maintain_proof = self.prove_invariant_maintained(&invariant, loop_stmt)?;
    |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^ method not found in `&mut FormalVerifier`

error[E0609]: no field `attributes` on type `&ast::Function`
   --> compiler/src/verification/mod.rs:204:27
    |
204 |         for attr in &func.attributes {
    |                           ^^^^^^^^^^ unknown field
    |
    = note: available fields are: `name`, `generics`, `params`, `return_type`, `where_clause`, `body`

error[E0282]: type annotations needed
   --> compiler/src/verification/mod.rs:207:40
    |
207 |                     preconditions.push(expr.clone());
    |                                        ^^^^ cannot infer type

error[E0609]: no field `attributes` on type `&ast::Function`
   --> compiler/src/verification/mod.rs:219:27
    |
219 |         for attr in &func.attributes {
    |                           ^^^^^^^^^^ unknown field
    |
    = note: available fields are: `name`, `generics`, `params`, `return_type`, `where_clause`, `body`

error[E0282]: type annotations needed
   --> compiler/src/verification/mod.rs:222:41
    |
222 |                     postconditions.push(expr.clone());
    |                                         ^^^^ cannot infer type

error[E0026]: variant `ast::Stmt::Let` does not have fields named `pattern`, `init`
   --> compiler/src/gpu/mod.rs:243:25
    |
243 |             Stmt::Let { pattern, init, .. } => {
    |                         ^^^^^^^  ^^^^ variant `ast::Stmt::Let` does not have these fields

error[E0026]: variant `ast::Expr::Literal` does not have a field named `value`
   --> compiler/src/gpu/mod.rs:259:29
    |
259 |             Expr::Literal { value, .. } => {
    |                             ^^^^^
    |                             |
    |                             variant `ast::Expr::Literal` does not have this field
    |                             help: `ast::Expr::Literal` has a field named `0`

error[E0599]: no variant named `Variable` found for enum `ast::Expr`
   --> compiler/src/gpu/mod.rs:267:19
    |
267 |             Expr::Variable { name, .. } => Ok(name.clone()),
    |                   ^^^^^^^^ variant not found in `ast::Expr`
    |
   ::: compiler/src/parser/ast.rs:94:1
    |
 94 | pub enum Expr {
    | ------------- variant `Variable` not found here

error[E0026]: variant `ast::Expr::Binary` does not have fields named `op`, `left`, `right`
   --> compiler/src/gpu/mod.rs:268:28
    |
268 |             Expr::Binary { op, left, right, .. } => {
    |                            ^^  ^^^^  ^^^^^ variant `ast::Expr::Binary` does not have these fields

error[E0599]: no variant or associated item named `I32` found for enum `ast::Type` in the current scope
   --> compiler/src/gpu/mod.rs:304:19
    |
304 |             Type::I32 => Ok("int".to_string()),
    |                   ^^^ variant or associated item not found in `ast::Type`
    |
   ::: compiler/src/parser/ast.rs:73:1
    |
 73 | pub enum Type {
    | ------------- variant or associated item `I32` not found for this enum

error[E0599]: no variant or associated item named `I64` found for enum `ast::Type` in the current scope
   --> compiler/src/gpu/mod.rs:305:19
    |
305 |             Type::I64 => Ok("long".to_string()),
    |                   ^^^ variant or associated item not found in `ast::Type`
    |
   ::: compiler/src/parser/ast.rs:73:1
    |
 73 | pub enum Type {
    | ------------- variant or associated item `I64` not found for this enum

error[E0599]: no variant or associated item named `F32` found for enum `ast::Type` in the current scope
   --> compiler/src/gpu/mod.rs:306:19
    |
306 |             Type::F32 => Ok("float".to_string()),
    |                   ^^^ variant or associated item not found in `ast::Type`
    |
   ::: compiler/src/parser/ast.rs:73:1
    |
 73 | pub enum Type {
    | ------------- variant or associated item `F32` not found for this enum

error[E0599]: no variant or associated item named `F64` found for enum `ast::Type` in the current scope
   --> compiler/src/gpu/mod.rs:307:19
    |
307 |             Type::F64 => Ok("double".to_string()),
    |                   ^^^ variant or associated item not found in `ast::Type`
    |
   ::: compiler/src/parser/ast.rs:73:1
    |
 73 | pub enum Type {
    | ------------- variant or associated item `F64` not found for this enum

error[E0599]: no variant or associated item named `Pointer` found for enum `ast::Type` in the current scope
   --> compiler/src/gpu/mod.rs:308:19
    |
308 |             Type::Pointer(inner) => Ok(format!("{}*", self.cuda_type(inner)?)),
    |                   ^^^^^^^ variant or associated item not found in `ast::Type`
    |
   ::: compiler/src/parser/ast.rs:73:1
    |
 73 | pub enum Type {
    | ------------- variant or associated item `Pointer` not found for this enum

error[E0599]: no variant or associated item named `I32` found for enum `ast::Type` in the current scope
   --> compiler/src/gpu/mod.rs:315:19
    |
315 |             Type::I32 => Ok("device int*".to_string()),
    |                   ^^^ variant or associated item not found in `ast::Type`
    |
   ::: compiler/src/parser/ast.rs:73:1
    |
 73 | pub enum Type {
    | ------------- variant or associated item `I32` not found for this enum

error[E0599]: no variant or associated item named `I64` found for enum `ast::Type` in the current scope
   --> compiler/src/gpu/mod.rs:316:19
    |
316 |             Type::I64 => Ok("device long*".to_string()),
    |                   ^^^ variant or associated item not found in `ast::Type`
    |
   ::: compiler/src/parser/ast.rs:73:1
    |
 73 | pub enum Type {
    | ------------- variant or associated item `I64` not found for this enum

error[E0599]: no variant or associated item named `F32` found for enum `ast::Type` in the current scope
   --> compiler/src/gpu/mod.rs:317:19
    |
317 |             Type::F32 => Ok("device float*".to_string()),
    |                   ^^^ variant or associated item not found in `ast::Type`
    |
   ::: compiler/src/parser/ast.rs:73:1
    |
 73 | pub enum Type {
    | ------------- variant or associated item `F32` not found for this enum

error[E0599]: no variant or associated item named `F64` found for enum `ast::Type` in the current scope
   --> compiler/src/gpu/mod.rs:318:19
    |
318 |             Type::F64 => Ok("device double*".to_string()),
    |                   ^^^ variant or associated item not found in `ast::Type`
    |
   ::: compiler/src/parser/ast.rs:73:1
    |
 73 | pub enum Type {
    | ------------- variant or associated item `F64` not found for this enum

error[E0599]: no variant or associated item named `I32` found for enum `ast::Type` in the current scope
   --> compiler/src/gpu/mod.rs:325:19
    |
325 |             Type::I32 => Ok("int".to_string()),
    |                   ^^^ variant or associated item not found in `ast::Type`
    |
   ::: compiler/src/parser/ast.rs:73:1
    |
 73 | pub enum Type {
    | ------------- variant or associated item `I32` not found for this enum

error[E0599]: no variant or associated item named `I64` found for enum `ast::Type` in the current scope
   --> compiler/src/gpu/mod.rs:326:19
    |
326 |             Type::I64 => Ok("int64_t".to_string()),
    |                   ^^^ variant or associated item not found in `ast::Type`
    |
   ::: compiler/src/parser/ast.rs:73:1
    |
 73 | pub enum Type {
    | ------------- variant or associated item `I64` not found for this enum

error[E0599]: no variant or associated item named `F32` found for enum `ast::Type` in the current scope
   --> compiler/src/gpu/mod.rs:327:19
    |
327 |             Type::F32 => Ok("float".to_string()),
    |                   ^^^ variant or associated item not found in `ast::Type`
    |
   ::: compiler/src/parser/ast.rs:73:1
    |
 73 | pub enum Type {
    | ------------- variant or associated item `F32` not found for this enum

error[E0599]: no variant or associated item named `F64` found for enum `ast::Type` in the current scope
   --> compiler/src/gpu/mod.rs:328:19
    |
328 |             Type::F64 => Ok("double".to_string()),
    |                   ^^^ variant or associated item not found in `ast::Type`
    |
   ::: compiler/src/parser/ast.rs:73:1
    |
 73 | pub enum Type {
    | ------------- variant or associated item `F64` not found for this enum

error[E0599]: no variant or associated item named `I32` found for enum `ast::Type` in the current scope
   --> compiler/src/gpu/mod.rs:335:19
    |
335 |             Type::I32 => Ok("int*".to_string()),
    |                   ^^^ variant or associated item not found in `ast::Type`
    |
   ::: compiler/src/parser/ast.rs:73:1
    |
 73 | pub enum Type {
    | ------------- variant or associated item `I32` not found for this enum

error[E0599]: no variant or associated item named `I64` found for enum `ast::Type` in the current scope
   --> compiler/src/gpu/mod.rs:336:19
    |
336 |             Type::I64 => Ok("long*".to_string()),
    |                   ^^^ variant or associated item not found in `ast::Type`
    |
   ::: compiler/src/parser/ast.rs:73:1
    |
 73 | pub enum Type {
    | ------------- variant or associated item `I64` not found for this enum

error[E0599]: no variant or associated item named `F32` found for enum `ast::Type` in the current scope
   --> compiler/src/gpu/mod.rs:337:19
    |
337 |             Type::F32 => Ok("float*".to_string()),
    |                   ^^^ variant or associated item not found in `ast::Type`
    |
   ::: compiler/src/parser/ast.rs:73:1
    |
 73 | pub enum Type {
    | ------------- variant or associated item `F32` not found for this enum

error[E0599]: no variant or associated item named `F64` found for enum `ast::Type` in the current scope
   --> compiler/src/gpu/mod.rs:338:19
    |
338 |             Type::F64 => Ok("double*".to_string()),
    |                   ^^^ variant or associated item not found in `ast::Type`
    |
   ::: compiler/src/parser/ast.rs:73:1
    |
 73 | pub enum Type {
    | ------------- variant or associated item `F64` not found for this enum

error[E0026]: variant `ast::Expr::Literal` does not have a field named `value`
  --> compiler/src/consteval/mod.rs:61:29
   |
61 |             Expr::Literal { value, .. } => self.eval_literal(value),
   |                             ^^^^^
   |                             |
   |                             variant `ast::Expr::Literal` does not have this field
   |                             help: `ast::Expr::Literal` has a field named `0`

error[E0599]: no variant named `Variable` found for enum `ast::Expr`
  --> compiler/src/consteval/mod.rs:63:19
   |
63 |             Expr::Variable { name, .. } => {
   |                   ^^^^^^^^ variant not found in `ast::Expr`
   |
  ::: compiler/src/parser/ast.rs:94:1
   |
94 | pub enum Expr {
   | ------------- variant `Variable` not found here

error[E0026]: variant `ast::Expr::Binary` does not have fields named `op`, `left`, `right`
  --> compiler/src/consteval/mod.rs:72:28
   |
72 |             Expr::Binary { op, left, right, .. } => {
   |                            ^^  ^^^^  ^^^^^ variant `ast::Expr::Binary` does not have these fields

error[E0026]: variant `ast::Expr::Unary` does not have fields named `op`, `operand`
  --> compiler/src/consteval/mod.rs:78:27
   |
78 |             Expr::Unary { op, operand, .. } => {
   |                           ^^  ^^^^^^^ variant `ast::Expr::Unary` does not have these fields

error[E0026]: variant `ast::Expr::Call` does not have fields named `func`, `args`
  --> compiler/src/consteval/mod.rs:83:26
   |
83 |             Expr::Call { func, args, .. } => {
   |                          ^^^^  ^^^^ variant `ast::Expr::Call` does not have these fields

error[E0026]: variant `ast::Expr::If` does not have fields named `condition`, `then_branch`, `else_branch`
  --> compiler/src/consteval/mod.rs:87:24
   |
87 |             Expr::If { condition, then_branch, else_branch, .. } => {
   |                        ^^^^^^^^^  ^^^^^^^^^^^  ^^^^^^^^^^^ variant `ast::Expr::If` does not have these fields

error[E0026]: variant `ast::Expr::Array` does not have a field named `elements`
  --> compiler/src/consteval/mod.rs:98:27
   |
98 |             Expr::Array { elements, .. } => {
   |                           ^^^^^^^^
   |                           |
   |                           variant `ast::Expr::Array` does not have this field
   |                           help: `ast::Expr::Array` has a field named `0`

error[E0308]: mismatched types
  --> compiler/src/consteval/mod.rs:67:25
   |
67 |                         format!("Undefined constant: {}", name),
   |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `String`
   |
   = note: this error originates in the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0308]: mismatched types
   --> compiler/src/consteval/mod.rs:107:17
    |
106 |             _ => Err(Error::new(
    |                      ---------- arguments to this function are incorrect
107 |                 "Expression cannot be evaluated at compile time",
    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `&str`
    |
note: associated function defined here
   --> compiler/src/error.rs:47:12
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |            ^^^ ---------------

error[E0308]: mismatched types
   --> compiler/src/consteval/mod.rs:132:51
    |
132 | ...                   return Err(Error::new("Division by zero", Span::dummy()));
    |                                  ---------- ^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `&str`
    |                                  |
    |                                  arguments to this function are incorrect
    |
note: associated function defined here
   --> compiler/src/error.rs:47:12
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |            ^^^ ---------------

error[E0308]: mismatched types
   --> compiler/src/consteval/mod.rs:148:48
    |
148 |                     _ => return Err(Error::new("Unsupported binary operation", Span::dummy())),
    |                                     ---------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `&str`
    |                                     |
    |                                     arguments to this function are incorrect
    |
note: associated function defined here
   --> compiler/src/error.rs:47:12
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |            ^^^ ---------------

error[E0308]: mismatched types
   --> compiler/src/consteval/mod.rs:165:48
    |
165 |                     _ => return Err(Error::new("Unsupported binary operation", Span::dummy())),
    |                                     ---------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `&str`
    |                                     |
    |                                     arguments to this function are incorrect
    |
note: associated function defined here
   --> compiler/src/error.rs:47:12
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |            ^^^ ---------------

error[E0308]: mismatched types
   --> compiler/src/consteval/mod.rs:176:48
    |
176 |                     _ => return Err(Error::new("Unsupported binary operation", Span::dummy())),
    |                                     ---------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `&str`
    |                                     |
    |                                     arguments to this function are incorrect
    |
note: associated function defined here
   --> compiler/src/error.rs:47:12
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |            ^^^ ---------------

error[E0308]: mismatched types
   --> compiler/src/consteval/mod.rs:181:33
    |
181 |             _ => Err(Error::new("Type mismatch in binary operation", Span::dummy())),
    |                      ---------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `&str`
    |                      |
    |                      arguments to this function are incorrect
    |
note: associated function defined here
   --> compiler/src/error.rs:47:12
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |            ^^^ ---------------

error[E0308]: mismatched types
   --> compiler/src/consteval/mod.rs:192:48
    |
192 |                     _ => return Err(Error::new("Unsupported unary operation", Span::dummy())),
    |                                     ---------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `&str`
    |                                     |
    |                                     arguments to this function are incorrect
    |
note: associated function defined here
   --> compiler/src/error.rs:47:12
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |            ^^^ ---------------

error[E0308]: mismatched types
   --> compiler/src/consteval/mod.rs:200:48
    |
200 |                     _ => return Err(Error::new("Unsupported unary operation", Span::dummy())),
    |                                     ---------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `&str`
    |                                     |
    |                                     arguments to this function are incorrect
    |
note: associated function defined here
   --> compiler/src/error.rs:47:12
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |            ^^^ ---------------

error[E0308]: mismatched types
   --> compiler/src/consteval/mod.rs:208:48
    |
208 |                     _ => return Err(Error::new("Unsupported unary operation", Span::dummy())),
    |                                     ---------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `&str`
    |                                     |
    |                                     arguments to this function are incorrect
    |
note: associated function defined here
   --> compiler/src/error.rs:47:12
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |            ^^^ ---------------

error[E0308]: mismatched types
   --> compiler/src/consteval/mod.rs:213:33
    |
213 |             _ => Err(Error::new("Type mismatch in unary operation", Span::dummy())),
    |                      ---------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `&str`
    |                      |
    |                      arguments to this function are incorrect
    |
note: associated function defined here
   --> compiler/src/error.rs:47:12
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |            ^^^ ---------------

error[E0599]: no variant named `Variable` found for enum `ast::Expr`
   --> compiler/src/consteval/mod.rs:220:19
    |
220 |             Expr::Variable { name, .. } => name,
    |                   ^^^^^^^^ variant not found in `ast::Expr`
    |
   ::: compiler/src/parser/ast.rs:94:1
    |
 94 | pub enum Expr {
    | ------------- variant `Variable` not found here

error[E0308]: mismatched types
   --> compiler/src/consteval/mod.rs:221:40
    |
221 |             _ => return Err(Error::new("Invalid function call", Span::dummy())),
    |                             ---------- ^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `&str`
    |                             |
    |                             arguments to this function are incorrect
    |
note: associated function defined here
   --> compiler/src/error.rs:47:12
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |            ^^^ ---------------

error[E0308]: mismatched types
   --> compiler/src/consteval/mod.rs:238:17
    |
238 |                 format!("Unknown compile-time function: {}", func_name),
    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `String`
    |
    = note: this error originates in the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0308]: mismatched types
   --> compiler/src/consteval/mod.rs:246:35
    |
246 |             return Err(Error::new("abs expects 1 argument", Span::dummy()));
    |                        ---------- ^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `&str`
    |                        |
    |                        arguments to this function are incorrect
    |
note: associated function defined here
   --> compiler/src/error.rs:47:12
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |            ^^^ ---------------

error[E0308]: mismatched types
   --> compiler/src/consteval/mod.rs:252:33
    |
252 |             _ => Err(Error::new("abs expects numeric argument", Span::dummy())),
    |                      ---------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `&str`
    |                      |
    |                      arguments to this function are incorrect
    |
note: associated function defined here
   --> compiler/src/error.rs:47:12
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |            ^^^ ---------------

error[E0308]: mismatched types
   --> compiler/src/consteval/mod.rs:258:35
    |
258 |             return Err(Error::new("min expects 2 arguments", Span::dummy()));
    |                        ---------- ^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `&str`
    |                        |
    |                        arguments to this function are incorrect
    |
note: associated function defined here
   --> compiler/src/error.rs:47:12
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |            ^^^ ---------------

error[E0308]: mismatched types
   --> compiler/src/consteval/mod.rs:264:33
    |
264 |             _ => Err(Error::new("min expects numeric arguments", Span::dummy())),
    |                      ---------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `&str`
    |                      |
    |                      arguments to this function are incorrect
    |
note: associated function defined here
   --> compiler/src/error.rs:47:12
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |            ^^^ ---------------

error[E0308]: mismatched types
   --> compiler/src/consteval/mod.rs:270:35
    |
270 |             return Err(Error::new("max expects 2 arguments", Span::dummy()));
    |                        ---------- ^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `&str`
    |                        |
    |                        arguments to this function are incorrect
    |
note: associated function defined here
   --> compiler/src/error.rs:47:12
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |            ^^^ ---------------

error[E0308]: mismatched types
   --> compiler/src/consteval/mod.rs:276:33
    |
276 |             _ => Err(Error::new("max expects numeric arguments", Span::dummy())),
    |                      ---------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `&str`
    |                      |
    |                      arguments to this function are incorrect
    |
note: associated function defined here
   --> compiler/src/error.rs:47:12
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |            ^^^ ---------------

error[E0308]: mismatched types
   --> compiler/src/consteval/mod.rs:282:35
    |
282 |             return Err(Error::new("pow expects 2 arguments", Span::dummy()));
    |                        ---------- ^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `&str`
    |                        |
    |                        arguments to this function are incorrect
    |
note: associated function defined here
   --> compiler/src/error.rs:47:12
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |            ^^^ ---------------

error[E0308]: mismatched types
   --> compiler/src/consteval/mod.rs:291:43
    |
291 |                     return Err(Error::new("Negative exponent for integer pow", Span::dummy()));
    |                                ---------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `&str`
    |                                |
    |                                arguments to this function are incorrect
    |
note: associated function defined here
   --> compiler/src/error.rs:47:12
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |            ^^^ ---------------

error[E0308]: mismatched types
   --> compiler/src/consteval/mod.rs:295:33
    |
295 |             _ => Err(Error::new("pow expects numeric arguments", Span::dummy())),
    |                      ---------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `&str`
    |                      |
    |                      arguments to this function are incorrect
    |
note: associated function defined here
   --> compiler/src/error.rs:47:12
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |            ^^^ ---------------

error[E0308]: mismatched types
   --> compiler/src/consteval/mod.rs:301:35
    |
301 |             return Err(Error::new("sqrt expects 1 argument", Span::dummy()));
    |                        ---------- ^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `&str`
    |                        |
    |                        arguments to this function are incorrect
    |
note: associated function defined here
   --> compiler/src/error.rs:47:12
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |            ^^^ ---------------

error[E0308]: mismatched types
   --> compiler/src/consteval/mod.rs:307:43
    |
307 |                     return Err(Error::new("sqrt of negative number", Span::dummy()));
    |                                ---------- ^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `&str`
    |                                |
    |                                arguments to this function are incorrect
    |
note: associated function defined here
   --> compiler/src/error.rs:47:12
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |            ^^^ ---------------

error[E0308]: mismatched types
   --> compiler/src/consteval/mod.rs:311:33
    |
311 |             _ => Err(Error::new("sqrt expects float argument", Span::dummy())),
    |                      ---------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `&str`
    |                      |
    |                      arguments to this function are incorrect
    |
note: associated function defined here
   --> compiler/src/error.rs:47:12
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |            ^^^ ---------------

warning: unused variable: `func`
   --> compiler/src/verification/mod.rs:194:41
    |
194 |     fn check_overflow_safety(&mut self, func: &Function) -> Result<bool> {
    |                                         ^^^^ help: if this is intentional, prefix it with an underscore: `_func`
    |
    = note: `#[warn(unused_variables)]` (part of `#[warn(unused)]`) on by default

error[E0594]: cannot assign to `proof.status`, as `proof` is not declared as mutable
   --> compiler/src/verification/mod.rs:247:13
    |
247 |             proof.status = ProofStatus::Proven;
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ cannot assign
    |
help: consider changing this to be mutable
    |
237 |         let mut proof = Proof {
    |             +++

error[E0594]: cannot assign to `proof.status`, as `proof` is not declared as mutable
   --> compiler/src/verification/mod.rs:249:13
    |
249 |             proof.status = ProofStatus::Failed;
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ cannot assign
    |
help: consider changing this to be mutable
    |
237 |         let mut proof = Proof {
    |             +++

warning: variable does not need to be mutable
   --> compiler/src/verification/mod.rs:268:13
    |
268 |         let mut proof = Proof {
    |             ----^^^^^
    |             |
    |             help: remove this `mut`
    |
    = note: `#[warn(unused_mut)]` (part of `#[warn(unused)]`) on by default

Some errors have detailed explanations: E0023, E0026, E0027, E0277, E0282, E0308, E0412, E0432, E0433...
For more information about an error, try `rustc --explain E0023`.
warning: `vez_compiler` (lib) generated 14 warnings
error: could not compile `vez_compiler` (lib) due to 288 previous errors; 14 warnings emitted
[0;32mâœ“[0m Compiler library built successfully
[1;33mâ†’[0m Building compiler binary...
warning: profiles for the non root package will be ignored, specify profiles at the workspace root:
package:   /run/media/zarigata/42A0B8BDA0B8B8AD/ARTIFICIAL-INTELIGENCE/ArtificialProgramingLanguage/compiler/Cargo.toml
workspace: /run/media/zarigata/42A0B8BDA0B8B8AD/ARTIFICIAL-INTELIGENCE/ArtificialProgramingLanguage/Cargo.toml
   Compiling vez_compiler v0.1.0 (/run/media/zarigata/42A0B8BDA0B8B8AD/ARTIFICIAL-INTELIGENCE/ArtificialProgramingLanguage/compiler)
error[E0583]: file not found for module `hygiene`
 --> compiler/src/macro_system/mod.rs:5:1
  |
5 | pub mod hygiene;
  | ^^^^^^^^^^^^^^^^
  |
  = help: to create the module `hygiene`, create file "compiler/src/macro_system/hygiene.rs" or "compiler/src/macro_system/hygiene/mod.rs"
  = note: if there is a `mod hygiene` elsewhere in the crate already, import it with `use crate::...` instead

error[E0583]: file not found for module `parser`
 --> compiler/src/macro_system/mod.rs:6:1
  |
6 | pub mod parser;
  | ^^^^^^^^^^^^^^^
  |
  = help: to create the module `parser`, create file "compiler/src/macro_system/parser.rs" or "compiler/src/macro_system/parser/mod.rs"
  = note: if there is a `mod parser` elsewhere in the crate already, import it with `use crate::...` instead

error[E0583]: file not found for module `builtin`
 --> compiler/src/macro_system/mod.rs:7:1
  |
7 | pub mod builtin;
  | ^^^^^^^^^^^^^^^^
  |
  = help: to create the module `builtin`, create file "compiler/src/macro_system/builtin.rs" or "compiler/src/macro_system/builtin/mod.rs"
  = note: if there is a `mod builtin` elsewhere in the crate already, import it with `use crate::...` instead

error[E0583]: file not found for module `future`
 --> compiler/src/async_runtime/mod.rs:4:1
  |
4 | pub mod future;
  | ^^^^^^^^^^^^^^^
  |
  = help: to create the module `future`, create file "compiler/src/async_runtime/future.rs" or "compiler/src/async_runtime/future/mod.rs"
  = note: if there is a `mod future` elsewhere in the crate already, import it with `use crate::...` instead

error[E0583]: file not found for module `task`
 --> compiler/src/async_runtime/mod.rs:6:1
  |
6 | pub mod task;
  | ^^^^^^^^^^^^^
  |
  = help: to create the module `task`, create file "compiler/src/async_runtime/task.rs" or "compiler/src/async_runtime/task/mod.rs"
  = note: if there is a `mod task` elsewhere in the crate already, import it with `use crate::...` instead

error[E0583]: file not found for module `waker`
 --> compiler/src/async_runtime/mod.rs:7:1
  |
7 | pub mod waker;
  | ^^^^^^^^^^^^^^
  |
  = help: to create the module `waker`, create file "compiler/src/async_runtime/waker.rs" or "compiler/src/async_runtime/waker/mod.rs"
  = note: if there is a `mod waker` elsewhere in the crate already, import it with `use crate::...` instead

error[E0583]: file not found for module `proof_engine`
 --> compiler/src/verification/mod.rs:5:1
  |
5 | pub mod proof_engine;
  | ^^^^^^^^^^^^^^^^^^^^^
  |
  = help: to create the module `proof_engine`, create file "compiler/src/verification/proof_engine.rs" or "compiler/src/verification/proof_engine/mod.rs"
  = note: if there is a `mod proof_engine` elsewhere in the crate already, import it with `use crate::...` instead

error[E0583]: file not found for module `safety_checker`
 --> compiler/src/verification/mod.rs:6:1
  |
6 | pub mod safety_checker;
  | ^^^^^^^^^^^^^^^^^^^^^^^
  |
  = help: to create the module `safety_checker`, create file "compiler/src/verification/safety_checker.rs" or "compiler/src/verification/safety_checker/mod.rs"
  = note: if there is a `mod safety_checker` elsewhere in the crate already, import it with `use crate::...` instead

error[E0583]: file not found for module `contracts`
 --> compiler/src/verification/mod.rs:7:1
  |
7 | pub mod contracts;
  | ^^^^^^^^^^^^^^^^^^
  |
  = help: to create the module `contracts`, create file "compiler/src/verification/contracts.rs" or "compiler/src/verification/contracts/mod.rs"
  = note: if there is a `mod contracts` elsewhere in the crate already, import it with `use crate::...` instead

error[E0583]: file not found for module `cuda`
 --> compiler/src/gpu/mod.rs:4:1
  |
4 | pub mod cuda;
  | ^^^^^^^^^^^^^
  |
  = help: to create the module `cuda`, create file "compiler/src/gpu/cuda.rs" or "compiler/src/gpu/cuda/mod.rs"
  = note: if there is a `mod cuda` elsewhere in the crate already, import it with `use crate::...` instead

error[E0583]: file not found for module `metal`
 --> compiler/src/gpu/mod.rs:5:1
  |
5 | pub mod metal;
  | ^^^^^^^^^^^^^^
  |
  = help: to create the module `metal`, create file "compiler/src/gpu/metal.rs" or "compiler/src/gpu/metal/mod.rs"
  = note: if there is a `mod metal` elsewhere in the crate already, import it with `use crate::...` instead

error[E0583]: file not found for module `vulkan`
 --> compiler/src/gpu/mod.rs:6:1
  |
6 | pub mod vulkan;
  | ^^^^^^^^^^^^^^^
  |
  = help: to create the module `vulkan`, create file "compiler/src/gpu/vulkan.rs" or "compiler/src/gpu/vulkan/mod.rs"
  = note: if there is a `mod vulkan` elsewhere in the crate already, import it with `use crate::...` instead

error[E0583]: file not found for module `kernel`
 --> compiler/src/gpu/mod.rs:7:1
  |
7 | pub mod kernel;
  | ^^^^^^^^^^^^^^^
  |
  = help: to create the module `kernel`, create file "compiler/src/gpu/kernel.rs" or "compiler/src/gpu/kernel/mod.rs"
  = note: if there is a `mod kernel` elsewhere in the crate already, import it with `use crate::...` instead

error[E0432]: unresolved import `crate::semantic::types`
  --> compiler/src/verification/mod.rs:10:22
   |
10 | use crate::semantic::types::Type;
   |                      ^^^^^ could not find `types` in `semantic`

error[E0432]: unresolved import `crate::semantic::types`
 --> compiler/src/consteval/mod.rs:5:22
  |
5 | use crate::semantic::types::Type;
  |                      ^^^^^ could not find `types` in `semantic`

error[E0432]: unresolved import `crate::error::CompilerError`
 --> compiler/src/codegen/llvm_backend.rs:6:28
  |
6 | use crate::error::{Result, CompilerError};
  |                            ^^^^^^^^^^^^^ no `CompilerError` in `error`

error[E0432]: unresolved import `crate::error::CompilerError`
 --> compiler/src/codegen/target.rs:3:28
  |
3 | use crate::error::{Result, CompilerError};
  |                            ^^^^^^^^^^^^^ no `CompilerError` in `error`

error[E0432]: unresolved import `crate::error::CompilerError`
 --> compiler/src/codegen/linker.rs:3:28
  |
3 | use crate::error::{Result, CompilerError};
  |                            ^^^^^^^^^^^^^ no `CompilerError` in `error`

error[E0532]: expected tuple struct or tuple variant, found unit variant `Constant::Null`
   --> compiler/src/codegen/llvm_backend.rs:129:13
    |
129 |             Constant::Null(ty) => format!("{} null", self.type_to_llvm(ty)),
    |             ^^^^^^^^^^^^^^^^^^ help: use this syntax instead: `Constant::Null`
    |
   ::: compiler/src/ir/ssa.rs:30:5
    |
 30 |     Null,
    |     ---- `Constant::Null` defined here

error[E0532]: expected tuple struct or tuple variant, found unit variant `Constant::Undef`
   --> compiler/src/codegen/llvm_backend.rs:130:13
    |
130 |             Constant::Undef(ty) => format!("{} undef", self.type_to_llvm(ty)),
    |             ^^^^^^^^^^^^^^^^^^^ help: use this syntax instead: `Constant::Undef`
    |
   ::: compiler/src/ir/ssa.rs:31:5
    |
 31 |     Undef,
    |     ----- `Constant::Undef` defined here

error[E0433]: failed to resolve: use of undeclared type `Pin`
  --> compiler/src/async_runtime/executor.rs:64:19
   |
64 |             match Pin::new(&mut future).poll(&waker) {
   |                   ^^^ use of undeclared type `Pin`
   |
help: consider importing this struct
   |
 4 + use std::pin::Pin;
   |

error[E0412]: cannot find type `Thread` in this scope
   --> compiler/src/async_runtime/executor.rs:112:18
    |
112 |     threads: Vec<Thread>,
    |                  ^^^^^^ not found in this scope
    |
help: consider importing this struct
    |
  4 + use std::thread::Thread;
    |

error[E0412]: cannot find type `Arc` in this scope
   --> compiler/src/async_runtime/executor.rs:113:17
    |
113 |     task_queue: Arc<Mutex<VecDeque<Box<dyn Task>>>>,
    |                 ^^^ not found in this scope
    |
help: consider importing this struct
    |
  4 + use std::sync::Arc;
    |

error[E0412]: cannot find type `Mutex` in this scope
   --> compiler/src/async_runtime/executor.rs:113:21
    |
113 |     task_queue: Arc<Mutex<VecDeque<Box<dyn Task>>>>,
    |                     ^^^^^ not found in this scope
    |
help: consider importing one of these structs
    |
  4 + use std::sync::Mutex;
    |
  4 + use std::sync::nonpoison::Mutex;
    |

error[E0433]: failed to resolve: use of undeclared type `Arc`
   --> compiler/src/async_runtime/executor.rs:118:26
    |
118 |         let task_queue = Arc::new(Mutex::new(VecDeque::new()));
    |                          ^^^ use of undeclared type `Arc`
    |
help: consider importing this struct
    |
  4 + use std::sync::Arc;
    |

error[E0433]: failed to resolve: use of undeclared type `Mutex`
   --> compiler/src/async_runtime/executor.rs:118:35
    |
118 |         let task_queue = Arc::new(Mutex::new(VecDeque::new()));
    |                                   ^^^^^ use of undeclared type `Mutex`
    |
help: consider importing one of these structs
    |
  4 + use std::sync::Mutex;
    |
  4 + use std::sync::nonpoison::Mutex;
    |

error[E0433]: failed to resolve: use of undeclared type `Thread`
   --> compiler/src/async_runtime/executor.rs:123:26
    |
123 |             let thread = Thread::spawn(move || {
    |                          ^^^^^^ use of undeclared type `Thread`
    |
help: consider importing this struct
    |
  4 + use std::thread::Thread;
    |

error[E0433]: failed to resolve: use of undeclared type `Thread`
   --> compiler/src/async_runtime/executor.rs:135:25
    |
135 |                         Thread::sleep(Duration::from_millis(10));
    |                         ^^^^^^ use of undeclared type `Thread`
    |
help: consider importing this struct
    |
  4 + use std::thread::Thread;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/verification/smt_solver.rs:113:77
    |
113 |                     _ => Err(Error::new("Unsupported literal type for SMT", Span::dummy())),
    |                                                                             ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/verification/smt_solver.rs:122:21
    |
122 |                     BinaryOp::Add => "+",
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/verification/smt_solver.rs:123:21
    |
123 |                     BinaryOp::Sub => "-",
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/verification/smt_solver.rs:124:21
    |
124 |                     BinaryOp::Mul => "*",
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/verification/smt_solver.rs:125:21
    |
125 |                     BinaryOp::Div => "div",
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/verification/smt_solver.rs:126:21
    |
126 |                     BinaryOp::Eq => "=",
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/verification/smt_solver.rs:127:21
    |
127 |                     BinaryOp::Ne => "distinct",
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/verification/smt_solver.rs:128:21
    |
128 |                     BinaryOp::Lt => "<",
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/verification/smt_solver.rs:129:21
    |
129 |                     BinaryOp::Le => "<=",
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/verification/smt_solver.rs:130:21
    |
130 |                     BinaryOp::Gt => ">",
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/verification/smt_solver.rs:131:21
    |
131 |                     BinaryOp::Ge => ">=",
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/verification/smt_solver.rs:132:21
    |
132 |                     BinaryOp::And => "and",
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/verification/smt_solver.rs:133:21
    |
133 |                     BinaryOp::Or => "or",
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/verification/smt_solver.rs:134:87
    |
134 |                     _ => return Err(Error::new("Unsupported binary operator for SMT", Span::dummy())),
    |                                                                                       ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0433]: failed to resolve: use of undeclared type `UnaryOp`
   --> compiler/src/verification/smt_solver.rs:143:21
    |
143 |                     UnaryOp::Not => "not",
    |                     ^^^^^^^ use of undeclared type `UnaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::UnaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `UnaryOp`
   --> compiler/src/verification/smt_solver.rs:144:21
    |
144 |                     UnaryOp::Neg => "-",
    |                     ^^^^^^^ use of undeclared type `UnaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::UnaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/verification/smt_solver.rs:145:86
    |
145 |                     _ => return Err(Error::new("Unsupported unary operator for SMT", Span::dummy())),
    |                                                                                      ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/verification/smt_solver.rs:150:72
    |
150 |             _ => Err(Error::new("Unsupported expression type for SMT", Span::dummy())),
    |                                                                        ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/verification/smt_solver.rs:195:83
    |
195 |             .map_err(|e| Error::new(format!("Failed to spawn SMT solver: {}", e), Span::dummy()))?;
    |                                                                                   ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/verification/smt_solver.rs:199:90
    |
199 |                 .map_err(|e| Error::new(format!("Failed to write to SMT solver: {}", e), Span::dummy()))?;
    |                                                                                          ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/verification/smt_solver.rs:203:89
    |
203 |             .map_err(|e| Error::new(format!("Failed to read SMT solver output: {}", e), Span::dummy()))?;
    |                                                                                         ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0412]: cannot find type `BinaryOp` in this scope
   --> compiler/src/gpu/mod.rs:285:34
    |
285 |     fn binary_op_str(&self, op: &BinaryOp) -> &str {
    |                                  ^^^^^^^^ not found in this scope
    |
help: consider importing this enum
    |
  9 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/gpu/mod.rs:287:13
    |
287 |             BinaryOp::Add => "+",
    |             ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  9 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/gpu/mod.rs:288:13
    |
288 |             BinaryOp::Sub => "-",
    |             ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  9 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/gpu/mod.rs:289:13
    |
289 |             BinaryOp::Mul => "*",
    |             ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  9 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/gpu/mod.rs:290:13
    |
290 |             BinaryOp::Div => "/",
    |             ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  9 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/gpu/mod.rs:291:13
    |
291 |             BinaryOp::Mod => "%",
    |             ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  9 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/gpu/mod.rs:292:13
    |
292 |             BinaryOp::Eq => "==",
    |             ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  9 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/gpu/mod.rs:293:13
    |
293 |             BinaryOp::Ne => "!=",
    |             ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  9 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/gpu/mod.rs:294:13
    |
294 |             BinaryOp::Lt => "<",
    |             ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  9 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/gpu/mod.rs:295:13
    |
295 |             BinaryOp::Le => "<=",
    |             ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  9 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/gpu/mod.rs:296:13
    |
296 |             BinaryOp::Gt => ">",
    |             ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  9 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/gpu/mod.rs:297:13
    |
297 |             BinaryOp::Ge => ">=",
    |             ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  9 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
  --> compiler/src/consteval/mod.rs:68:25
   |
68 |                         Span::dummy()
   |                         ^^^^ use of undeclared type `Span`
   |
help: consider importing this struct through its public re-export
   |
 4 + use crate::prelude::Span;
   |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/consteval/mod.rs:108:17
    |
108 |                 Span::dummy()
    |                 ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0412]: cannot find type `BinaryOp` in this scope
   --> compiler/src/consteval/mod.rs:123:34
    |
123 |     fn eval_binary_op(&self, op: BinaryOp, left: &ConstValue, right: &ConstValue) -> Result<ConstValue> {
    |                                  ^^^^^^^^ not found in this scope
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:127:21
    |
127 |                     BinaryOp::Add => ConstValue::Int(l + r),
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:128:21
    |
128 |                     BinaryOp::Sub => ConstValue::Int(l - r),
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:129:21
    |
129 |                     BinaryOp::Mul => ConstValue::Int(l * r),
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:130:21
    |
130 |                     BinaryOp::Div => {
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/consteval/mod.rs:132:71
    |
132 | ...                   return Err(Error::new("Division by zero", Span::dummy()));
    |                                                                 ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:136:21
    |
136 |                     BinaryOp::Mod => ConstValue::Int(l % r),
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:137:21
    |
137 |                     BinaryOp::Eq => ConstValue::Bool(l == r),
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:138:21
    |
138 |                     BinaryOp::Ne => ConstValue::Bool(l != r),
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:139:21
    |
139 |                     BinaryOp::Lt => ConstValue::Bool(l < r),
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:140:21
    |
140 |                     BinaryOp::Le => ConstValue::Bool(l <= r),
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:141:21
    |
141 |                     BinaryOp::Gt => ConstValue::Bool(l > r),
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:142:21
    |
142 |                     BinaryOp::Ge => ConstValue::Bool(l >= r),
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:143:21
    |
143 |                     BinaryOp::BitAnd => ConstValue::Int(l & r),
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:144:21
    |
144 |                     BinaryOp::BitOr => ConstValue::Int(l | r),
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:145:21
    |
145 |                     BinaryOp::BitXor => ConstValue::Int(l ^ r),
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:146:21
    |
146 |                     BinaryOp::Shl => ConstValue::Int(l << r),
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:147:21
    |
147 |                     BinaryOp::Shr => ConstValue::Int(l >> r),
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/consteval/mod.rs:148:80
    |
148 |                     _ => return Err(Error::new("Unsupported binary operation", Span::dummy())),
    |                                                                                ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:155:21
    |
155 |                     BinaryOp::Add => ConstValue::Float(l + r),
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:156:21
    |
156 |                     BinaryOp::Sub => ConstValue::Float(l - r),
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:157:21
    |
157 |                     BinaryOp::Mul => ConstValue::Float(l * r),
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:158:21
    |
158 |                     BinaryOp::Div => ConstValue::Float(l / r),
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:159:21
    |
159 |                     BinaryOp::Eq => ConstValue::Bool(l == r),
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:160:21
    |
160 |                     BinaryOp::Ne => ConstValue::Bool(l != r),
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:161:21
    |
161 |                     BinaryOp::Lt => ConstValue::Bool(l < r),
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:162:21
    |
162 |                     BinaryOp::Le => ConstValue::Bool(l <= r),
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:163:21
    |
163 |                     BinaryOp::Gt => ConstValue::Bool(l > r),
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:164:21
    |
164 |                     BinaryOp::Ge => ConstValue::Bool(l >= r),
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/consteval/mod.rs:165:80
    |
165 |                     _ => return Err(Error::new("Unsupported binary operation", Span::dummy())),
    |                                                                                ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:172:21
    |
172 |                     BinaryOp::And => ConstValue::Bool(*l && *r),
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:173:21
    |
173 |                     BinaryOp::Or => ConstValue::Bool(*l || *r),
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:174:21
    |
174 |                     BinaryOp::Eq => ConstValue::Bool(l == r),
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:175:21
    |
175 |                     BinaryOp::Ne => ConstValue::Bool(l != r),
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/consteval/mod.rs:176:80
    |
176 |                     _ => return Err(Error::new("Unsupported binary operation", Span::dummy())),
    |                                                                                ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/consteval/mod.rs:181:70
    |
181 |             _ => Err(Error::new("Type mismatch in binary operation", Span::dummy())),
    |                                                                      ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0412]: cannot find type `UnaryOp` in this scope
   --> compiler/src/consteval/mod.rs:185:33
    |
185 |     fn eval_unary_op(&self, op: UnaryOp, val: &ConstValue) -> Result<ConstValue> {
    |                                 ^^^^^^^ not found in this scope
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::UnaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `UnaryOp`
   --> compiler/src/consteval/mod.rs:189:21
    |
189 |                     UnaryOp::Neg => ConstValue::Int(-n),
    |                     ^^^^^^^ use of undeclared type `UnaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::UnaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `UnaryOp`
   --> compiler/src/consteval/mod.rs:190:21
    |
190 |                     UnaryOp::Not => ConstValue::Bool(*n == 0),
    |                     ^^^^^^^ use of undeclared type `UnaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::UnaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `UnaryOp`
   --> compiler/src/consteval/mod.rs:191:21
    |
191 |                     UnaryOp::BitNot => ConstValue::Int(!n),
    |                     ^^^^^^^ use of undeclared type `UnaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::UnaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/consteval/mod.rs:192:79
    |
192 |                     _ => return Err(Error::new("Unsupported unary operation", Span::dummy())),
    |                                                                               ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0433]: failed to resolve: use of undeclared type `UnaryOp`
   --> compiler/src/consteval/mod.rs:199:21
    |
199 |                     UnaryOp::Neg => ConstValue::Float(-f),
    |                     ^^^^^^^ use of undeclared type `UnaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::UnaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/consteval/mod.rs:200:79
    |
200 |                     _ => return Err(Error::new("Unsupported unary operation", Span::dummy())),
    |                                                                               ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0433]: failed to resolve: use of undeclared type `UnaryOp`
   --> compiler/src/consteval/mod.rs:207:21
    |
207 |                     UnaryOp::Not => ConstValue::Bool(!b),
    |                     ^^^^^^^ use of undeclared type `UnaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::UnaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/consteval/mod.rs:208:79
    |
208 |                     _ => return Err(Error::new("Unsupported unary operation", Span::dummy())),
    |                                                                               ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/consteval/mod.rs:213:69
    |
213 |             _ => Err(Error::new("Type mismatch in unary operation", Span::dummy())),
    |                                                                     ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/consteval/mod.rs:221:65
    |
221 |             _ => return Err(Error::new("Invalid function call", Span::dummy())),
    |                                                                 ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/consteval/mod.rs:239:17
    |
239 |                 Span::dummy()
    |                 ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/consteval/mod.rs:246:61
    |
246 |             return Err(Error::new("abs expects 1 argument", Span::dummy()));
    |                                                             ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/consteval/mod.rs:252:65
    |
252 |             _ => Err(Error::new("abs expects numeric argument", Span::dummy())),
    |                                                                 ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/consteval/mod.rs:258:62
    |
258 |             return Err(Error::new("min expects 2 arguments", Span::dummy()));
    |                                                              ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/consteval/mod.rs:264:66
    |
264 |             _ => Err(Error::new("min expects numeric arguments", Span::dummy())),
    |                                                                  ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/consteval/mod.rs:270:62
    |
270 |             return Err(Error::new("max expects 2 arguments", Span::dummy()));
    |                                                              ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/consteval/mod.rs:276:66
    |
276 |             _ => Err(Error::new("max expects numeric arguments", Span::dummy())),
    |                                                                  ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/consteval/mod.rs:282:62
    |
282 |             return Err(Error::new("pow expects 2 arguments", Span::dummy()));
    |                                                              ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/consteval/mod.rs:291:80
    |
291 |                     return Err(Error::new("Negative exponent for integer pow", Span::dummy()));
    |                                                                                ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/consteval/mod.rs:295:66
    |
295 |             _ => Err(Error::new("pow expects numeric arguments", Span::dummy())),
    |                                                                  ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/consteval/mod.rs:301:62
    |
301 |             return Err(Error::new("sqrt expects 1 argument", Span::dummy()));
    |                                                              ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/consteval/mod.rs:307:70
    |
307 |                     return Err(Error::new("sqrt of negative number", Span::dummy()));
    |                                                                      ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/consteval/mod.rs:311:64
    |
311 |             _ => Err(Error::new("sqrt expects float argument", Span::dummy())),
    |                                                                ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0412]: cannot find type `BinaryOp` in this scope
  --> compiler/src/plugin/api.rs:60:40
   |
60 |     pub fn create_binary_op(&self, op: BinaryOp, left: Expr, right: Expr) -> Expr {
   |                                        ^^^^^^^^ not found in this scope
   |
help: consider importing this enum
   |
 4 + use crate::ir::instructions::BinaryOp;
   |

error[E0412]: cannot find type `Span` in this scope
   --> compiler/src/plugin/mod.rs:151:19
    |
151 |     pub location: Span,
    |                   ^^^^ not found in this scope
    |
help: consider importing this struct through its public re-export
    |
  9 + use crate::prelude::Span;
    |

error[E0659]: `Function` is ambiguous
  --> compiler/src/gpu/mod.rs:78:42
   |
78 |     pub fn generate_kernel(&self, func: &Function) -> Result<String> {
   |                                          ^^^^^^^^ ambiguous name
   |
   = note: ambiguous because of multiple glob imports of a name in the same module
note: `Function` could refer to the struct imported here
  --> compiler/src/gpu/mod.rs:9:5
   |
 9 | use crate::parser::ast::*;
   |     ^^^^^^^^^^^^^^^^^^^^^
   = help: consider adding an explicit import of `Function` to disambiguate
note: `Function` could also refer to the struct imported here
  --> compiler/src/gpu/mod.rs:10:5
   |
10 | use crate::ir::ssa::*;
   |     ^^^^^^^^^^^^^^^^^
   = help: consider adding an explicit import of `Function` to disambiguate

error[E0659]: `Function` is ambiguous
  --> compiler/src/gpu/mod.rs:87:43
   |
87 |     fn generate_cuda_kernel(&self, func: &Function) -> Result<String> {
   |                                           ^^^^^^^^ ambiguous name
   |
   = note: ambiguous because of multiple glob imports of a name in the same module
note: `Function` could refer to the struct imported here
  --> compiler/src/gpu/mod.rs:9:5
   |
 9 | use crate::parser::ast::*;
   |     ^^^^^^^^^^^^^^^^^^^^^
   = help: consider adding an explicit import of `Function` to disambiguate
note: `Function` could also refer to the struct imported here
  --> compiler/src/gpu/mod.rs:10:5
   |
10 | use crate::ir::ssa::*;
   |     ^^^^^^^^^^^^^^^^^
   = help: consider adding an explicit import of `Function` to disambiguate

error[E0659]: `Function` is ambiguous
   --> compiler/src/gpu/mod.rs:120:44
    |
120 |     fn generate_metal_kernel(&self, func: &Function) -> Result<String> {
    |                                            ^^^^^^^^ ambiguous name
    |
    = note: ambiguous because of multiple glob imports of a name in the same module
note: `Function` could refer to the struct imported here
   --> compiler/src/gpu/mod.rs:9:5
    |
  9 | use crate::parser::ast::*;
    |     ^^^^^^^^^^^^^^^^^^^^^
    = help: consider adding an explicit import of `Function` to disambiguate
note: `Function` could also refer to the struct imported here
   --> compiler/src/gpu/mod.rs:10:5
    |
 10 | use crate::ir::ssa::*;
    |     ^^^^^^^^^^^^^^^^^
    = help: consider adding an explicit import of `Function` to disambiguate

error[E0659]: `Function` is ambiguous
   --> compiler/src/gpu/mod.rs:157:45
    |
157 |     fn generate_vulkan_kernel(&self, func: &Function) -> Result<String> {
    |                                             ^^^^^^^^ ambiguous name
    |
    = note: ambiguous because of multiple glob imports of a name in the same module
note: `Function` could refer to the struct imported here
   --> compiler/src/gpu/mod.rs:9:5
    |
  9 | use crate::parser::ast::*;
    |     ^^^^^^^^^^^^^^^^^^^^^
    = help: consider adding an explicit import of `Function` to disambiguate
note: `Function` could also refer to the struct imported here
   --> compiler/src/gpu/mod.rs:10:5
    |
 10 | use crate::ir::ssa::*;
    |     ^^^^^^^^^^^^^^^^^
    = help: consider adding an explicit import of `Function` to disambiguate

error[E0659]: `Function` is ambiguous
   --> compiler/src/gpu/mod.rs:193:45
    |
193 |     fn generate_opencl_kernel(&self, func: &Function) -> Result<String> {
    |                                             ^^^^^^^^ ambiguous name
    |
    = note: ambiguous because of multiple glob imports of a name in the same module
note: `Function` could refer to the struct imported here
   --> compiler/src/gpu/mod.rs:9:5
    |
  9 | use crate::parser::ast::*;
    |     ^^^^^^^^^^^^^^^^^^^^^
    = help: consider adding an explicit import of `Function` to disambiguate
note: `Function` could also refer to the struct imported here
   --> compiler/src/gpu/mod.rs:10:5
    |
 10 | use crate::ir::ssa::*;
    |     ^^^^^^^^^^^^^^^^^
    = help: consider adding an explicit import of `Function` to disambiguate

error[E0659]: `Function` is ambiguous
   --> compiler/src/gpu/mod.rs:227:43
    |
227 |     fn generate_kernel_body(&self, func: &Function) -> Result<String> {
    |                                           ^^^^^^^^ ambiguous name
    |
    = note: ambiguous because of multiple glob imports of a name in the same module
note: `Function` could refer to the struct imported here
   --> compiler/src/gpu/mod.rs:9:5
    |
  9 | use crate::parser::ast::*;
    |     ^^^^^^^^^^^^^^^^^^^^^
    = help: consider adding an explicit import of `Function` to disambiguate
note: `Function` could also refer to the struct imported here
   --> compiler/src/gpu/mod.rs:10:5
    |
 10 | use crate::ir::ssa::*;
    |     ^^^^^^^^^^^^^^^^^
    = help: consider adding an explicit import of `Function` to disambiguate

warning: unused import: `TypeVar`
 --> compiler/src/semantic/type_checker.rs:6:69
  |
6 | use super::type_env::{TypeEnv, InferredType, Substitution, Unifier, TypeVar};
  |                                                                     ^^^^^^^
  |
  = note: `#[warn(unused_imports)]` (part of `#[warn(unused)]`) on by default

warning: unused import: `BasicBlock`
 --> compiler/src/ir/builder.rs:5:42
  |
5 | use super::ssa::{Function as IrFunction, BasicBlock, Value, ValueId, Constant, Module};
  |                                          ^^^^^^^^^^

warning: unused import: `crate::ir::types::IrType`
 --> compiler/src/optimizer/constant_folding.rs:5:5
  |
5 | use crate::ir::types::IrType;
  |     ^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `ValueId`
 --> compiler/src/optimizer/inline.rs:3:54
  |
3 | use crate::ir::ssa::{Module, Function as IrFunction, ValueId};
  |                                                      ^^^^^^^

warning: unused import: `Path`
 --> compiler/src/codegen/linker.rs:5:17
  |
5 | use std::path::{Path, PathBuf};
  |                 ^^^^

warning: unused import: `crate::parser::ast::*`
 --> compiler/src/macro_system/mod.rs:9:5
  |
9 | use crate::parser::ast::*;
  |     ^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `std::prelude::*`
 --> compiler/src/async_runtime/mod.rs:9:5
  |
9 | use std::prelude::*;
  |     ^^^^^^^^^^^^^^^

warning: unused import: `Error`
  --> compiler/src/verification/mod.rs:11:20
   |
11 | use crate::error::{Error, Result};
   |                    ^^^^^

warning: unused import: `std::collections::HashMap`
  --> compiler/src/verification/mod.rs:12:5
   |
12 | use std::collections::HashMap;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `crate::ir::ssa::*`
  --> compiler/src/gpu/mod.rs:10:5
   |
10 | use crate::ir::ssa::*;
   |     ^^^^^^^^^^^^^^^^^

warning: unused import: `Error`
  --> compiler/src/gpu/mod.rs:11:20
   |
11 | use crate::error::{Error, Result};
   |                    ^^^^^

error[E0277]: `F1` is not a future
   --> compiler/src/async_runtime/mod.rs:113:17
    |
113 |     let r1 = f1.await;
    |                 ^^^^^ `F1` is not a future
    |
    = note: F1 must be a future or must implement `IntoFuture` to be awaited
    = note: required for `F1` to implement `IntoFuture`
help: remove the `.await`
    |
113 -     let r1 = f1.await;
113 +     let r1 = f1;
    |
help: consider further restricting type parameter `F1` with trait `Future`
    |
110 |     F1: Future + std::future::Future,
    |                +++++++++++++++++++++

error[E0277]: `F2` is not a future
   --> compiler/src/async_runtime/mod.rs:114:17
    |
114 |     let r2 = f2.await;
    |                 ^^^^^ `F2` is not a future
    |
    = note: F2 must be a future or must implement `IntoFuture` to be awaited
    = note: required for `F2` to implement `IntoFuture`
help: remove the `.await`
    |
114 -     let r2 = f2.await;
114 +     let r2 = f2;
    |
help: consider further restricting type parameter `F2` with trait `Future`
    |
111 |     F2: Future + std::future::Future,
    |                +++++++++++++++++++++

error[E0023]: this pattern has 1 field, but the corresponding tuple variant has 2 fields
  --> compiler/src/lexer/token.rs:66:35
   |
26 |     IntLiteral(String, Option<String>),   // value, optional suffix (i32, u64, etc.)
   |                ------  -------------- tuple variant has 2 fields
...
66 |             TokenKind::IntLiteral(_) | TokenKind::FloatLiteral(_) |
   |                                   ^ expected 2 fields, found 1
   |
help: use `_` to explicitly ignore each field
   |
66 |             TokenKind::IntLiteral(_, _) | TokenKind::FloatLiteral(_) |
   |                                    +++
help: use `..` to ignore all fields
   |
66 -             TokenKind::IntLiteral(_) | TokenKind::FloatLiteral(_) |
66 +             TokenKind::IntLiteral(..) | TokenKind::FloatLiteral(_) |
   |

error[E0023]: this pattern has 1 field, but the corresponding tuple variant has 2 fields
  --> compiler/src/lexer/token.rs:66:64
   |
27 |     FloatLiteral(String, Option<String>), // value, optional suffix (f32, f64)
   |                  ------  -------------- tuple variant has 2 fields
...
66 |             TokenKind::IntLiteral(_) | TokenKind::FloatLiteral(_) |
   |                                                                ^ expected 2 fields, found 1
   |
help: use `_` to explicitly ignore each field
   |
66 |             TokenKind::IntLiteral(_) | TokenKind::FloatLiteral(_, _) |
   |                                                                 +++
help: use `..` to ignore all fields
   |
66 -             TokenKind::IntLiteral(_) | TokenKind::FloatLiteral(_) |
66 +             TokenKind::IntLiteral(_) | TokenKind::FloatLiteral(..) |
   |

error[E0308]: mismatched types
   --> compiler/src/lexer/mod.rs:689:13
    |
682 |     fn lex_slash(&mut self) -> Result<TokenKind> {
    |                                ----------------- expected `std::result::Result<TokenKind, error::Error>` because of return type
...
689 |             self.next_token() // Skip comment and get next token
    |             ^^^^^^^^^^^^^^^^^ expected `Result<TokenKind, Error>`, found `Result<Token, Error>`
    |
    = note: expected enum `std::result::Result<TokenKind, _>`
               found enum `std::result::Result<Token, _>`

error[E0308]: mismatched types
   --> compiler/src/lexer/mod.rs:698:32
    |
682 |     fn lex_slash(&mut self) -> Result<TokenKind> {
    |                                ----------------- expected `std::result::Result<TokenKind, error::Error>` because of return type
...
698 |                         return self.next_token(); // Skip comment
    |                                ^^^^^^^^^^^^^^^^^ expected `Result<TokenKind, Error>`, found `Result<Token, Error>`
    |
    = note: expected enum `std::result::Result<TokenKind, _>`
               found enum `std::result::Result<Token, _>`

error[E0599]: no function or associated item named `default` found for struct `span::Span` in the current scope
  --> compiler/src/semantic/resolver.rs:66:19
   |
66 |             Span::default(),
   |                   ^^^^^^^ function or associated item not found in `span::Span`
   |
  ::: compiler/src/span.rs:31:1
   |
31 | pub struct Span {
   | --------------- function or associated item `default` not found for this struct
   |
note: if you're trying to build a new `span::Span`, consider using `span::Span::new` which returns `span::Span`
  --> compiler/src/span.rs:37:5
   |
37 |     pub fn new(start: Position, end: Position) -> Self {
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   = help: items from traits can only be used if the trait is implemented and in scope
   = note: the following trait defines an item `default`, perhaps you need to implement it:
           candidate #1: `Default`

error[E0599]: no variant or associated item named `DuplicateSymbol` found for enum `error::ErrorKind` in the current scope
  --> compiler/src/semantic/resolver.rs:71:50
   |
71 |             self.add_error(Error::new(ErrorKind::DuplicateSymbol, e));
   |                                                  ^^^^^^^^^^^^^^^ variant or associated item not found in `error::ErrorKind`
   |
  ::: compiler/src/error.rs:18:1
   |
18 | pub enum ErrorKind {
   | ------------------ variant or associated item `DuplicateSymbol` not found for this enum

error[E0599]: no function or associated item named `default` found for struct `span::Span` in the current scope
  --> compiler/src/semantic/resolver.rs:84:23
   |
84 |                 Span::default(),
   |                       ^^^^^^^ function or associated item not found in `span::Span`
   |
  ::: compiler/src/span.rs:31:1
   |
31 | pub struct Span {
   | --------------- function or associated item `default` not found for this struct
   |
note: if you're trying to build a new `span::Span`, consider using `span::Span::new` which returns `span::Span`
  --> compiler/src/span.rs:37:5
   |
37 |     pub fn new(start: Position, end: Position) -> Self {
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   = help: items from traits can only be used if the trait is implemented and in scope
   = note: the following trait defines an item `default`, perhaps you need to implement it:
           candidate #1: `Default`

error[E0599]: no variant or associated item named `DuplicateSymbol` found for enum `error::ErrorKind` in the current scope
  --> compiler/src/semantic/resolver.rs:89:54
   |
89 |                 self.add_error(Error::new(ErrorKind::DuplicateSymbol, e));
   |                                                      ^^^^^^^^^^^^^^^ variant or associated item not found in `error::ErrorKind`
   |
  ::: compiler/src/error.rs:18:1
   |
18 | pub enum ErrorKind {
   | ------------------ variant or associated item `DuplicateSymbol` not found for this enum

error[E0599]: no function or associated item named `default` found for struct `span::Span` in the current scope
  --> compiler/src/semantic/resolver.rs:99:23
   |
99 |                 Span::default(),
   |                       ^^^^^^^ function or associated item not found in `span::Span`
   |
  ::: compiler/src/span.rs:31:1
   |
31 | pub struct Span {
   | --------------- function or associated item `default` not found for this struct
   |
note: if you're trying to build a new `span::Span`, consider using `span::Span::new` which returns `span::Span`
  --> compiler/src/span.rs:37:5
   |
37 |     pub fn new(start: Position, end: Position) -> Self {
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   = help: items from traits can only be used if the trait is implemented and in scope
   = note: the following trait defines an item `default`, perhaps you need to implement it:
           candidate #1: `Default`

error[E0599]: no variant or associated item named `DuplicateSymbol` found for enum `error::ErrorKind` in the current scope
   --> compiler/src/semantic/resolver.rs:104:54
    |
104 |                 self.add_error(Error::new(ErrorKind::DuplicateSymbol, e));
    |                                                      ^^^^^^^^^^^^^^^ variant or associated item not found in `error::ErrorKind`
    |
   ::: compiler/src/error.rs:18:1
    |
 18 | pub enum ErrorKind {
    | ------------------ variant or associated item `DuplicateSymbol` not found for this enum

error[E0599]: no function or associated item named `default` found for struct `span::Span` in the current scope
   --> compiler/src/semantic/resolver.rs:122:19
    |
122 |             Span::default(),
    |                   ^^^^^^^ function or associated item not found in `span::Span`
    |
   ::: compiler/src/span.rs:31:1
    |
 31 | pub struct Span {
    | --------------- function or associated item `default` not found for this struct
    |
note: if you're trying to build a new `span::Span`, consider using `span::Span::new` which returns `span::Span`
   --> compiler/src/span.rs:37:5
    |
 37 |     pub fn new(start: Position, end: Position) -> Self {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    = help: items from traits can only be used if the trait is implemented and in scope
    = note: the following trait defines an item `default`, perhaps you need to implement it:
            candidate #1: `Default`

error[E0599]: no variant or associated item named `DuplicateSymbol` found for enum `error::ErrorKind` in the current scope
   --> compiler/src/semantic/resolver.rs:127:50
    |
127 |             self.add_error(Error::new(ErrorKind::DuplicateSymbol, e));
    |                                                  ^^^^^^^^^^^^^^^ variant or associated item not found in `error::ErrorKind`
    |
   ::: compiler/src/error.rs:18:1
    |
 18 | pub enum ErrorKind {
    | ------------------ variant or associated item `DuplicateSymbol` not found for this enum

error[E0599]: no function or associated item named `default` found for struct `span::Span` in the current scope
   --> compiler/src/semantic/resolver.rs:136:19
    |
136 |             Span::default(),
    |                   ^^^^^^^ function or associated item not found in `span::Span`
    |
   ::: compiler/src/span.rs:31:1
    |
 31 | pub struct Span {
    | --------------- function or associated item `default` not found for this struct
    |
note: if you're trying to build a new `span::Span`, consider using `span::Span::new` which returns `span::Span`
   --> compiler/src/span.rs:37:5
    |
 37 |     pub fn new(start: Position, end: Position) -> Self {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    = help: items from traits can only be used if the trait is implemented and in scope
    = note: the following trait defines an item `default`, perhaps you need to implement it:
            candidate #1: `Default`

error[E0599]: no variant or associated item named `DuplicateSymbol` found for enum `error::ErrorKind` in the current scope
   --> compiler/src/semantic/resolver.rs:141:50
    |
141 |             self.add_error(Error::new(ErrorKind::DuplicateSymbol, e));
    |                                                  ^^^^^^^^^^^^^^^ variant or associated item not found in `error::ErrorKind`
    |
   ::: compiler/src/error.rs:18:1
    |
 18 | pub enum ErrorKind {
    | ------------------ variant or associated item `DuplicateSymbol` not found for this enum

error[E0599]: no function or associated item named `default` found for struct `span::Span` in the current scope
   --> compiler/src/semantic/resolver.rs:151:23
    |
151 |                 Span::default(),
    |                       ^^^^^^^ function or associated item not found in `span::Span`
    |
   ::: compiler/src/span.rs:31:1
    |
 31 | pub struct Span {
    | --------------- function or associated item `default` not found for this struct
    |
note: if you're trying to build a new `span::Span`, consider using `span::Span::new` which returns `span::Span`
   --> compiler/src/span.rs:37:5
    |
 37 |     pub fn new(start: Position, end: Position) -> Self {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    = help: items from traits can only be used if the trait is implemented and in scope
    = note: the following trait defines an item `default`, perhaps you need to implement it:
            candidate #1: `Default`

error[E0599]: no variant or associated item named `DuplicateSymbol` found for enum `error::ErrorKind` in the current scope
   --> compiler/src/semantic/resolver.rs:156:54
    |
156 |                 self.add_error(Error::new(ErrorKind::DuplicateSymbol, e));
    |                                                      ^^^^^^^^^^^^^^^ variant or associated item not found in `error::ErrorKind`
    |
   ::: compiler/src/error.rs:18:1
    |
 18 | pub enum ErrorKind {
    | ------------------ variant or associated item `DuplicateSymbol` not found for this enum

error[E0599]: no function or associated item named `default` found for struct `span::Span` in the current scope
   --> compiler/src/semantic/resolver.rs:166:19
    |
166 |             Span::default(),
    |                   ^^^^^^^ function or associated item not found in `span::Span`
    |
   ::: compiler/src/span.rs:31:1
    |
 31 | pub struct Span {
    | --------------- function or associated item `default` not found for this struct
    |
note: if you're trying to build a new `span::Span`, consider using `span::Span::new` which returns `span::Span`
   --> compiler/src/span.rs:37:5
    |
 37 |     pub fn new(start: Position, end: Position) -> Self {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    = help: items from traits can only be used if the trait is implemented and in scope
    = note: the following trait defines an item `default`, perhaps you need to implement it:
            candidate #1: `Default`

error[E0599]: no variant or associated item named `DuplicateSymbol` found for enum `error::ErrorKind` in the current scope
   --> compiler/src/semantic/resolver.rs:171:50
    |
171 |             self.add_error(Error::new(ErrorKind::DuplicateSymbol, e));
    |                                                  ^^^^^^^^^^^^^^^ variant or associated item not found in `error::ErrorKind`
    |
   ::: compiler/src/error.rs:18:1
    |
 18 | pub enum ErrorKind {
    | ------------------ variant or associated item `DuplicateSymbol` not found for this enum

error[E0599]: no function or associated item named `default` found for struct `span::Span` in the current scope
   --> compiler/src/semantic/resolver.rs:185:23
    |
185 |                 Span::default(),
    |                       ^^^^^^^ function or associated item not found in `span::Span`
    |
   ::: compiler/src/span.rs:31:1
    |
 31 | pub struct Span {
    | --------------- function or associated item `default` not found for this struct
    |
note: if you're trying to build a new `span::Span`, consider using `span::Span::new` which returns `span::Span`
   --> compiler/src/span.rs:37:5
    |
 37 |     pub fn new(start: Position, end: Position) -> Self {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    = help: items from traits can only be used if the trait is implemented and in scope
    = note: the following trait defines an item `default`, perhaps you need to implement it:
            candidate #1: `Default`

error[E0599]: no variant or associated item named `DuplicateSymbol` found for enum `error::ErrorKind` in the current scope
   --> compiler/src/semantic/resolver.rs:190:54
    |
190 |                 self.add_error(Error::new(ErrorKind::DuplicateSymbol, e));
    |                                                      ^^^^^^^^^^^^^^^ variant or associated item not found in `error::ErrorKind`
    |
   ::: compiler/src/error.rs:18:1
    |
 18 | pub enum ErrorKind {
    | ------------------ variant or associated item `DuplicateSymbol` not found for this enum

error[E0599]: no function or associated item named `default` found for struct `span::Span` in the current scope
   --> compiler/src/semantic/resolver.rs:217:19
    |
217 |             Span::default(),
    |                   ^^^^^^^ function or associated item not found in `span::Span`
    |
   ::: compiler/src/span.rs:31:1
    |
 31 | pub struct Span {
    | --------------- function or associated item `default` not found for this struct
    |
note: if you're trying to build a new `span::Span`, consider using `span::Span::new` which returns `span::Span`
   --> compiler/src/span.rs:37:5
    |
 37 |     pub fn new(start: Position, end: Position) -> Self {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    = help: items from traits can only be used if the trait is implemented and in scope
    = note: the following trait defines an item `default`, perhaps you need to implement it:
            candidate #1: `Default`

error[E0599]: no variant or associated item named `DuplicateSymbol` found for enum `error::ErrorKind` in the current scope
   --> compiler/src/semantic/resolver.rs:222:50
    |
222 |             self.add_error(Error::new(ErrorKind::DuplicateSymbol, e));
    |                                                  ^^^^^^^^^^^^^^^ variant or associated item not found in `error::ErrorKind`
    |
   ::: compiler/src/error.rs:18:1
    |
 18 | pub enum ErrorKind {
    | ------------------ variant or associated item `DuplicateSymbol` not found for this enum

error[E0599]: no function or associated item named `default` found for struct `span::Span` in the current scope
   --> compiler/src/semantic/resolver.rs:250:27
    |
250 |                     Span::default(),
    |                           ^^^^^^^ function or associated item not found in `span::Span`
    |
   ::: compiler/src/span.rs:31:1
    |
 31 | pub struct Span {
    | --------------- function or associated item `default` not found for this struct
    |
note: if you're trying to build a new `span::Span`, consider using `span::Span::new` which returns `span::Span`
   --> compiler/src/span.rs:37:5
    |
 37 |     pub fn new(start: Position, end: Position) -> Self {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    = help: items from traits can only be used if the trait is implemented and in scope
    = note: the following trait defines an item `default`, perhaps you need to implement it:
            candidate #1: `Default`

error[E0599]: no variant or associated item named `DuplicateSymbol` found for enum `error::ErrorKind` in the current scope
   --> compiler/src/semantic/resolver.rs:259:58
    |
259 |                     self.add_error(Error::new(ErrorKind::DuplicateSymbol, e));
    |                                                          ^^^^^^^^^^^^^^^ variant or associated item not found in `error::ErrorKind`
    |
   ::: compiler/src/error.rs:18:1
    |
 18 | pub enum ErrorKind {
    | ------------------ variant or associated item `DuplicateSymbol` not found for this enum

error[E0599]: no function or associated item named `default` found for struct `span::Span` in the current scope
   --> compiler/src/semantic/resolver.rs:357:27
    |
357 |                     Span::default(),
    |                           ^^^^^^^ function or associated item not found in `span::Span`
    |
   ::: compiler/src/span.rs:31:1
    |
 31 | pub struct Span {
    | --------------- function or associated item `default` not found for this struct
    |
note: if you're trying to build a new `span::Span`, consider using `span::Span::new` which returns `span::Span`
   --> compiler/src/span.rs:37:5
    |
 37 |     pub fn new(start: Position, end: Position) -> Self {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    = help: items from traits can only be used if the trait is implemented and in scope
    = note: the following trait defines an item `default`, perhaps you need to implement it:
            candidate #1: `Default`

error[E0599]: no variant or associated item named `DuplicateSymbol` found for enum `error::ErrorKind` in the current scope
   --> compiler/src/semantic/resolver.rs:362:58
    |
362 |                     self.add_error(Error::new(ErrorKind::DuplicateSymbol, e));
    |                                                          ^^^^^^^^^^^^^^^ variant or associated item not found in `error::ErrorKind`
    |
   ::: compiler/src/error.rs:18:1
    |
 18 | pub enum ErrorKind {
    | ------------------ variant or associated item `DuplicateSymbol` not found for this enum

error[E0599]: no function or associated item named `default` found for struct `span::Span` in the current scope
   --> compiler/src/semantic/resolver.rs:407:27
    |
407 |                     Span::default(),
    |                           ^^^^^^^ function or associated item not found in `span::Span`
    |
   ::: compiler/src/span.rs:31:1
    |
 31 | pub struct Span {
    | --------------- function or associated item `default` not found for this struct
    |
note: if you're trying to build a new `span::Span`, consider using `span::Span::new` which returns `span::Span`
   --> compiler/src/span.rs:37:5
    |
 37 |     pub fn new(start: Position, end: Position) -> Self {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    = help: items from traits can only be used if the trait is implemented and in scope
    = note: the following trait defines an item `default`, perhaps you need to implement it:
            candidate #1: `Default`

error[E0599]: no variant or associated item named `DuplicateSymbol` found for enum `error::ErrorKind` in the current scope
   --> compiler/src/semantic/resolver.rs:412:58
    |
412 |                     self.add_error(Error::new(ErrorKind::DuplicateSymbol, e));
    |                                                          ^^^^^^^^^^^^^^^ variant or associated item not found in `error::ErrorKind`
    |
   ::: compiler/src/error.rs:18:1
    |
 18 | pub enum ErrorKind {
    | ------------------ variant or associated item `DuplicateSymbol` not found for this enum

error[E0599]: no variant or associated item named `TypeError` found for enum `error::ErrorKind` in the current scope
   --> compiler/src/semantic/type_env.rs:239:36
    |
239 |                         ErrorKind::TypeError,
    |                                    ^^^^^^^^^ variant or associated item not found in `error::ErrorKind`
    |
   ::: compiler/src/error.rs:18:1
    |
 18 | pub enum ErrorKind {
    | ------------------ variant or associated item `TypeError` not found for this enum
    |
help: there is a variant with a similar name
    |
239 -                         ErrorKind::TypeError,
240 -                         "Occurs check failed: infinite type"
241 -                     ))
239 +                         ErrorKind::MoveError)
    |

error[E0599]: no variant or associated item named `TypeError` found for enum `error::ErrorKind` in the current scope
   --> compiler/src/semantic/type_env.rs:253:36
    |
253 |                         ErrorKind::TypeError,
    |                                    ^^^^^^^^^ variant or associated item not found in `error::ErrorKind`
    |
   ::: compiler/src/error.rs:18:1
    |
 18 | pub enum ErrorKind {
    | ------------------ variant or associated item `TypeError` not found for this enum
    |
help: there is a variant with a similar name
    |
253 -                         ErrorKind::TypeError,
254 -                         format!("Function arity mismatch: {} vs {}", params1.len(), params2.len())
255 -                     ));
253 +                         ErrorKind::MoveError);
    |

error[E0599]: no variant or associated item named `TypeError` found for enum `error::ErrorKind` in the current scope
   --> compiler/src/semantic/type_env.rs:275:36
    |
275 |                         ErrorKind::TypeError,
    |                                    ^^^^^^^^^ variant or associated item not found in `error::ErrorKind`
    |
   ::: compiler/src/error.rs:18:1
    |
 18 | pub enum ErrorKind {
    | ------------------ variant or associated item `TypeError` not found for this enum
    |
help: there is a variant with a similar name
    |
275 -                         ErrorKind::TypeError,
276 -                         format!("Type mismatch: {} vs {}", name1, name2)
277 -                     ));
275 +                         ErrorKind::MoveError);
    |

error[E0599]: no variant or associated item named `TypeError` found for enum `error::ErrorKind` in the current scope
   --> compiler/src/semantic/type_env.rs:282:36
    |
282 |                         ErrorKind::TypeError,
    |                                    ^^^^^^^^^ variant or associated item not found in `error::ErrorKind`
    |
   ::: compiler/src/error.rs:18:1
    |
 18 | pub enum ErrorKind {
    | ------------------ variant or associated item `TypeError` not found for this enum
    |
help: there is a variant with a similar name
    |
282 -                         ErrorKind::TypeError,
283 -                         "Generic argument count mismatch"
284 -                     ));
282 +                         ErrorKind::MoveError);
    |

error[E0599]: no variant or associated item named `TypeError` found for enum `error::ErrorKind` in the current scope
   --> compiler/src/semantic/type_env.rs:300:36
    |
300 |                         ErrorKind::TypeError,
    |                                    ^^^^^^^^^ variant or associated item not found in `error::ErrorKind`
    |
   ::: compiler/src/error.rs:18:1
    |
 18 | pub enum ErrorKind {
    | ------------------ variant or associated item `TypeError` not found for this enum
    |
help: there is a variant with a similar name
    |
300 -                         ErrorKind::TypeError,
301 -                         "Tuple size mismatch"
302 -                     ));
300 +                         ErrorKind::MoveError);
    |

error[E0599]: no variant or associated item named `TypeError` found for enum `error::ErrorKind` in the current scope
   --> compiler/src/semantic/type_env.rs:318:36
    |
318 |                         ErrorKind::TypeError,
    |                                    ^^^^^^^^^ variant or associated item not found in `error::ErrorKind`
    |
   ::: compiler/src/error.rs:18:1
    |
 18 | pub enum ErrorKind {
    | ------------------ variant or associated item `TypeError` not found for this enum
    |
help: there is a variant with a similar name
    |
318 -                         ErrorKind::TypeError,
319 -                         "Array size mismatch"
320 -                     ));
318 +                         ErrorKind::MoveError);
    |

error[E0599]: no variant or associated item named `TypeError` found for enum `error::ErrorKind` in the current scope
   --> compiler/src/semantic/type_env.rs:341:36
    |
341 |                         ErrorKind::TypeError,
    |                                    ^^^^^^^^^ variant or associated item not found in `error::ErrorKind`
    |
   ::: compiler/src/error.rs:18:1
    |
 18 | pub enum ErrorKind {
    | ------------------ variant or associated item `TypeError` not found for this enum
    |
help: there is a variant with a similar name
    |
341 -                         ErrorKind::TypeError,
342 -                         format!("Type mismatch: {} vs {}", n1, n2)
343 -                     ))
341 +                         ErrorKind::MoveError)
    |

error[E0599]: no variant or associated item named `TypeError` found for enum `error::ErrorKind` in the current scope
   --> compiler/src/semantic/type_env.rs:349:28
    |
349 |                 ErrorKind::TypeError,
    |                            ^^^^^^^^^ variant or associated item not found in `error::ErrorKind`
    |
   ::: compiler/src/error.rs:18:1
    |
 18 | pub enum ErrorKind {
    | ------------------ variant or associated item `TypeError` not found for this enum
    |
help: there is a variant with a similar name
    |
349 -                 ErrorKind::TypeError,
350 -                 format!("Cannot unify types: {:?} and {:?}", t1, t2)
351 -             ))
349 +                 ErrorKind::MoveError)
    |

error[E0599]: no variant or associated item named `TypeError` found for enum `error::ErrorKind` in the current scope
   --> compiler/src/semantic/type_checker.rs:144:36
    |
144 |                         ErrorKind::TypeError,
    |                                    ^^^^^^^^^ variant or associated item not found in `error::ErrorKind`
    |
   ::: compiler/src/error.rs:18:1
    |
 18 | pub enum ErrorKind {
    | ------------------ variant or associated item `TypeError` not found for this enum
    |
help: there is a variant with a similar name
    |
144 -                         ErrorKind::TypeError,
145 -                         "Let binding must have type annotation or initializer"
146 -                     ));
144 +                         ErrorKind::MoveError);
    |

warning: unreachable expression
  --> compiler/src/codegen/llvm_backend.rs:46:9
   |
33 |         return "x86_64-unknown-linux-gnu".to_string();
   |         --------------------------------------------- any code following this expression is unreachable
...
46 |         "unknown-unknown-unknown".to_string()
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ unreachable expression
   |
   = note: `#[warn(unreachable_code)]` (part of `#[warn(unused)]`) on by default

error[E0599]: no variant or associated item named `I1` found for enum `IrType` in the current scope
  --> compiler/src/codegen/llvm_backend.rs:60:21
   |
60 |             IrType::I1 => "i1".to_string(),
   |                     ^^ variant or associated item not found in `IrType`
   |
  ::: compiler/src/ir/types.rs:7:1
   |
 7 | pub enum IrType {
   | --------------- variant or associated item `I1` not found for this enum
   |
help: there is a variant with a similar name
   |
60 -             IrType::I1 => "i1".to_string(),
60 +             IrType::I8 => "i1".to_string(),
   |

error[E0599]: no variant or associated item named `Ptr` found for enum `IrType` in the current scope
  --> compiler/src/codegen/llvm_backend.rs:73:21
   |
73 |             IrType::Ptr(inner) => format!("{}*", self.type_to_llvm(inner)),
   |                     ^^^ variant or associated item not found in `IrType`
   |
  ::: compiler/src/ir/types.rs:7:1
   |
 7 | pub enum IrType {
   | --------------- variant or associated item `Ptr` not found for this enum

error[E0026]: variant `Instruction::Branch` does not have fields named `true_bb`, `false_bb`
   --> compiler/src/codegen/llvm_backend.rs:290:41
    |
290 |             Instruction::Branch { cond, true_bb, false_bb } => {
    |                                         ^^^^^^^  ^^^^^^^^ variant `Instruction::Branch` does not have these fields

error[E0027]: pattern does not mention fields `then_block`, `else_block`
   --> compiler/src/codegen/llvm_backend.rs:290:13
    |
290 |             Instruction::Branch { cond, true_bb, false_bb } => {
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ missing fields `then_block`, `else_block`
    |
help: include the missing fields in the pattern
    |
290 |             Instruction::Branch { cond, true_bb, false_bb, then_block, else_block } => {
    |                                                          ++++++++++++++++++++++++
help: if you don't care about these missing fields, you can explicitly ignore them
    |
290 |             Instruction::Branch { cond, true_bb, false_bb, then_block: _, else_block: _ } => {
    |                                                          ++++++++++++++++++++++++++++++
help: or always ignore missing fields here
    |
290 |             Instruction::Branch { cond, true_bb, false_bb, .. } => {
    |                                                          ++++

error[E0609]: no field `0` on type `&usize`
   --> compiler/src/codegen/llvm_backend.rs:295:53
    |
295 |                 Ok(format!("br label %bb{}", target.0))
    |                                                     ^ unknown field

error[E0609]: no field `0` on type `&usize`
   --> compiler/src/codegen/llvm_backend.rs:305:63
    |
305 |                         format!("[ {}, %bb{} ]", val_name, bb.0)
    |                                                               ^ unknown field

error[E0599]: no variant or associated item named `I1` found for enum `IrType` in the current scope
   --> compiler/src/codegen/llvm_backend.rs:337:59
    |
337 |             Value::Constant(Constant::Bool(_)) => IrType::I1,
    |                                                           ^^ variant or associated item not found in `IrType`
    |
   ::: compiler/src/ir/types.rs:7:1
    |
  7 | pub enum IrType {
    | --------------- variant or associated item `I1` not found for this enum
    |
help: there is a variant with a similar name
    |
337 -             Value::Constant(Constant::Bool(_)) => IrType::I1,
337 +             Value::Constant(Constant::Bool(_)) => IrType::I8,
    |

error[E0599]: no variant named `MacroCall` found for enum `ast::Expr`
  --> compiler/src/macro_system/expander.rs:25:19
   |
25 |             Expr::MacroCall { name, args, span } => {
   |                   ^^^^^^^^^ variant not found in `ast::Expr`
   |
  ::: compiler/src/parser/ast.rs:94:1
   |
94 | pub enum Expr {
   | ------------- variant `MacroCall` not found here

error[E0769]: tuple variant `Expr::Binary` written as struct variant
  --> compiler/src/macro_system/expander.rs:28:13
   |
28 |             Expr::Binary { op, left, right, span } => {
   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
help: use the tuple variant pattern syntax instead
   |
28 -             Expr::Binary { op, left, right, span } => {
28 +             Expr::Binary(_, _, _) => {
   |

error[E0769]: tuple variant `Expr::Call` written as struct variant
  --> compiler/src/macro_system/expander.rs:38:13
   |
38 |             Expr::Call { func, args, span } => {
   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
help: use the tuple variant pattern syntax instead
   |
38 -             Expr::Call { func, args, span } => {
38 +             Expr::Call(_, _) => {
   |

error[E0769]: tuple variant `Expr::Block` written as struct variant
  --> compiler/src/macro_system/expander.rs:49:13
   |
49 |             Expr::Block { stmts, span } => {
   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
help: use the tuple variant pattern syntax instead
   |
49 -             Expr::Block { stmts, span } => {
49 +             Expr::Block(_) => {
   |

error[E0559]: variant `ast::Expr::Binary` has no field named `op`
  --> compiler/src/macro_system/expander.rs:32:21
   |
32 |                     op: *op,
   |                     ^^ field does not exist
   |
  ::: compiler/src/parser/ast.rs:97:5
   |
97 |     Binary(Box<Expr>, BinOp, Box<Expr>),
   |     ------ `ast::Expr::Binary` defined here
   |
help: `ast::Expr::Binary` is a tuple variant, use the appropriate syntax
   |
31 -                 Ok(Expr::Binary {
32 -                     op: *op,
33 -                     left,
34 -                     right,
35 -                     span: *span,
36 -                 })
31 +                 Ok(Expr::Binary(/* Box<ast::Expr> */, /* ast::BinOp */, /* Box<ast::Expr> */))
   |

error[E0559]: variant `ast::Expr::Binary` has no field named `left`
  --> compiler/src/macro_system/expander.rs:33:21
   |
33 |                     left,
   |                     ^^^^ field does not exist
   |
  ::: compiler/src/parser/ast.rs:97:5
   |
97 |     Binary(Box<Expr>, BinOp, Box<Expr>),
   |     ------ `ast::Expr::Binary` defined here
   |
help: `ast::Expr::Binary` is a tuple variant, use the appropriate syntax
   |
31 -                 Ok(Expr::Binary {
32 -                     op: *op,
33 -                     left,
34 -                     right,
35 -                     span: *span,
36 -                 })
31 +                 Ok(Expr::Binary(/* Box<ast::Expr> */, /* ast::BinOp */, /* Box<ast::Expr> */))
   |

error[E0559]: variant `ast::Expr::Binary` has no field named `right`
  --> compiler/src/macro_system/expander.rs:34:21
   |
34 |                     right,
   |                     ^^^^^ field does not exist
   |
  ::: compiler/src/parser/ast.rs:97:5
   |
97 |     Binary(Box<Expr>, BinOp, Box<Expr>),
   |     ------ `ast::Expr::Binary` defined here
   |
help: `ast::Expr::Binary` is a tuple variant, use the appropriate syntax
   |
31 -                 Ok(Expr::Binary {
32 -                     op: *op,
33 -                     left,
34 -                     right,
35 -                     span: *span,
36 -                 })
31 +                 Ok(Expr::Binary(/* Box<ast::Expr> */, /* ast::BinOp */, /* Box<ast::Expr> */))
   |

error[E0559]: variant `ast::Expr::Binary` has no field named `span`
  --> compiler/src/macro_system/expander.rs:35:21
   |
35 |                     span: *span,
   |                     ^^^^ field does not exist
   |
  ::: compiler/src/parser/ast.rs:97:5
   |
97 |     Binary(Box<Expr>, BinOp, Box<Expr>),
   |     ------ `ast::Expr::Binary` defined here
   |
help: `ast::Expr::Binary` is a tuple variant, use the appropriate syntax
   |
31 -                 Ok(Expr::Binary {
32 -                     op: *op,
33 -                     left,
34 -                     right,
35 -                     span: *span,
36 -                 })
31 +                 Ok(Expr::Binary(/* Box<ast::Expr> */, /* ast::BinOp */, /* Box<ast::Expr> */))
   |

error[E0559]: variant `ast::Expr::Call` has no field named `func`
  --> compiler/src/macro_system/expander.rs:44:21
   |
44 |                     func,
   |                     ^^^^ field does not exist
   |
  ::: compiler/src/parser/ast.rs:99:5
   |
99 |     Call(Box<Expr>, Vec<Expr>),
   |     ---- `ast::Expr::Call` defined here
   |
help: `ast::Expr::Call` is a tuple variant, use the appropriate syntax
   |
43 -                 Ok(Expr::Call {
44 -                     func,
45 -                     args,
46 -                     span: *span,
47 -                 })
43 +                 Ok(Expr::Call(/* Box<ast::Expr> */, /* Vec<ast::Expr> */))
   |

error[E0559]: variant `ast::Expr::Call` has no field named `args`
  --> compiler/src/macro_system/expander.rs:45:21
   |
45 |                     args,
   |                     ^^^^ field does not exist
   |
  ::: compiler/src/parser/ast.rs:99:5
   |
99 |     Call(Box<Expr>, Vec<Expr>),
   |     ---- `ast::Expr::Call` defined here
   |
help: `ast::Expr::Call` is a tuple variant, use the appropriate syntax
   |
43 -                 Ok(Expr::Call {
44 -                     func,
45 -                     args,
46 -                     span: *span,
47 -                 })
43 +                 Ok(Expr::Call(/* Box<ast::Expr> */, /* Vec<ast::Expr> */))
   |

error[E0559]: variant `ast::Expr::Call` has no field named `span`
  --> compiler/src/macro_system/expander.rs:46:21
   |
46 |                     span: *span,
   |                     ^^^^ field does not exist
   |
  ::: compiler/src/parser/ast.rs:99:5
   |
99 |     Call(Box<Expr>, Vec<Expr>),
   |     ---- `ast::Expr::Call` defined here
   |
help: `ast::Expr::Call` is a tuple variant, use the appropriate syntax
   |
43 -                 Ok(Expr::Call {
44 -                     func,
45 -                     args,
46 -                     span: *span,
47 -                 })
43 +                 Ok(Expr::Call(/* Box<ast::Expr> */, /* Vec<ast::Expr> */))
   |

error[E0559]: variant `ast::Expr::Block` has no field named `stmts`
   --> compiler/src/macro_system/expander.rs:54:21
    |
 54 |                     stmts,
    |                     ^^^^^ field does not exist
    |
   ::: compiler/src/parser/ast.rs:103:5
    |
103 |     Block(Vec<Stmt>),
    |     ----- `ast::Expr::Block` defined here
    |
help: `ast::Expr::Block` is a tuple variant, use the appropriate syntax
    |
 53 -                 Ok(Expr::Block {
 54 -                     stmts,
 55 -                     span: *span,
 56 -                 })
 53 +                 Ok(Expr::Block(/* Vec<ast::Stmt> */))
    |

error[E0559]: variant `ast::Expr::Block` has no field named `span`
   --> compiler/src/macro_system/expander.rs:55:21
    |
 55 |                     span: *span,
    |                     ^^^^ field does not exist
    |
   ::: compiler/src/parser/ast.rs:103:5
    |
103 |     Block(Vec<Stmt>),
    |     ----- `ast::Expr::Block` defined here
    |
help: `ast::Expr::Block` is a tuple variant, use the appropriate syntax
    |
 53 -                 Ok(Expr::Block {
 54 -                     stmts,
 55 -                     span: *span,
 56 -                 })
 53 +                 Ok(Expr::Block(/* Vec<ast::Stmt> */))
    |

error[E0769]: tuple variant `Stmt::Let` written as struct variant
  --> compiler/src/macro_system/expander.rs:67:13
   |
67 |             Stmt::Let { pattern, ty, init, span } => {
   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
help: use the tuple variant pattern syntax instead
   |
67 -             Stmt::Let { pattern, ty, init, span } => {
67 +             Stmt::Let(_, _, _) => {
   |

error[E0559]: variant `ast::Stmt::Let` has no field named `pattern`
  --> compiler/src/macro_system/expander.rs:73:21
   |
73 |                     pattern: pattern.clone(),
   |                     ^^^^^^^ field does not exist
   |
  ::: compiler/src/parser/ast.rs:87:5
   |
87 |     Let(String, Option<Type>, Option<Expr>),
   |     --- `ast::Stmt::Let` defined here
   |
help: `ast::Stmt::Let` is a tuple variant, use the appropriate syntax
   |
72 -                 Ok(Stmt::Let {
73 -                     pattern: pattern.clone(),
74 -                     ty: ty.clone(),
75 -                     init,
76 -                     span: *span,
77 -                 })
72 +                 Ok(Stmt::Let(/* String */, /* Option<ast::Type> */, /* Option<ast::Expr> */))
   |

error[E0559]: variant `ast::Stmt::Let` has no field named `ty`
  --> compiler/src/macro_system/expander.rs:74:21
   |
74 |                     ty: ty.clone(),
   |                     ^^ field does not exist
   |
  ::: compiler/src/parser/ast.rs:87:5
   |
87 |     Let(String, Option<Type>, Option<Expr>),
   |     --- `ast::Stmt::Let` defined here
   |
help: `ast::Stmt::Let` is a tuple variant, use the appropriate syntax
   |
72 -                 Ok(Stmt::Let {
73 -                     pattern: pattern.clone(),
74 -                     ty: ty.clone(),
75 -                     init,
76 -                     span: *span,
77 -                 })
72 +                 Ok(Stmt::Let(/* String */, /* Option<ast::Type> */, /* Option<ast::Expr> */))
   |

error[E0559]: variant `ast::Stmt::Let` has no field named `init`
  --> compiler/src/macro_system/expander.rs:75:21
   |
75 |                     init,
   |                     ^^^^ field does not exist
   |
  ::: compiler/src/parser/ast.rs:87:5
   |
87 |     Let(String, Option<Type>, Option<Expr>),
   |     --- `ast::Stmt::Let` defined here
   |
help: `ast::Stmt::Let` is a tuple variant, use the appropriate syntax
   |
72 -                 Ok(Stmt::Let {
73 -                     pattern: pattern.clone(),
74 -                     ty: ty.clone(),
75 -                     init,
76 -                     span: *span,
77 -                 })
72 +                 Ok(Stmt::Let(/* String */, /* Option<ast::Type> */, /* Option<ast::Expr> */))
   |

error[E0559]: variant `ast::Stmt::Let` has no field named `span`
  --> compiler/src/macro_system/expander.rs:76:21
   |
76 |                     span: *span,
   |                     ^^^^ field does not exist
   |
  ::: compiler/src/parser/ast.rs:87:5
   |
87 |     Let(String, Option<Type>, Option<Expr>),
   |     --- `ast::Stmt::Let` defined here
   |
help: `ast::Stmt::Let` is a tuple variant, use the appropriate syntax
   |
72 -                 Ok(Stmt::Let {
73 -                     pattern: pattern.clone(),
74 -                     ty: ty.clone(),
75 -                     init,
76 -                     span: *span,
77 -                 })
72 +                 Ok(Stmt::Let(/* String */, /* Option<ast::Type> */, /* Option<ast::Expr> */))
   |

error[E0308]: mismatched types
  --> compiler/src/macro_system/expander.rs:86:17
   |
86 |                 format!("macro expansion depth exceeded (max: {})", self.max_depth),
   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `String`
   |
   = note: this error originates in the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0277]: the trait bound `String: From<span::Span>` is not satisfied
  --> compiler/src/macro_system/expander.rs:87:17
   |
85 |             return Err(Error::new(
   |                        ---------- required by a bound introduced by this call
86 |                 format!("macro expansion depth exceeded (max: {})", self.max_depth),
87 |                 span,
   |                 ^^^^ the trait `From<span::Span>` is not implemented for `String`
   |
   = help: the following other types implement trait `From<T>`:
             `String` implements `From<&String>`
             `String` implements `From<&mut str>`
             `String` implements `From<&str>`
             `String` implements `From<Box<str>>`
             `String` implements `From<Cow<'_, str>>`
             `String` implements `From<char>`
             `String` implements `From<clap::Id>`
             `String` implements `From<clap::builder::Str>`
   = note: required for `span::Span` to implement `Into<String>`
note: required by a bound in `error::Error::new`
  --> compiler/src/error.rs:47:47
   |
47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
   |                                               ^^^^^^^^^^^^ required by this bound in `Error::new`

error[E0308]: mismatched types
  --> compiler/src/macro_system/expander.rs:92:39
   |
92 |             .ok_or_else(|| Error::new(format!("undefined macro: {}", name), span))?;
   |                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `String`
   |
   = note: this error originates in the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0277]: the trait bound `String: From<span::Span>` is not satisfied
  --> compiler/src/macro_system/expander.rs:92:77
   |
92 |             .ok_or_else(|| Error::new(format!("undefined macro: {}", name), span))?;
   |                            ----------                                       ^^^^ the trait `From<span::Span>` is not implemented for `String`
   |                            |
   |                            required by a bound introduced by this call
   |
   = help: the following other types implement trait `From<T>`:
             `String` implements `From<&String>`
             `String` implements `From<&mut str>`
             `String` implements `From<&str>`
             `String` implements `From<Box<str>>`
             `String` implements `From<Cow<'_, str>>`
             `String` implements `From<char>`
             `String` implements `From<clap::Id>`
             `String` implements `From<clap::builder::Str>`
   = note: required for `span::Span` to implement `Into<String>`
note: required by a bound in `error::Error::new`
  --> compiler/src/error.rs:47:47
   |
47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
   |                                               ^^^^^^^^^^^^ required by this bound in `Error::new`

error[E0308]: mismatched types
   --> compiler/src/macro_system/expander.rs:110:21
    |
110 |                     format!("no matching macro rule for {}", def.name),
    |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `String`
    |
    = note: this error originates in the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0277]: the trait bound `String: From<span::Span>` is not satisfied
   --> compiler/src/macro_system/expander.rs:111:21
    |
109 |                 Err(Error::new(
    |                     ---------- required by a bound introduced by this call
110 |                     format!("no matching macro rule for {}", def.name),
111 |                     span,
    |                     ^^^^ the trait `From<span::Span>` is not implemented for `String`
    |
    = help: the following other types implement trait `From<T>`:
              `String` implements `From<&String>`
              `String` implements `From<&mut str>`
              `String` implements `From<&str>`
              `String` implements `From<Box<str>>`
              `String` implements `From<Cow<'_, str>>`
              `String` implements `From<char>`
              `String` implements `From<clap::Id>`
              `String` implements `From<clap::builder::Str>`
    = note: required for `span::Span` to implement `Into<String>`
note: required by a bound in `error::Error::new`
   --> compiler/src/error.rs:47:47
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |                                               ^^^^^^^^^^^^ required by this bound in `Error::new`

error[E0277]: the trait bound `String: From<span::Span>` is not satisfied
   --> compiler/src/macro_system/expander.rs:116:73
    |
116 |                 Err(Error::new("procedural macros not yet implemented", span))
    |                     ----------                                          ^^^^ the trait `From<span::Span>` is not implemented for `String`
    |                     |
    |                     required by a bound introduced by this call
    |
    = help: the following other types implement trait `From<T>`:
              `String` implements `From<&String>`
              `String` implements `From<&mut str>`
              `String` implements `From<&str>`
              `String` implements `From<Box<str>>`
              `String` implements `From<Cow<'_, str>>`
              `String` implements `From<char>`
              `String` implements `From<clap::Id>`
              `String` implements `From<clap::builder::Str>`
    = note: required for `span::Span` to implement `Into<String>`
note: required by a bound in `error::Error::new`
   --> compiler/src/error.rs:47:47
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |                                               ^^^^^^^^^^^^ required by this bound in `Error::new`

error[E0308]: mismatched types
   --> compiler/src/macro_system/expander.rs:116:32
    |
116 |                 Err(Error::new("procedural macros not yet implemented", span))
    |                     ---------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `&str`
    |                     |
    |                     arguments to this function are incorrect
    |
note: associated function defined here
   --> compiler/src/error.rs:47:12
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |            ^^^ ---------------

error[E0559]: variant `ast::Expr::Block` has no field named `stmts`
   --> compiler/src/macro_system/expander.rs:224:13
    |
224 |             stmts: vec![],
    |             ^^^^^ field does not exist
    |
   ::: compiler/src/parser/ast.rs:103:5
    |
103 |     Block(Vec<Stmt>),
    |     ----- `ast::Expr::Block` defined here
    |
help: `ast::Expr::Block` is a tuple variant, use the appropriate syntax
    |
223 -         Ok(Expr::Block {
224 -             stmts: vec![],
225 -             span,
226 -         })
223 +         Ok(Expr::Block(/* Vec<ast::Stmt> */))
    |

error[E0559]: variant `ast::Expr::Block` has no field named `span`
   --> compiler/src/macro_system/expander.rs:225:13
    |
225 |             span,
    |             ^^^^ field does not exist
    |
   ::: compiler/src/parser/ast.rs:103:5
    |
103 |     Block(Vec<Stmt>),
    |     ----- `ast::Expr::Block` defined here
    |
help: `ast::Expr::Block` is a tuple variant, use the appropriate syntax
    |
223 -         Ok(Expr::Block {
224 -             stmts: vec![],
225 -             span,
226 -         })
223 +         Ok(Expr::Block(/* Vec<ast::Stmt> */))
    |

error[E0599]: no function or associated item named `dummy` found for struct `span::Span` in the current scope
   --> compiler/src/macro_system/mod.rs:132:29
    |
132 |                 span: Span::dummy(),
    |                             ^^^^^ function or associated item not found in `span::Span`
    |
   ::: compiler/src/span.rs:31:1
    |
 31 | pub struct Span {
    | --------------- function or associated item `dummy` not found for this struct
    |
note: if you're trying to build a new `span::Span`, consider using `span::Span::new` which returns `span::Span`
   --> compiler/src/span.rs:37:5
    |
 37 |     pub fn new(start: Position, end: Position) -> Self {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0599]: no function or associated item named `dummy` found for struct `span::Span` in the current scope
   --> compiler/src/macro_system/mod.rs:187:29
    |
187 |                 span: Span::dummy(),
    |                             ^^^^^ function or associated item not found in `span::Span`
    |
   ::: compiler/src/span.rs:31:1
    |
 31 | pub struct Span {
    | --------------- function or associated item `dummy` not found for this struct
    |
note: if you're trying to build a new `span::Span`, consider using `span::Span::new` which returns `span::Span`
   --> compiler/src/span.rs:37:5
    |
 37 |     pub fn new(start: Position, end: Position) -> Self {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0599]: no function or associated item named `dummy` found for struct `span::Span` in the current scope
   --> compiler/src/macro_system/mod.rs:209:29
    |
209 |                 span: Span::dummy(),
    |                             ^^^^^ function or associated item not found in `span::Span`
    |
   ::: compiler/src/span.rs:31:1
    |
 31 | pub struct Span {
    | --------------- function or associated item `dummy` not found for this struct
    |
note: if you're trying to build a new `span::Span`, consider using `span::Span::new` which returns `span::Span`
   --> compiler/src/span.rs:37:5
    |
 37 |     pub fn new(start: Position, end: Position) -> Self {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0282]: type annotations needed
   --> compiler/src/async_runtime/executor.rs:132:25
    |
132 |                         task.poll(&waker);
    |                         ^^^^ cannot infer type

error[E0599]: no function or associated item named `from_millis` found for struct `async_runtime::Duration` in the current scope
   --> compiler/src/async_runtime/executor.rs:135:49
    |
135 |                         Thread::sleep(Duration::from_millis(10));
    |                                                 ^^^^^^^^^^^ function or associated item not found in `async_runtime::Duration`
    |
   ::: compiler/src/async_runtime/mod.rs:142:1
    |
142 | pub struct Duration {
    | ------------------- function or associated item `from_millis` not found for this struct

error[E0026]: variant `ast::Expr::Literal` does not have a field named `value`
   --> compiler/src/verification/smt_solver.rs:109:29
    |
109 |             Expr::Literal { value, .. } => {
    |                             ^^^^^
    |                             |
    |                             variant `ast::Expr::Literal` does not have this field
    |                             help: `ast::Expr::Literal` has a field named `0`

error[E0599]: no variant named `Variable` found for enum `ast::Expr`
   --> compiler/src/verification/smt_solver.rs:116:19
    |
116 |             Expr::Variable { name, .. } => Ok(name.clone()),
    |                   ^^^^^^^^ variant not found in `ast::Expr`
    |
   ::: compiler/src/parser/ast.rs:94:1
    |
 94 | pub enum Expr {
    | ------------- variant `Variable` not found here

error[E0026]: variant `ast::Expr::Binary` does not have fields named `op`, `left`, `right`
   --> compiler/src/verification/smt_solver.rs:117:28
    |
117 |             Expr::Binary { op, left, right, .. } => {
    |                            ^^  ^^^^  ^^^^^ variant `ast::Expr::Binary` does not have these fields

error[E0026]: variant `ast::Expr::Unary` does not have fields named `op`, `operand`
   --> compiler/src/verification/smt_solver.rs:139:27
    |
139 |             Expr::Unary { op, operand, .. } => {
    |                           ^^  ^^^^^^^ variant `ast::Expr::Unary` does not have these fields

error[E0308]: mismatched types
   --> compiler/src/verification/smt_solver.rs:113:41
    |
113 |                     _ => Err(Error::new("Unsupported literal type for SMT", Span::dummy())),
    |                              ---------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `&str`
    |                              |
    |                              arguments to this function are incorrect
    |
note: associated function defined here
   --> compiler/src/error.rs:47:12
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |            ^^^ ---------------

error[E0308]: mismatched types
   --> compiler/src/verification/smt_solver.rs:134:48
    |
134 |                     _ => return Err(Error::new("Unsupported binary operator for SMT", Span::dummy())),
    |                                     ---------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `&str`
    |                                     |
    |                                     arguments to this function are incorrect
    |
note: associated function defined here
   --> compiler/src/error.rs:47:12
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |            ^^^ ---------------

error[E0308]: mismatched types
   --> compiler/src/verification/smt_solver.rs:145:48
    |
145 |                     _ => return Err(Error::new("Unsupported unary operator for SMT", Span::dummy())),
    |                                     ---------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `&str`
    |                                     |
    |                                     arguments to this function are incorrect
    |
note: associated function defined here
   --> compiler/src/error.rs:47:12
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |            ^^^ ---------------

error[E0308]: mismatched types
   --> compiler/src/verification/smt_solver.rs:150:33
    |
150 |             _ => Err(Error::new("Unsupported expression type for SMT", Span::dummy())),
    |                      ---------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `&str`
    |                      |
    |                      arguments to this function are incorrect
    |
note: associated function defined here
   --> compiler/src/error.rs:47:12
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |            ^^^ ---------------

error[E0599]: no variant named `Variable` found for enum `ast::Expr`
   --> compiler/src/verification/smt_solver.rs:164:19
    |
164 |             Expr::Variable { name, .. } => {
    |                   ^^^^^^^^ variant not found in `ast::Expr`
    |
   ::: compiler/src/parser/ast.rs:94:1
    |
 94 | pub enum Expr {
    | ------------- variant `Variable` not found here

error[E0026]: variant `ast::Expr::Binary` does not have fields named `left`, `right`
   --> compiler/src/verification/smt_solver.rs:167:28
    |
167 |             Expr::Binary { left, right, .. } => {
    |                            ^^^^  ^^^^^ variant `ast::Expr::Binary` does not have these fields

error[E0026]: variant `ast::Expr::Unary` does not have a field named `operand`
   --> compiler/src/verification/smt_solver.rs:171:27
    |
171 |             Expr::Unary { operand, .. } => {
    |                           ^^^^^^^ variant `ast::Expr::Unary` does not have this field

error[E0308]: mismatched types
   --> compiler/src/verification/smt_solver.rs:195:37
    |
195 |             .map_err(|e| Error::new(format!("Failed to spawn SMT solver: {}", e), Span::dummy()))?;
    |                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `String`
    |
    = note: this error originates in the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0308]: mismatched types
   --> compiler/src/verification/smt_solver.rs:199:41
    |
199 |                 .map_err(|e| Error::new(format!("Failed to write to SMT solver: {}", e), Span::dummy()))?;
    |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `String`
    |
    = note: this error originates in the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0308]: mismatched types
   --> compiler/src/verification/smt_solver.rs:203:37
    |
203 |             .map_err(|e| Error::new(format!("Failed to read SMT solver output: {}", e), Span::dummy()))?;
    |                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `String`
    |
    = note: this error originates in the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0599]: no method named `prove_postcondition` found for mutable reference `&mut FormalVerifier` in the current scope
   --> compiler/src/verification/mod.rs:115:30
    |
115 |             let proof = self.prove_postcondition(func, post)?;
    |                              ^^^^^^^^^^^^^^^^^^^
    |
help: there is a method `verify_postcondition` with a similar name
    |
115 -             let proof = self.prove_postcondition(func, post)?;
115 +             let proof = self.verify_postcondition(func, post)?;
    |

error[E0599]: no method named `check_memory_safety` found for mutable reference `&mut FormalVerifier` in the current scope
   --> compiler/src/verification/mod.rs:120:34
    |
120 |         let memory_safety = self.check_memory_safety(func)?;
    |                                  ^^^^^^^^^^^^^^^^^^^
    |
help: there is a method `check_null_safety` with a similar name
    |
120 -         let memory_safety = self.check_memory_safety(func)?;
120 +         let memory_safety = self.check_null_safety(func)?;
    |

error[E0599]: no method named `prove_invariant_init` found for mutable reference `&mut FormalVerifier` in the current scope
   --> compiler/src/verification/mod.rs:136:31
    |
136 |         let init_proof = self.prove_invariant_init(&invariant)?;
    |                               ^^^^^^^^^^^^^^^^^^^^
    |
help: there is a method `verify_invariant_init` with a similar name
    |
136 -         let init_proof = self.prove_invariant_init(&invariant)?;
136 +         let init_proof = self.verify_invariant_init(&invariant)?;
    |

error[E0599]: no method named `prove_invariant_maintained` found for mutable reference `&mut FormalVerifier` in the current scope
   --> compiler/src/verification/mod.rs:142:35
    |
142 |         let maintain_proof = self.prove_invariant_maintained(&invariant, loop_stmt)?;
    |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^ method not found in `&mut FormalVerifier`

error[E0609]: no field `attributes` on type `&ast::Function`
   --> compiler/src/verification/mod.rs:204:27
    |
204 |         for attr in &func.attributes {
    |                           ^^^^^^^^^^ unknown field
    |
    = note: available fields are: `name`, `generics`, `params`, `return_type`, `where_clause`, `body`

error[E0282]: type annotations needed
   --> compiler/src/verification/mod.rs:207:40
    |
207 |                     preconditions.push(expr.clone());
    |                                        ^^^^ cannot infer type

error[E0609]: no field `attributes` on type `&ast::Function`
   --> compiler/src/verification/mod.rs:219:27
    |
219 |         for attr in &func.attributes {
    |                           ^^^^^^^^^^ unknown field
    |
    = note: available fields are: `name`, `generics`, `params`, `return_type`, `where_clause`, `body`

error[E0282]: type annotations needed
   --> compiler/src/verification/mod.rs:222:41
    |
222 |                     postconditions.push(expr.clone());
    |                                         ^^^^ cannot infer type

error[E0026]: variant `ast::Stmt::Let` does not have fields named `pattern`, `init`
   --> compiler/src/gpu/mod.rs:243:25
    |
243 |             Stmt::Let { pattern, init, .. } => {
    |                         ^^^^^^^  ^^^^ variant `ast::Stmt::Let` does not have these fields

error[E0026]: variant `ast::Expr::Literal` does not have a field named `value`
   --> compiler/src/gpu/mod.rs:259:29
    |
259 |             Expr::Literal { value, .. } => {
    |                             ^^^^^
    |                             |
    |                             variant `ast::Expr::Literal` does not have this field
    |                             help: `ast::Expr::Literal` has a field named `0`

error[E0599]: no variant named `Variable` found for enum `ast::Expr`
   --> compiler/src/gpu/mod.rs:267:19
    |
267 |             Expr::Variable { name, .. } => Ok(name.clone()),
    |                   ^^^^^^^^ variant not found in `ast::Expr`
    |
   ::: compiler/src/parser/ast.rs:94:1
    |
 94 | pub enum Expr {
    | ------------- variant `Variable` not found here

error[E0026]: variant `ast::Expr::Binary` does not have fields named `op`, `left`, `right`
   --> compiler/src/gpu/mod.rs:268:28
    |
268 |             Expr::Binary { op, left, right, .. } => {
    |                            ^^  ^^^^  ^^^^^ variant `ast::Expr::Binary` does not have these fields

error[E0599]: no variant or associated item named `I32` found for enum `ast::Type` in the current scope
   --> compiler/src/gpu/mod.rs:304:19
    |
304 |             Type::I32 => Ok("int".to_string()),
    |                   ^^^ variant or associated item not found in `ast::Type`
    |
   ::: compiler/src/parser/ast.rs:73:1
    |
 73 | pub enum Type {
    | ------------- variant or associated item `I32` not found for this enum

error[E0599]: no variant or associated item named `I64` found for enum `ast::Type` in the current scope
   --> compiler/src/gpu/mod.rs:305:19
    |
305 |             Type::I64 => Ok("long".to_string()),
    |                   ^^^ variant or associated item not found in `ast::Type`
    |
   ::: compiler/src/parser/ast.rs:73:1
    |
 73 | pub enum Type {
    | ------------- variant or associated item `I64` not found for this enum

error[E0599]: no variant or associated item named `F32` found for enum `ast::Type` in the current scope
   --> compiler/src/gpu/mod.rs:306:19
    |
306 |             Type::F32 => Ok("float".to_string()),
    |                   ^^^ variant or associated item not found in `ast::Type`
    |
   ::: compiler/src/parser/ast.rs:73:1
    |
 73 | pub enum Type {
    | ------------- variant or associated item `F32` not found for this enum

error[E0599]: no variant or associated item named `F64` found for enum `ast::Type` in the current scope
   --> compiler/src/gpu/mod.rs:307:19
    |
307 |             Type::F64 => Ok("double".to_string()),
    |                   ^^^ variant or associated item not found in `ast::Type`
    |
   ::: compiler/src/parser/ast.rs:73:1
    |
 73 | pub enum Type {
    | ------------- variant or associated item `F64` not found for this enum

error[E0599]: no variant or associated item named `Pointer` found for enum `ast::Type` in the current scope
   --> compiler/src/gpu/mod.rs:308:19
    |
308 |             Type::Pointer(inner) => Ok(format!("{}*", self.cuda_type(inner)?)),
    |                   ^^^^^^^ variant or associated item not found in `ast::Type`
    |
   ::: compiler/src/parser/ast.rs:73:1
    |
 73 | pub enum Type {
    | ------------- variant or associated item `Pointer` not found for this enum

error[E0599]: no variant or associated item named `I32` found for enum `ast::Type` in the current scope
   --> compiler/src/gpu/mod.rs:315:19
    |
315 |             Type::I32 => Ok("device int*".to_string()),
    |                   ^^^ variant or associated item not found in `ast::Type`
    |
   ::: compiler/src/parser/ast.rs:73:1
    |
 73 | pub enum Type {
    | ------------- variant or associated item `I32` not found for this enum

error[E0599]: no variant or associated item named `I64` found for enum `ast::Type` in the current scope
   --> compiler/src/gpu/mod.rs:316:19
    |
316 |             Type::I64 => Ok("device long*".to_string()),
    |                   ^^^ variant or associated item not found in `ast::Type`
    |
   ::: compiler/src/parser/ast.rs:73:1
    |
 73 | pub enum Type {
    | ------------- variant or associated item `I64` not found for this enum

error[E0599]: no variant or associated item named `F32` found for enum `ast::Type` in the current scope
   --> compiler/src/gpu/mod.rs:317:19
    |
317 |             Type::F32 => Ok("device float*".to_string()),
    |                   ^^^ variant or associated item not found in `ast::Type`
    |
   ::: compiler/src/parser/ast.rs:73:1
    |
 73 | pub enum Type {
    | ------------- variant or associated item `F32` not found for this enum

error[E0599]: no variant or associated item named `F64` found for enum `ast::Type` in the current scope
   --> compiler/src/gpu/mod.rs:318:19
    |
318 |             Type::F64 => Ok("device double*".to_string()),
    |                   ^^^ variant or associated item not found in `ast::Type`
    |
   ::: compiler/src/parser/ast.rs:73:1
    |
 73 | pub enum Type {
    | ------------- variant or associated item `F64` not found for this enum

error[E0599]: no variant or associated item named `I32` found for enum `ast::Type` in the current scope
   --> compiler/src/gpu/mod.rs:325:19
    |
325 |             Type::I32 => Ok("int".to_string()),
    |                   ^^^ variant or associated item not found in `ast::Type`
    |
   ::: compiler/src/parser/ast.rs:73:1
    |
 73 | pub enum Type {
    | ------------- variant or associated item `I32` not found for this enum

error[E0599]: no variant or associated item named `I64` found for enum `ast::Type` in the current scope
   --> compiler/src/gpu/mod.rs:326:19
    |
326 |             Type::I64 => Ok("int64_t".to_string()),
    |                   ^^^ variant or associated item not found in `ast::Type`
    |
   ::: compiler/src/parser/ast.rs:73:1
    |
 73 | pub enum Type {
    | ------------- variant or associated item `I64` not found for this enum

error[E0599]: no variant or associated item named `F32` found for enum `ast::Type` in the current scope
   --> compiler/src/gpu/mod.rs:327:19
    |
327 |             Type::F32 => Ok("float".to_string()),
    |                   ^^^ variant or associated item not found in `ast::Type`
    |
   ::: compiler/src/parser/ast.rs:73:1
    |
 73 | pub enum Type {
    | ------------- variant or associated item `F32` not found for this enum

error[E0599]: no variant or associated item named `F64` found for enum `ast::Type` in the current scope
   --> compiler/src/gpu/mod.rs:328:19
    |
328 |             Type::F64 => Ok("double".to_string()),
    |                   ^^^ variant or associated item not found in `ast::Type`
    |
   ::: compiler/src/parser/ast.rs:73:1
    |
 73 | pub enum Type {
    | ------------- variant or associated item `F64` not found for this enum

error[E0599]: no variant or associated item named `I32` found for enum `ast::Type` in the current scope
   --> compiler/src/gpu/mod.rs:335:19
    |
335 |             Type::I32 => Ok("int*".to_string()),
    |                   ^^^ variant or associated item not found in `ast::Type`
    |
   ::: compiler/src/parser/ast.rs:73:1
    |
 73 | pub enum Type {
    | ------------- variant or associated item `I32` not found for this enum

error[E0599]: no variant or associated item named `I64` found for enum `ast::Type` in the current scope
   --> compiler/src/gpu/mod.rs:336:19
    |
336 |             Type::I64 => Ok("long*".to_string()),
    |                   ^^^ variant or associated item not found in `ast::Type`
    |
   ::: compiler/src/parser/ast.rs:73:1
    |
 73 | pub enum Type {
    | ------------- variant or associated item `I64` not found for this enum

error[E0599]: no variant or associated item named `F32` found for enum `ast::Type` in the current scope
   --> compiler/src/gpu/mod.rs:337:19
    |
337 |             Type::F32 => Ok("float*".to_string()),
    |                   ^^^ variant or associated item not found in `ast::Type`
    |
   ::: compiler/src/parser/ast.rs:73:1
    |
 73 | pub enum Type {
    | ------------- variant or associated item `F32` not found for this enum

error[E0599]: no variant or associated item named `F64` found for enum `ast::Type` in the current scope
   --> compiler/src/gpu/mod.rs:338:19
    |
338 |             Type::F64 => Ok("double*".to_string()),
    |                   ^^^ variant or associated item not found in `ast::Type`
    |
   ::: compiler/src/parser/ast.rs:73:1
    |
 73 | pub enum Type {
    | ------------- variant or associated item `F64` not found for this enum

error[E0026]: variant `ast::Expr::Literal` does not have a field named `value`
  --> compiler/src/consteval/mod.rs:61:29
   |
61 |             Expr::Literal { value, .. } => self.eval_literal(value),
   |                             ^^^^^
   |                             |
   |                             variant `ast::Expr::Literal` does not have this field
   |                             help: `ast::Expr::Literal` has a field named `0`

error[E0599]: no variant named `Variable` found for enum `ast::Expr`
  --> compiler/src/consteval/mod.rs:63:19
   |
63 |             Expr::Variable { name, .. } => {
   |                   ^^^^^^^^ variant not found in `ast::Expr`
   |
  ::: compiler/src/parser/ast.rs:94:1
   |
94 | pub enum Expr {
   | ------------- variant `Variable` not found here

error[E0026]: variant `ast::Expr::Binary` does not have fields named `op`, `left`, `right`
  --> compiler/src/consteval/mod.rs:72:28
   |
72 |             Expr::Binary { op, left, right, .. } => {
   |                            ^^  ^^^^  ^^^^^ variant `ast::Expr::Binary` does not have these fields

error[E0026]: variant `ast::Expr::Unary` does not have fields named `op`, `operand`
  --> compiler/src/consteval/mod.rs:78:27
   |
78 |             Expr::Unary { op, operand, .. } => {
   |                           ^^  ^^^^^^^ variant `ast::Expr::Unary` does not have these fields

error[E0026]: variant `ast::Expr::Call` does not have fields named `func`, `args`
  --> compiler/src/consteval/mod.rs:83:26
   |
83 |             Expr::Call { func, args, .. } => {
   |                          ^^^^  ^^^^ variant `ast::Expr::Call` does not have these fields

error[E0026]: variant `ast::Expr::If` does not have fields named `condition`, `then_branch`, `else_branch`
  --> compiler/src/consteval/mod.rs:87:24
   |
87 |             Expr::If { condition, then_branch, else_branch, .. } => {
   |                        ^^^^^^^^^  ^^^^^^^^^^^  ^^^^^^^^^^^ variant `ast::Expr::If` does not have these fields

error[E0026]: variant `ast::Expr::Array` does not have a field named `elements`
  --> compiler/src/consteval/mod.rs:98:27
   |
98 |             Expr::Array { elements, .. } => {
   |                           ^^^^^^^^
   |                           |
   |                           variant `ast::Expr::Array` does not have this field
   |                           help: `ast::Expr::Array` has a field named `0`

error[E0308]: mismatched types
  --> compiler/src/consteval/mod.rs:67:25
   |
67 |                         format!("Undefined constant: {}", name),
   |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `String`
   |
   = note: this error originates in the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0308]: mismatched types
   --> compiler/src/consteval/mod.rs:107:17
    |
106 |             _ => Err(Error::new(
    |                      ---------- arguments to this function are incorrect
107 |                 "Expression cannot be evaluated at compile time",
    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `&str`
    |
note: associated function defined here
   --> compiler/src/error.rs:47:12
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |            ^^^ ---------------

error[E0308]: mismatched types
   --> compiler/src/consteval/mod.rs:132:51
    |
132 | ...                   return Err(Error::new("Division by zero", Span::dummy()));
    |                                  ---------- ^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `&str`
    |                                  |
    |                                  arguments to this function are incorrect
    |
note: associated function defined here
   --> compiler/src/error.rs:47:12
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |            ^^^ ---------------

error[E0308]: mismatched types
   --> compiler/src/consteval/mod.rs:148:48
    |
148 |                     _ => return Err(Error::new("Unsupported binary operation", Span::dummy())),
    |                                     ---------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `&str`
    |                                     |
    |                                     arguments to this function are incorrect
    |
note: associated function defined here
   --> compiler/src/error.rs:47:12
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |            ^^^ ---------------

error[E0308]: mismatched types
   --> compiler/src/consteval/mod.rs:165:48
    |
165 |                     _ => return Err(Error::new("Unsupported binary operation", Span::dummy())),
    |                                     ---------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `&str`
    |                                     |
    |                                     arguments to this function are incorrect
    |
note: associated function defined here
   --> compiler/src/error.rs:47:12
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |            ^^^ ---------------

error[E0308]: mismatched types
   --> compiler/src/consteval/mod.rs:176:48
    |
176 |                     _ => return Err(Error::new("Unsupported binary operation", Span::dummy())),
    |                                     ---------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `&str`
    |                                     |
    |                                     arguments to this function are incorrect
    |
note: associated function defined here
   --> compiler/src/error.rs:47:12
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |            ^^^ ---------------

error[E0308]: mismatched types
   --> compiler/src/consteval/mod.rs:181:33
    |
181 |             _ => Err(Error::new("Type mismatch in binary operation", Span::dummy())),
    |                      ---------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `&str`
    |                      |
    |                      arguments to this function are incorrect
    |
note: associated function defined here
   --> compiler/src/error.rs:47:12
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |            ^^^ ---------------

error[E0308]: mismatched types
   --> compiler/src/consteval/mod.rs:192:48
    |
192 |                     _ => return Err(Error::new("Unsupported unary operation", Span::dummy())),
    |                                     ---------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `&str`
    |                                     |
    |                                     arguments to this function are incorrect
    |
note: associated function defined here
   --> compiler/src/error.rs:47:12
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |            ^^^ ---------------

error[E0308]: mismatched types
   --> compiler/src/consteval/mod.rs:200:48
    |
200 |                     _ => return Err(Error::new("Unsupported unary operation", Span::dummy())),
    |                                     ---------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `&str`
    |                                     |
    |                                     arguments to this function are incorrect
    |
note: associated function defined here
   --> compiler/src/error.rs:47:12
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |            ^^^ ---------------

error[E0308]: mismatched types
   --> compiler/src/consteval/mod.rs:208:48
    |
208 |                     _ => return Err(Error::new("Unsupported unary operation", Span::dummy())),
    |                                     ---------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `&str`
    |                                     |
    |                                     arguments to this function are incorrect
    |
note: associated function defined here
   --> compiler/src/error.rs:47:12
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |            ^^^ ---------------

error[E0308]: mismatched types
   --> compiler/src/consteval/mod.rs:213:33
    |
213 |             _ => Err(Error::new("Type mismatch in unary operation", Span::dummy())),
    |                      ---------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `&str`
    |                      |
    |                      arguments to this function are incorrect
    |
note: associated function defined here
   --> compiler/src/error.rs:47:12
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |            ^^^ ---------------

error[E0599]: no variant named `Variable` found for enum `ast::Expr`
   --> compiler/src/consteval/mod.rs:220:19
    |
220 |             Expr::Variable { name, .. } => name,
    |                   ^^^^^^^^ variant not found in `ast::Expr`
    |
   ::: compiler/src/parser/ast.rs:94:1
    |
 94 | pub enum Expr {
    | ------------- variant `Variable` not found here

error[E0308]: mismatched types
   --> compiler/src/consteval/mod.rs:221:40
    |
221 |             _ => return Err(Error::new("Invalid function call", Span::dummy())),
    |                             ---------- ^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `&str`
    |                             |
    |                             arguments to this function are incorrect
    |
note: associated function defined here
   --> compiler/src/error.rs:47:12
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |            ^^^ ---------------

error[E0308]: mismatched types
   --> compiler/src/consteval/mod.rs:238:17
    |
238 |                 format!("Unknown compile-time function: {}", func_name),
    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `String`
    |
    = note: this error originates in the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0308]: mismatched types
   --> compiler/src/consteval/mod.rs:246:35
    |
246 |             return Err(Error::new("abs expects 1 argument", Span::dummy()));
    |                        ---------- ^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `&str`
    |                        |
    |                        arguments to this function are incorrect
    |
note: associated function defined here
   --> compiler/src/error.rs:47:12
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |            ^^^ ---------------

error[E0308]: mismatched types
   --> compiler/src/consteval/mod.rs:252:33
    |
252 |             _ => Err(Error::new("abs expects numeric argument", Span::dummy())),
    |                      ---------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `&str`
    |                      |
    |                      arguments to this function are incorrect
    |
note: associated function defined here
   --> compiler/src/error.rs:47:12
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |            ^^^ ---------------

error[E0308]: mismatched types
   --> compiler/src/consteval/mod.rs:258:35
    |
258 |             return Err(Error::new("min expects 2 arguments", Span::dummy()));
    |                        ---------- ^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `&str`
    |                        |
    |                        arguments to this function are incorrect
    |
note: associated function defined here
   --> compiler/src/error.rs:47:12
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |            ^^^ ---------------

error[E0308]: mismatched types
   --> compiler/src/consteval/mod.rs:264:33
    |
264 |             _ => Err(Error::new("min expects numeric arguments", Span::dummy())),
    |                      ---------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `&str`
    |                      |
    |                      arguments to this function are incorrect
    |
note: associated function defined here
   --> compiler/src/error.rs:47:12
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |            ^^^ ---------------

error[E0308]: mismatched types
   --> compiler/src/consteval/mod.rs:270:35
    |
270 |             return Err(Error::new("max expects 2 arguments", Span::dummy()));
    |                        ---------- ^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `&str`
    |                        |
    |                        arguments to this function are incorrect
    |
note: associated function defined here
   --> compiler/src/error.rs:47:12
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |            ^^^ ---------------

error[E0308]: mismatched types
   --> compiler/src/consteval/mod.rs:276:33
    |
276 |             _ => Err(Error::new("max expects numeric arguments", Span::dummy())),
    |                      ---------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `&str`
    |                      |
    |                      arguments to this function are incorrect
    |
note: associated function defined here
   --> compiler/src/error.rs:47:12
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |            ^^^ ---------------

error[E0308]: mismatched types
   --> compiler/src/consteval/mod.rs:282:35
    |
282 |             return Err(Error::new("pow expects 2 arguments", Span::dummy()));
    |                        ---------- ^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `&str`
    |                        |
    |                        arguments to this function are incorrect
    |
note: associated function defined here
   --> compiler/src/error.rs:47:12
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |            ^^^ ---------------

error[E0308]: mismatched types
   --> compiler/src/consteval/mod.rs:291:43
    |
291 |                     return Err(Error::new("Negative exponent for integer pow", Span::dummy()));
    |                                ---------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `&str`
    |                                |
    |                                arguments to this function are incorrect
    |
note: associated function defined here
   --> compiler/src/error.rs:47:12
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |            ^^^ ---------------

error[E0308]: mismatched types
   --> compiler/src/consteval/mod.rs:295:33
    |
295 |             _ => Err(Error::new("pow expects numeric arguments", Span::dummy())),
    |                      ---------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `&str`
    |                      |
    |                      arguments to this function are incorrect
    |
note: associated function defined here
   --> compiler/src/error.rs:47:12
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |            ^^^ ---------------

error[E0308]: mismatched types
   --> compiler/src/consteval/mod.rs:301:35
    |
301 |             return Err(Error::new("sqrt expects 1 argument", Span::dummy()));
    |                        ---------- ^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `&str`
    |                        |
    |                        arguments to this function are incorrect
    |
note: associated function defined here
   --> compiler/src/error.rs:47:12
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |            ^^^ ---------------

error[E0308]: mismatched types
   --> compiler/src/consteval/mod.rs:307:43
    |
307 |                     return Err(Error::new("sqrt of negative number", Span::dummy()));
    |                                ---------- ^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `&str`
    |                                |
    |                                arguments to this function are incorrect
    |
note: associated function defined here
   --> compiler/src/error.rs:47:12
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |            ^^^ ---------------

error[E0308]: mismatched types
   --> compiler/src/consteval/mod.rs:311:33
    |
311 |             _ => Err(Error::new("sqrt expects float argument", Span::dummy())),
    |                      ---------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `&str`
    |                      |
    |                      arguments to this function are incorrect
    |
note: associated function defined here
   --> compiler/src/error.rs:47:12
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |            ^^^ ---------------

warning: unused variable: `func`
   --> compiler/src/verification/mod.rs:194:41
    |
194 |     fn check_overflow_safety(&mut self, func: &Function) -> Result<bool> {
    |                                         ^^^^ help: if this is intentional, prefix it with an underscore: `_func`
    |
    = note: `#[warn(unused_variables)]` (part of `#[warn(unused)]`) on by default

error[E0594]: cannot assign to `proof.status`, as `proof` is not declared as mutable
   --> compiler/src/verification/mod.rs:247:13
    |
247 |             proof.status = ProofStatus::Proven;
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ cannot assign
    |
help: consider changing this to be mutable
    |
237 |         let mut proof = Proof {
    |             +++

error[E0594]: cannot assign to `proof.status`, as `proof` is not declared as mutable
   --> compiler/src/verification/mod.rs:249:13
    |
249 |             proof.status = ProofStatus::Failed;
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ cannot assign
    |
help: consider changing this to be mutable
    |
237 |         let mut proof = Proof {
    |             +++

warning: variable does not need to be mutable
   --> compiler/src/verification/mod.rs:268:13
    |
268 |         let mut proof = Proof {
    |             ----^^^^^
    |             |
    |             help: remove this `mut`
    |
    = note: `#[warn(unused_mut)]` (part of `#[warn(unused)]`) on by default

Some errors have detailed explanations: E0023, E0026, E0027, E0277, E0282, E0308, E0412, E0432, E0433...
For more information about an error, try `rustc --explain E0023`.
warning: `vez_compiler` (lib) generated 14 warnings
error: could not compile `vez_compiler` (lib) due to 288 previous errors; 14 warnings emitted
[0;32mâœ“[0m Compiler binary built successfully
[1;33mâ†’[0m Building all workspace packages...
warning: profiles for the non root package will be ignored, specify profiles at the workspace root:
package:   /run/media/zarigata/42A0B8BDA0B8B8AD/ARTIFICIAL-INTELIGENCE/ArtificialProgramingLanguage/compiler/Cargo.toml
workspace: /run/media/zarigata/42A0B8BDA0B8B8AD/ARTIFICIAL-INTELIGENCE/ArtificialProgramingLanguage/Cargo.toml
   Compiling serde_core v1.0.228
   Compiling serde v1.0.228
   Compiling anyhow v1.0.100
   Compiling zmij v1.0.12
   Compiling serde_json v1.0.149
   Compiling hashbrown v0.16.1
   Compiling equivalent v1.0.2
   Compiling winnow v0.7.14
   Compiling itoa v1.0.17
   Compiling toml_write v0.1.2
   Compiling serde_derive v1.0.228
   Compiling vez_compiler v0.1.0 (/run/media/zarigata/42A0B8BDA0B8B8AD/ARTIFICIAL-INTELIGENCE/ArtificialProgramingLanguage/compiler)
error[E0583]: file not found for module `hygiene`
 --> compiler/src/macro_system/mod.rs:5:1
  |
5 | pub mod hygiene;
  | ^^^^^^^^^^^^^^^^
  |
  = help: to create the module `hygiene`, create file "compiler/src/macro_system/hygiene.rs" or "compiler/src/macro_system/hygiene/mod.rs"
  = note: if there is a `mod hygiene` elsewhere in the crate already, import it with `use crate::...` instead

error[E0583]: file not found for module `parser`
 --> compiler/src/macro_system/mod.rs:6:1
  |
6 | pub mod parser;
  | ^^^^^^^^^^^^^^^
  |
  = help: to create the module `parser`, create file "compiler/src/macro_system/parser.rs" or "compiler/src/macro_system/parser/mod.rs"
  = note: if there is a `mod parser` elsewhere in the crate already, import it with `use crate::...` instead

error[E0583]: file not found for module `builtin`
 --> compiler/src/macro_system/mod.rs:7:1
  |
7 | pub mod builtin;
  | ^^^^^^^^^^^^^^^^
  |
  = help: to create the module `builtin`, create file "compiler/src/macro_system/builtin.rs" or "compiler/src/macro_system/builtin/mod.rs"
  = note: if there is a `mod builtin` elsewhere in the crate already, import it with `use crate::...` instead

error[E0583]: file not found for module `future`
 --> compiler/src/async_runtime/mod.rs:4:1
  |
4 | pub mod future;
  | ^^^^^^^^^^^^^^^
  |
  = help: to create the module `future`, create file "compiler/src/async_runtime/future.rs" or "compiler/src/async_runtime/future/mod.rs"
  = note: if there is a `mod future` elsewhere in the crate already, import it with `use crate::...` instead

error[E0583]: file not found for module `task`
 --> compiler/src/async_runtime/mod.rs:6:1
  |
6 | pub mod task;
  | ^^^^^^^^^^^^^
  |
  = help: to create the module `task`, create file "compiler/src/async_runtime/task.rs" or "compiler/src/async_runtime/task/mod.rs"
  = note: if there is a `mod task` elsewhere in the crate already, import it with `use crate::...` instead

error[E0583]: file not found for module `waker`
 --> compiler/src/async_runtime/mod.rs:7:1
  |
7 | pub mod waker;
  | ^^^^^^^^^^^^^^
  |
  = help: to create the module `waker`, create file "compiler/src/async_runtime/waker.rs" or "compiler/src/async_runtime/waker/mod.rs"
  = note: if there is a `mod waker` elsewhere in the crate already, import it with `use crate::...` instead

error[E0583]: file not found for module `proof_engine`
 --> compiler/src/verification/mod.rs:5:1
  |
5 | pub mod proof_engine;
  | ^^^^^^^^^^^^^^^^^^^^^
  |
  = help: to create the module `proof_engine`, create file "compiler/src/verification/proof_engine.rs" or "compiler/src/verification/proof_engine/mod.rs"
  = note: if there is a `mod proof_engine` elsewhere in the crate already, import it with `use crate::...` instead

error[E0583]: file not found for module `safety_checker`
 --> compiler/src/verification/mod.rs:6:1
  |
6 | pub mod safety_checker;
  | ^^^^^^^^^^^^^^^^^^^^^^^
  |
  = help: to create the module `safety_checker`, create file "compiler/src/verification/safety_checker.rs" or "compiler/src/verification/safety_checker/mod.rs"
  = note: if there is a `mod safety_checker` elsewhere in the crate already, import it with `use crate::...` instead

error[E0583]: file not found for module `contracts`
 --> compiler/src/verification/mod.rs:7:1
  |
7 | pub mod contracts;
  | ^^^^^^^^^^^^^^^^^^
  |
  = help: to create the module `contracts`, create file "compiler/src/verification/contracts.rs" or "compiler/src/verification/contracts/mod.rs"
  = note: if there is a `mod contracts` elsewhere in the crate already, import it with `use crate::...` instead

error[E0583]: file not found for module `cuda`
 --> compiler/src/gpu/mod.rs:4:1
  |
4 | pub mod cuda;
  | ^^^^^^^^^^^^^
  |
  = help: to create the module `cuda`, create file "compiler/src/gpu/cuda.rs" or "compiler/src/gpu/cuda/mod.rs"
  = note: if there is a `mod cuda` elsewhere in the crate already, import it with `use crate::...` instead

error[E0583]: file not found for module `metal`
 --> compiler/src/gpu/mod.rs:5:1
  |
5 | pub mod metal;
  | ^^^^^^^^^^^^^^
  |
  = help: to create the module `metal`, create file "compiler/src/gpu/metal.rs" or "compiler/src/gpu/metal/mod.rs"
  = note: if there is a `mod metal` elsewhere in the crate already, import it with `use crate::...` instead

error[E0583]: file not found for module `vulkan`
 --> compiler/src/gpu/mod.rs:6:1
  |
6 | pub mod vulkan;
  | ^^^^^^^^^^^^^^^
  |
  = help: to create the module `vulkan`, create file "compiler/src/gpu/vulkan.rs" or "compiler/src/gpu/vulkan/mod.rs"
  = note: if there is a `mod vulkan` elsewhere in the crate already, import it with `use crate::...` instead

error[E0583]: file not found for module `kernel`
 --> compiler/src/gpu/mod.rs:7:1
  |
7 | pub mod kernel;
  | ^^^^^^^^^^^^^^^
  |
  = help: to create the module `kernel`, create file "compiler/src/gpu/kernel.rs" or "compiler/src/gpu/kernel/mod.rs"
  = note: if there is a `mod kernel` elsewhere in the crate already, import it with `use crate::...` instead

error[E0432]: unresolved import `crate::semantic::types`
  --> compiler/src/verification/mod.rs:10:22
   |
10 | use crate::semantic::types::Type;
   |                      ^^^^^ could not find `types` in `semantic`

error[E0432]: unresolved import `crate::semantic::types`
 --> compiler/src/consteval/mod.rs:5:22
  |
5 | use crate::semantic::types::Type;
  |                      ^^^^^ could not find `types` in `semantic`

error[E0432]: unresolved import `crate::error::CompilerError`
 --> compiler/src/codegen/llvm_backend.rs:6:28
  |
6 | use crate::error::{Result, CompilerError};
  |                            ^^^^^^^^^^^^^ no `CompilerError` in `error`

error[E0432]: unresolved import `crate::error::CompilerError`
 --> compiler/src/codegen/target.rs:3:28
  |
3 | use crate::error::{Result, CompilerError};
  |                            ^^^^^^^^^^^^^ no `CompilerError` in `error`

error[E0432]: unresolved import `crate::error::CompilerError`
 --> compiler/src/codegen/linker.rs:3:28
  |
3 | use crate::error::{Result, CompilerError};
  |                            ^^^^^^^^^^^^^ no `CompilerError` in `error`

error[E0532]: expected tuple struct or tuple variant, found unit variant `Constant::Null`
   --> compiler/src/codegen/llvm_backend.rs:129:13
    |
129 |             Constant::Null(ty) => format!("{} null", self.type_to_llvm(ty)),
    |             ^^^^^^^^^^^^^^^^^^ help: use this syntax instead: `Constant::Null`
    |
   ::: compiler/src/ir/ssa.rs:30:5
    |
 30 |     Null,
    |     ---- `Constant::Null` defined here

error[E0532]: expected tuple struct or tuple variant, found unit variant `Constant::Undef`
   --> compiler/src/codegen/llvm_backend.rs:130:13
    |
130 |             Constant::Undef(ty) => format!("{} undef", self.type_to_llvm(ty)),
    |             ^^^^^^^^^^^^^^^^^^^ help: use this syntax instead: `Constant::Undef`
    |
   ::: compiler/src/ir/ssa.rs:31:5
    |
 31 |     Undef,
    |     ----- `Constant::Undef` defined here

error[E0433]: failed to resolve: use of undeclared type `Pin`
  --> compiler/src/async_runtime/executor.rs:64:19
   |
64 |             match Pin::new(&mut future).poll(&waker) {
   |                   ^^^ use of undeclared type `Pin`
   |
help: consider importing this struct
   |
 4 + use std::pin::Pin;
   |

error[E0412]: cannot find type `Thread` in this scope
   --> compiler/src/async_runtime/executor.rs:112:18
    |
112 |     threads: Vec<Thread>,
    |                  ^^^^^^ not found in this scope
    |
help: consider importing this struct
    |
  4 + use std::thread::Thread;
    |

error[E0412]: cannot find type `Arc` in this scope
   --> compiler/src/async_runtime/executor.rs:113:17
    |
113 |     task_queue: Arc<Mutex<VecDeque<Box<dyn Task>>>>,
    |                 ^^^ not found in this scope
    |
help: consider importing this struct
    |
  4 + use std::sync::Arc;
    |

error[E0412]: cannot find type `Mutex` in this scope
   --> compiler/src/async_runtime/executor.rs:113:21
    |
113 |     task_queue: Arc<Mutex<VecDeque<Box<dyn Task>>>>,
    |                     ^^^^^ not found in this scope
    |
help: consider importing one of these structs
    |
  4 + use std::sync::Mutex;
    |
  4 + use std::sync::nonpoison::Mutex;
    |

error[E0433]: failed to resolve: use of undeclared type `Arc`
   --> compiler/src/async_runtime/executor.rs:118:26
    |
118 |         let task_queue = Arc::new(Mutex::new(VecDeque::new()));
    |                          ^^^ use of undeclared type `Arc`
    |
help: consider importing this struct
    |
  4 + use std::sync::Arc;
    |

error[E0433]: failed to resolve: use of undeclared type `Mutex`
   --> compiler/src/async_runtime/executor.rs:118:35
    |
118 |         let task_queue = Arc::new(Mutex::new(VecDeque::new()));
    |                                   ^^^^^ use of undeclared type `Mutex`
    |
help: consider importing one of these structs
    |
  4 + use std::sync::Mutex;
    |
  4 + use std::sync::nonpoison::Mutex;
    |

error[E0433]: failed to resolve: use of undeclared type `Thread`
   --> compiler/src/async_runtime/executor.rs:123:26
    |
123 |             let thread = Thread::spawn(move || {
    |                          ^^^^^^ use of undeclared type `Thread`
    |
help: consider importing this struct
    |
  4 + use std::thread::Thread;
    |

error[E0433]: failed to resolve: use of undeclared type `Thread`
   --> compiler/src/async_runtime/executor.rs:135:25
    |
135 |                         Thread::sleep(Duration::from_millis(10));
    |                         ^^^^^^ use of undeclared type `Thread`
    |
help: consider importing this struct
    |
  4 + use std::thread::Thread;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/verification/smt_solver.rs:113:77
    |
113 |                     _ => Err(Error::new("Unsupported literal type for SMT", Span::dummy())),
    |                                                                             ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/verification/smt_solver.rs:122:21
    |
122 |                     BinaryOp::Add => "+",
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/verification/smt_solver.rs:123:21
    |
123 |                     BinaryOp::Sub => "-",
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/verification/smt_solver.rs:124:21
    |
124 |                     BinaryOp::Mul => "*",
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/verification/smt_solver.rs:125:21
    |
125 |                     BinaryOp::Div => "div",
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/verification/smt_solver.rs:126:21
    |
126 |                     BinaryOp::Eq => "=",
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/verification/smt_solver.rs:127:21
    |
127 |                     BinaryOp::Ne => "distinct",
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/verification/smt_solver.rs:128:21
    |
128 |                     BinaryOp::Lt => "<",
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/verification/smt_solver.rs:129:21
    |
129 |                     BinaryOp::Le => "<=",
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/verification/smt_solver.rs:130:21
    |
130 |                     BinaryOp::Gt => ">",
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/verification/smt_solver.rs:131:21
    |
131 |                     BinaryOp::Ge => ">=",
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/verification/smt_solver.rs:132:21
    |
132 |                     BinaryOp::And => "and",
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/verification/smt_solver.rs:133:21
    |
133 |                     BinaryOp::Or => "or",
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/verification/smt_solver.rs:134:87
    |
134 |                     _ => return Err(Error::new("Unsupported binary operator for SMT", Span::dummy())),
    |                                                                                       ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0433]: failed to resolve: use of undeclared type `UnaryOp`
   --> compiler/src/verification/smt_solver.rs:143:21
    |
143 |                     UnaryOp::Not => "not",
    |                     ^^^^^^^ use of undeclared type `UnaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::UnaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `UnaryOp`
   --> compiler/src/verification/smt_solver.rs:144:21
    |
144 |                     UnaryOp::Neg => "-",
    |                     ^^^^^^^ use of undeclared type `UnaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::UnaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/verification/smt_solver.rs:145:86
    |
145 |                     _ => return Err(Error::new("Unsupported unary operator for SMT", Span::dummy())),
    |                                                                                      ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/verification/smt_solver.rs:150:72
    |
150 |             _ => Err(Error::new("Unsupported expression type for SMT", Span::dummy())),
    |                                                                        ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/verification/smt_solver.rs:195:83
    |
195 |             .map_err(|e| Error::new(format!("Failed to spawn SMT solver: {}", e), Span::dummy()))?;
    |                                                                                   ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/verification/smt_solver.rs:199:90
    |
199 |                 .map_err(|e| Error::new(format!("Failed to write to SMT solver: {}", e), Span::dummy()))?;
    |                                                                                          ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/verification/smt_solver.rs:203:89
    |
203 |             .map_err(|e| Error::new(format!("Failed to read SMT solver output: {}", e), Span::dummy()))?;
    |                                                                                         ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0412]: cannot find type `BinaryOp` in this scope
   --> compiler/src/gpu/mod.rs:285:34
    |
285 |     fn binary_op_str(&self, op: &BinaryOp) -> &str {
    |                                  ^^^^^^^^ not found in this scope
    |
help: consider importing this enum
    |
  9 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/gpu/mod.rs:287:13
    |
287 |             BinaryOp::Add => "+",
    |             ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  9 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/gpu/mod.rs:288:13
    |
288 |             BinaryOp::Sub => "-",
    |             ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  9 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/gpu/mod.rs:289:13
    |
289 |             BinaryOp::Mul => "*",
    |             ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  9 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/gpu/mod.rs:290:13
    |
290 |             BinaryOp::Div => "/",
    |             ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  9 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/gpu/mod.rs:291:13
    |
291 |             BinaryOp::Mod => "%",
    |             ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  9 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/gpu/mod.rs:292:13
    |
292 |             BinaryOp::Eq => "==",
    |             ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  9 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/gpu/mod.rs:293:13
    |
293 |             BinaryOp::Ne => "!=",
    |             ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  9 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/gpu/mod.rs:294:13
    |
294 |             BinaryOp::Lt => "<",
    |             ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  9 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/gpu/mod.rs:295:13
    |
295 |             BinaryOp::Le => "<=",
    |             ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  9 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/gpu/mod.rs:296:13
    |
296 |             BinaryOp::Gt => ">",
    |             ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  9 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/gpu/mod.rs:297:13
    |
297 |             BinaryOp::Ge => ">=",
    |             ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  9 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
  --> compiler/src/consteval/mod.rs:68:25
   |
68 |                         Span::dummy()
   |                         ^^^^ use of undeclared type `Span`
   |
help: consider importing this struct through its public re-export
   |
 4 + use crate::prelude::Span;
   |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/consteval/mod.rs:108:17
    |
108 |                 Span::dummy()
    |                 ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0412]: cannot find type `BinaryOp` in this scope
   --> compiler/src/consteval/mod.rs:123:34
    |
123 |     fn eval_binary_op(&self, op: BinaryOp, left: &ConstValue, right: &ConstValue) -> Result<ConstValue> {
    |                                  ^^^^^^^^ not found in this scope
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:127:21
    |
127 |                     BinaryOp::Add => ConstValue::Int(l + r),
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:128:21
    |
128 |                     BinaryOp::Sub => ConstValue::Int(l - r),
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:129:21
    |
129 |                     BinaryOp::Mul => ConstValue::Int(l * r),
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:130:21
    |
130 |                     BinaryOp::Div => {
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/consteval/mod.rs:132:71
    |
132 | ...                   return Err(Error::new("Division by zero", Span::dummy()));
    |                                                                 ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:136:21
    |
136 |                     BinaryOp::Mod => ConstValue::Int(l % r),
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:137:21
    |
137 |                     BinaryOp::Eq => ConstValue::Bool(l == r),
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:138:21
    |
138 |                     BinaryOp::Ne => ConstValue::Bool(l != r),
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:139:21
    |
139 |                     BinaryOp::Lt => ConstValue::Bool(l < r),
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:140:21
    |
140 |                     BinaryOp::Le => ConstValue::Bool(l <= r),
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:141:21
    |
141 |                     BinaryOp::Gt => ConstValue::Bool(l > r),
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:142:21
    |
142 |                     BinaryOp::Ge => ConstValue::Bool(l >= r),
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:143:21
    |
143 |                     BinaryOp::BitAnd => ConstValue::Int(l & r),
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:144:21
    |
144 |                     BinaryOp::BitOr => ConstValue::Int(l | r),
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:145:21
    |
145 |                     BinaryOp::BitXor => ConstValue::Int(l ^ r),
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:146:21
    |
146 |                     BinaryOp::Shl => ConstValue::Int(l << r),
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:147:21
    |
147 |                     BinaryOp::Shr => ConstValue::Int(l >> r),
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/consteval/mod.rs:148:80
    |
148 |                     _ => return Err(Error::new("Unsupported binary operation", Span::dummy())),
    |                                                                                ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:155:21
    |
155 |                     BinaryOp::Add => ConstValue::Float(l + r),
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:156:21
    |
156 |                     BinaryOp::Sub => ConstValue::Float(l - r),
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:157:21
    |
157 |                     BinaryOp::Mul => ConstValue::Float(l * r),
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:158:21
    |
158 |                     BinaryOp::Div => ConstValue::Float(l / r),
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:159:21
    |
159 |                     BinaryOp::Eq => ConstValue::Bool(l == r),
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:160:21
    |
160 |                     BinaryOp::Ne => ConstValue::Bool(l != r),
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:161:21
    |
161 |                     BinaryOp::Lt => ConstValue::Bool(l < r),
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:162:21
    |
162 |                     BinaryOp::Le => ConstValue::Bool(l <= r),
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:163:21
    |
163 |                     BinaryOp::Gt => ConstValue::Bool(l > r),
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:164:21
    |
164 |                     BinaryOp::Ge => ConstValue::Bool(l >= r),
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/consteval/mod.rs:165:80
    |
165 |                     _ => return Err(Error::new("Unsupported binary operation", Span::dummy())),
    |                                                                                ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:172:21
    |
172 |                     BinaryOp::And => ConstValue::Bool(*l && *r),
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:173:21
    |
173 |                     BinaryOp::Or => ConstValue::Bool(*l || *r),
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:174:21
    |
174 |                     BinaryOp::Eq => ConstValue::Bool(l == r),
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:175:21
    |
175 |                     BinaryOp::Ne => ConstValue::Bool(l != r),
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/consteval/mod.rs:176:80
    |
176 |                     _ => return Err(Error::new("Unsupported binary operation", Span::dummy())),
    |                                                                                ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/consteval/mod.rs:181:70
    |
181 |             _ => Err(Error::new("Type mismatch in binary operation", Span::dummy())),
    |                                                                      ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0412]: cannot find type `UnaryOp` in this scope
   --> compiler/src/consteval/mod.rs:185:33
    |
185 |     fn eval_unary_op(&self, op: UnaryOp, val: &ConstValue) -> Result<ConstValue> {
    |                                 ^^^^^^^ not found in this scope
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::UnaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `UnaryOp`
   --> compiler/src/consteval/mod.rs:189:21
    |
189 |                     UnaryOp::Neg => ConstValue::Int(-n),
    |                     ^^^^^^^ use of undeclared type `UnaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::UnaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `UnaryOp`
   --> compiler/src/consteval/mod.rs:190:21
    |
190 |                     UnaryOp::Not => ConstValue::Bool(*n == 0),
    |                     ^^^^^^^ use of undeclared type `UnaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::UnaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `UnaryOp`
   --> compiler/src/consteval/mod.rs:191:21
    |
191 |                     UnaryOp::BitNot => ConstValue::Int(!n),
    |                     ^^^^^^^ use of undeclared type `UnaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::UnaryOp;
    |

   Compiling indexmap v2.13.0
error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/consteval/mod.rs:192:79
    |
192 |                     _ => return Err(Error::new("Unsupported unary operation", Span::dummy())),
    |                                                                               ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0433]: failed to resolve: use of undeclared type `UnaryOp`
   --> compiler/src/consteval/mod.rs:199:21
    |
199 |                     UnaryOp::Neg => ConstValue::Float(-f),
    |                     ^^^^^^^ use of undeclared type `UnaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::UnaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/consteval/mod.rs:200:79
    |
200 |                     _ => return Err(Error::new("Unsupported unary operation", Span::dummy())),
    |                                                                               ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0433]: failed to resolve: use of undeclared type `UnaryOp`
   --> compiler/src/consteval/mod.rs:207:21
    |
207 |                     UnaryOp::Not => ConstValue::Bool(!b),
    |                     ^^^^^^^ use of undeclared type `UnaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::UnaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/consteval/mod.rs:208:79
    |
208 |                     _ => return Err(Error::new("Unsupported unary operation", Span::dummy())),
    |                                                                               ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/consteval/mod.rs:213:69
    |
213 |             _ => Err(Error::new("Type mismatch in unary operation", Span::dummy())),
    |                                                                     ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/consteval/mod.rs:221:65
    |
221 |             _ => return Err(Error::new("Invalid function call", Span::dummy())),
    |                                                                 ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/consteval/mod.rs:239:17
    |
239 |                 Span::dummy()
    |                 ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/consteval/mod.rs:246:61
    |
246 |             return Err(Error::new("abs expects 1 argument", Span::dummy()));
    |                                                             ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/consteval/mod.rs:252:65
    |
252 |             _ => Err(Error::new("abs expects numeric argument", Span::dummy())),
    |                                                                 ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/consteval/mod.rs:258:62
    |
258 |             return Err(Error::new("min expects 2 arguments", Span::dummy()));
    |                                                              ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/consteval/mod.rs:264:66
    |
264 |             _ => Err(Error::new("min expects numeric arguments", Span::dummy())),
    |                                                                  ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/consteval/mod.rs:270:62
    |
270 |             return Err(Error::new("max expects 2 arguments", Span::dummy()));
    |                                                              ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/consteval/mod.rs:276:66
    |
276 |             _ => Err(Error::new("max expects numeric arguments", Span::dummy())),
    |                                                                  ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/consteval/mod.rs:282:62
    |
282 |             return Err(Error::new("pow expects 2 arguments", Span::dummy()));
    |                                                              ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/consteval/mod.rs:291:80
    |
291 |                     return Err(Error::new("Negative exponent for integer pow", Span::dummy()));
    |                                                                                ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/consteval/mod.rs:295:66
    |
295 |             _ => Err(Error::new("pow expects numeric arguments", Span::dummy())),
    |                                                                  ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/consteval/mod.rs:301:62
    |
301 |             return Err(Error::new("sqrt expects 1 argument", Span::dummy()));
    |                                                              ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/consteval/mod.rs:307:70
    |
307 |                     return Err(Error::new("sqrt of negative number", Span::dummy()));
    |                                                                      ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/consteval/mod.rs:311:64
    |
311 |             _ => Err(Error::new("sqrt expects float argument", Span::dummy())),
    |                                                                ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0412]: cannot find type `BinaryOp` in this scope
  --> compiler/src/plugin/api.rs:60:40
   |
60 |     pub fn create_binary_op(&self, op: BinaryOp, left: Expr, right: Expr) -> Expr {
   |                                        ^^^^^^^^ not found in this scope
   |
help: consider importing this enum
   |
 4 + use crate::ir::instructions::BinaryOp;
   |

error[E0412]: cannot find type `Span` in this scope
   --> compiler/src/plugin/mod.rs:151:19
    |
151 |     pub location: Span,
    |                   ^^^^ not found in this scope
    |
help: consider importing this struct through its public re-export
    |
  9 + use crate::prelude::Span;
    |

error[E0659]: `Function` is ambiguous
  --> compiler/src/gpu/mod.rs:78:42
   |
78 |     pub fn generate_kernel(&self, func: &Function) -> Result<String> {
   |                                          ^^^^^^^^ ambiguous name
   |
   = note: ambiguous because of multiple glob imports of a name in the same module
note: `Function` could refer to the struct imported here
  --> compiler/src/gpu/mod.rs:9:5
   |
 9 | use crate::parser::ast::*;
   |     ^^^^^^^^^^^^^^^^^^^^^
   = help: consider adding an explicit import of `Function` to disambiguate
note: `Function` could also refer to the struct imported here
  --> compiler/src/gpu/mod.rs:10:5
   |
10 | use crate::ir::ssa::*;
   |     ^^^^^^^^^^^^^^^^^
   = help: consider adding an explicit import of `Function` to disambiguate

error[E0659]: `Function` is ambiguous
  --> compiler/src/gpu/mod.rs:87:43
   |
87 |     fn generate_cuda_kernel(&self, func: &Function) -> Result<String> {
   |                                           ^^^^^^^^ ambiguous name
   |
   = note: ambiguous because of multiple glob imports of a name in the same module
note: `Function` could refer to the struct imported here
  --> compiler/src/gpu/mod.rs:9:5
   |
 9 | use crate::parser::ast::*;
   |     ^^^^^^^^^^^^^^^^^^^^^
   = help: consider adding an explicit import of `Function` to disambiguate
note: `Function` could also refer to the struct imported here
  --> compiler/src/gpu/mod.rs:10:5
   |
10 | use crate::ir::ssa::*;
   |     ^^^^^^^^^^^^^^^^^
   = help: consider adding an explicit import of `Function` to disambiguate

error[E0659]: `Function` is ambiguous
   --> compiler/src/gpu/mod.rs:120:44
    |
120 |     fn generate_metal_kernel(&self, func: &Function) -> Result<String> {
    |                                            ^^^^^^^^ ambiguous name
    |
    = note: ambiguous because of multiple glob imports of a name in the same module
note: `Function` could refer to the struct imported here
   --> compiler/src/gpu/mod.rs:9:5
    |
  9 | use crate::parser::ast::*;
    |     ^^^^^^^^^^^^^^^^^^^^^
    = help: consider adding an explicit import of `Function` to disambiguate
note: `Function` could also refer to the struct imported here
   --> compiler/src/gpu/mod.rs:10:5
    |
 10 | use crate::ir::ssa::*;
    |     ^^^^^^^^^^^^^^^^^
    = help: consider adding an explicit import of `Function` to disambiguate

error[E0659]: `Function` is ambiguous
   --> compiler/src/gpu/mod.rs:157:45
    |
157 |     fn generate_vulkan_kernel(&self, func: &Function) -> Result<String> {
    |                                             ^^^^^^^^ ambiguous name
    |
    = note: ambiguous because of multiple glob imports of a name in the same module
note: `Function` could refer to the struct imported here
   --> compiler/src/gpu/mod.rs:9:5
    |
  9 | use crate::parser::ast::*;
    |     ^^^^^^^^^^^^^^^^^^^^^
    = help: consider adding an explicit import of `Function` to disambiguate
note: `Function` could also refer to the struct imported here
   --> compiler/src/gpu/mod.rs:10:5
    |
 10 | use crate::ir::ssa::*;
    |     ^^^^^^^^^^^^^^^^^
    = help: consider adding an explicit import of `Function` to disambiguate

error[E0659]: `Function` is ambiguous
   --> compiler/src/gpu/mod.rs:193:45
    |
193 |     fn generate_opencl_kernel(&self, func: &Function) -> Result<String> {
    |                                             ^^^^^^^^ ambiguous name
    |
    = note: ambiguous because of multiple glob imports of a name in the same module
note: `Function` could refer to the struct imported here
   --> compiler/src/gpu/mod.rs:9:5
    |
  9 | use crate::parser::ast::*;
    |     ^^^^^^^^^^^^^^^^^^^^^
    = help: consider adding an explicit import of `Function` to disambiguate
note: `Function` could also refer to the struct imported here
   --> compiler/src/gpu/mod.rs:10:5
    |
 10 | use crate::ir::ssa::*;
    |     ^^^^^^^^^^^^^^^^^
    = help: consider adding an explicit import of `Function` to disambiguate

error[E0659]: `Function` is ambiguous
   --> compiler/src/gpu/mod.rs:227:43
    |
227 |     fn generate_kernel_body(&self, func: &Function) -> Result<String> {
    |                                           ^^^^^^^^ ambiguous name
    |
    = note: ambiguous because of multiple glob imports of a name in the same module
note: `Function` could refer to the struct imported here
   --> compiler/src/gpu/mod.rs:9:5
    |
  9 | use crate::parser::ast::*;
    |     ^^^^^^^^^^^^^^^^^^^^^
    = help: consider adding an explicit import of `Function` to disambiguate
note: `Function` could also refer to the struct imported here
   --> compiler/src/gpu/mod.rs:10:5
    |
 10 | use crate::ir::ssa::*;
    |     ^^^^^^^^^^^^^^^^^
    = help: consider adding an explicit import of `Function` to disambiguate

warning: unused import: `TypeVar`
 --> compiler/src/semantic/type_checker.rs:6:69
  |
6 | use super::type_env::{TypeEnv, InferredType, Substitution, Unifier, TypeVar};
  |                                                                     ^^^^^^^
  |
  = note: `#[warn(unused_imports)]` (part of `#[warn(unused)]`) on by default

warning: unused import: `BasicBlock`
 --> compiler/src/ir/builder.rs:5:42
  |
5 | use super::ssa::{Function as IrFunction, BasicBlock, Value, ValueId, Constant, Module};
  |                                          ^^^^^^^^^^

warning: unused import: `crate::ir::types::IrType`
 --> compiler/src/optimizer/constant_folding.rs:5:5
  |
5 | use crate::ir::types::IrType;
  |     ^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `ValueId`
 --> compiler/src/optimizer/inline.rs:3:54
  |
3 | use crate::ir::ssa::{Module, Function as IrFunction, ValueId};
  |                                                      ^^^^^^^

warning: unused import: `Path`
 --> compiler/src/codegen/linker.rs:5:17
  |
5 | use std::path::{Path, PathBuf};
  |                 ^^^^

warning: unused import: `crate::parser::ast::*`
 --> compiler/src/macro_system/mod.rs:9:5
  |
9 | use crate::parser::ast::*;
  |     ^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `std::prelude::*`
 --> compiler/src/async_runtime/mod.rs:9:5
  |
9 | use std::prelude::*;
  |     ^^^^^^^^^^^^^^^

warning: unused import: `Error`
  --> compiler/src/verification/mod.rs:11:20
   |
11 | use crate::error::{Error, Result};
   |                    ^^^^^

warning: unused import: `std::collections::HashMap`
  --> compiler/src/verification/mod.rs:12:5
   |
12 | use std::collections::HashMap;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `crate::ir::ssa::*`
  --> compiler/src/gpu/mod.rs:10:5
   |
10 | use crate::ir::ssa::*;
   |     ^^^^^^^^^^^^^^^^^

warning: unused import: `Error`
  --> compiler/src/gpu/mod.rs:11:20
   |
11 | use crate::error::{Error, Result};
   |                    ^^^^^

error[E0277]: `F1` is not a future
   --> compiler/src/async_runtime/mod.rs:113:17
    |
113 |     let r1 = f1.await;
    |                 ^^^^^ `F1` is not a future
    |
    = note: F1 must be a future or must implement `IntoFuture` to be awaited
    = note: required for `F1` to implement `IntoFuture`
help: remove the `.await`
    |
113 -     let r1 = f1.await;
113 +     let r1 = f1;
    |
help: consider further restricting type parameter `F1` with trait `Future`
    |
110 |     F1: Future + std::future::Future,
    |                +++++++++++++++++++++

error[E0277]: `F2` is not a future
   --> compiler/src/async_runtime/mod.rs:114:17
    |
114 |     let r2 = f2.await;
    |                 ^^^^^ `F2` is not a future
    |
    = note: F2 must be a future or must implement `IntoFuture` to be awaited
    = note: required for `F2` to implement `IntoFuture`
help: remove the `.await`
    |
114 -     let r2 = f2.await;
114 +     let r2 = f2;
    |
help: consider further restricting type parameter `F2` with trait `Future`
    |
111 |     F2: Future + std::future::Future,
    |                +++++++++++++++++++++

error[E0023]: this pattern has 1 field, but the corresponding tuple variant has 2 fields
  --> compiler/src/lexer/token.rs:66:35
   |
26 |     IntLiteral(String, Option<String>),   // value, optional suffix (i32, u64, etc.)
   |                ------  -------------- tuple variant has 2 fields
...
66 |             TokenKind::IntLiteral(_) | TokenKind::FloatLiteral(_) |
   |                                   ^ expected 2 fields, found 1
   |
help: use `_` to explicitly ignore each field
   |
66 |             TokenKind::IntLiteral(_, _) | TokenKind::FloatLiteral(_) |
   |                                    +++
help: use `..` to ignore all fields
   |
66 -             TokenKind::IntLiteral(_) | TokenKind::FloatLiteral(_) |
66 +             TokenKind::IntLiteral(..) | TokenKind::FloatLiteral(_) |
   |

error[E0023]: this pattern has 1 field, but the corresponding tuple variant has 2 fields
  --> compiler/src/lexer/token.rs:66:64
   |
27 |     FloatLiteral(String, Option<String>), // value, optional suffix (f32, f64)
   |                  ------  -------------- tuple variant has 2 fields
...
66 |             TokenKind::IntLiteral(_) | TokenKind::FloatLiteral(_) |
   |                                                                ^ expected 2 fields, found 1
   |
help: use `_` to explicitly ignore each field
   |
66 |             TokenKind::IntLiteral(_) | TokenKind::FloatLiteral(_, _) |
   |                                                                 +++
help: use `..` to ignore all fields
   |
66 -             TokenKind::IntLiteral(_) | TokenKind::FloatLiteral(_) |
66 +             TokenKind::IntLiteral(_) | TokenKind::FloatLiteral(..) |
   |

error[E0308]: mismatched types
   --> compiler/src/lexer/mod.rs:689:13
    |
682 |     fn lex_slash(&mut self) -> Result<TokenKind> {
    |                                ----------------- expected `std::result::Result<TokenKind, error::Error>` because of return type
...
689 |             self.next_token() // Skip comment and get next token
    |             ^^^^^^^^^^^^^^^^^ expected `Result<TokenKind, Error>`, found `Result<Token, Error>`
    |
    = note: expected enum `std::result::Result<TokenKind, _>`
               found enum `std::result::Result<Token, _>`

error[E0308]: mismatched types
   --> compiler/src/lexer/mod.rs:698:32
    |
682 |     fn lex_slash(&mut self) -> Result<TokenKind> {
    |                                ----------------- expected `std::result::Result<TokenKind, error::Error>` because of return type
...
698 |                         return self.next_token(); // Skip comment
    |                                ^^^^^^^^^^^^^^^^^ expected `Result<TokenKind, Error>`, found `Result<Token, Error>`
    |
    = note: expected enum `std::result::Result<TokenKind, _>`
               found enum `std::result::Result<Token, _>`

error[E0599]: no function or associated item named `default` found for struct `span::Span` in the current scope
  --> compiler/src/semantic/resolver.rs:66:19
   |
66 |             Span::default(),
   |                   ^^^^^^^ function or associated item not found in `span::Span`
   |
  ::: compiler/src/span.rs:31:1
   |
31 | pub struct Span {
   | --------------- function or associated item `default` not found for this struct
   |
note: if you're trying to build a new `span::Span`, consider using `span::Span::new` which returns `span::Span`
  --> compiler/src/span.rs:37:5
   |
37 |     pub fn new(start: Position, end: Position) -> Self {
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   = help: items from traits can only be used if the trait is implemented and in scope
   = note: the following trait defines an item `default`, perhaps you need to implement it:
           candidate #1: `Default`

error[E0599]: no variant or associated item named `DuplicateSymbol` found for enum `error::ErrorKind` in the current scope
  --> compiler/src/semantic/resolver.rs:71:50
   |
71 |             self.add_error(Error::new(ErrorKind::DuplicateSymbol, e));
   |                                                  ^^^^^^^^^^^^^^^ variant or associated item not found in `error::ErrorKind`
   |
  ::: compiler/src/error.rs:18:1
   |
18 | pub enum ErrorKind {
   | ------------------ variant or associated item `DuplicateSymbol` not found for this enum

error[E0599]: no function or associated item named `default` found for struct `span::Span` in the current scope
  --> compiler/src/semantic/resolver.rs:84:23
   |
84 |                 Span::default(),
   |                       ^^^^^^^ function or associated item not found in `span::Span`
   |
  ::: compiler/src/span.rs:31:1
   |
31 | pub struct Span {
   | --------------- function or associated item `default` not found for this struct
   |
note: if you're trying to build a new `span::Span`, consider using `span::Span::new` which returns `span::Span`
  --> compiler/src/span.rs:37:5
   |
37 |     pub fn new(start: Position, end: Position) -> Self {
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   = help: items from traits can only be used if the trait is implemented and in scope
   = note: the following trait defines an item `default`, perhaps you need to implement it:
           candidate #1: `Default`

error[E0599]: no variant or associated item named `DuplicateSymbol` found for enum `error::ErrorKind` in the current scope
  --> compiler/src/semantic/resolver.rs:89:54
   |
89 |                 self.add_error(Error::new(ErrorKind::DuplicateSymbol, e));
   |                                                      ^^^^^^^^^^^^^^^ variant or associated item not found in `error::ErrorKind`
   |
  ::: compiler/src/error.rs:18:1
   |
18 | pub enum ErrorKind {
   | ------------------ variant or associated item `DuplicateSymbol` not found for this enum

error[E0599]: no function or associated item named `default` found for struct `span::Span` in the current scope
  --> compiler/src/semantic/resolver.rs:99:23
   |
99 |                 Span::default(),
   |                       ^^^^^^^ function or associated item not found in `span::Span`
   |
  ::: compiler/src/span.rs:31:1
   |
31 | pub struct Span {
   | --------------- function or associated item `default` not found for this struct
   |
note: if you're trying to build a new `span::Span`, consider using `span::Span::new` which returns `span::Span`
  --> compiler/src/span.rs:37:5
   |
37 |     pub fn new(start: Position, end: Position) -> Self {
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   = help: items from traits can only be used if the trait is implemented and in scope
   = note: the following trait defines an item `default`, perhaps you need to implement it:
           candidate #1: `Default`

error[E0599]: no variant or associated item named `DuplicateSymbol` found for enum `error::ErrorKind` in the current scope
   --> compiler/src/semantic/resolver.rs:104:54
    |
104 |                 self.add_error(Error::new(ErrorKind::DuplicateSymbol, e));
    |                                                      ^^^^^^^^^^^^^^^ variant or associated item not found in `error::ErrorKind`
    |
   ::: compiler/src/error.rs:18:1
    |
 18 | pub enum ErrorKind {
    | ------------------ variant or associated item `DuplicateSymbol` not found for this enum

error[E0599]: no function or associated item named `default` found for struct `span::Span` in the current scope
   --> compiler/src/semantic/resolver.rs:122:19
    |
122 |             Span::default(),
    |                   ^^^^^^^ function or associated item not found in `span::Span`
    |
   ::: compiler/src/span.rs:31:1
    |
 31 | pub struct Span {
    | --------------- function or associated item `default` not found for this struct
    |
note: if you're trying to build a new `span::Span`, consider using `span::Span::new` which returns `span::Span`
   --> compiler/src/span.rs:37:5
    |
 37 |     pub fn new(start: Position, end: Position) -> Self {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    = help: items from traits can only be used if the trait is implemented and in scope
    = note: the following trait defines an item `default`, perhaps you need to implement it:
            candidate #1: `Default`

error[E0599]: no variant or associated item named `DuplicateSymbol` found for enum `error::ErrorKind` in the current scope
   --> compiler/src/semantic/resolver.rs:127:50
    |
127 |             self.add_error(Error::new(ErrorKind::DuplicateSymbol, e));
    |                                                  ^^^^^^^^^^^^^^^ variant or associated item not found in `error::ErrorKind`
    |
   ::: compiler/src/error.rs:18:1
    |
 18 | pub enum ErrorKind {
    | ------------------ variant or associated item `DuplicateSymbol` not found for this enum

error[E0599]: no function or associated item named `default` found for struct `span::Span` in the current scope
   --> compiler/src/semantic/resolver.rs:136:19
    |
136 |             Span::default(),
    |                   ^^^^^^^ function or associated item not found in `span::Span`
    |
   ::: compiler/src/span.rs:31:1
    |
 31 | pub struct Span {
    | --------------- function or associated item `default` not found for this struct
    |
note: if you're trying to build a new `span::Span`, consider using `span::Span::new` which returns `span::Span`
   --> compiler/src/span.rs:37:5
    |
 37 |     pub fn new(start: Position, end: Position) -> Self {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    = help: items from traits can only be used if the trait is implemented and in scope
    = note: the following trait defines an item `default`, perhaps you need to implement it:
            candidate #1: `Default`

error[E0599]: no variant or associated item named `DuplicateSymbol` found for enum `error::ErrorKind` in the current scope
   --> compiler/src/semantic/resolver.rs:141:50
    |
141 |             self.add_error(Error::new(ErrorKind::DuplicateSymbol, e));
    |                                                  ^^^^^^^^^^^^^^^ variant or associated item not found in `error::ErrorKind`
    |
   ::: compiler/src/error.rs:18:1
    |
 18 | pub enum ErrorKind {
    | ------------------ variant or associated item `DuplicateSymbol` not found for this enum

error[E0599]: no function or associated item named `default` found for struct `span::Span` in the current scope
   --> compiler/src/semantic/resolver.rs:151:23
    |
151 |                 Span::default(),
    |                       ^^^^^^^ function or associated item not found in `span::Span`
    |
   ::: compiler/src/span.rs:31:1
    |
 31 | pub struct Span {
    | --------------- function or associated item `default` not found for this struct
    |
note: if you're trying to build a new `span::Span`, consider using `span::Span::new` which returns `span::Span`
   --> compiler/src/span.rs:37:5
    |
 37 |     pub fn new(start: Position, end: Position) -> Self {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    = help: items from traits can only be used if the trait is implemented and in scope
    = note: the following trait defines an item `default`, perhaps you need to implement it:
            candidate #1: `Default`

error[E0599]: no variant or associated item named `DuplicateSymbol` found for enum `error::ErrorKind` in the current scope
   --> compiler/src/semantic/resolver.rs:156:54
    |
156 |                 self.add_error(Error::new(ErrorKind::DuplicateSymbol, e));
    |                                                      ^^^^^^^^^^^^^^^ variant or associated item not found in `error::ErrorKind`
    |
   ::: compiler/src/error.rs:18:1
    |
 18 | pub enum ErrorKind {
    | ------------------ variant or associated item `DuplicateSymbol` not found for this enum

error[E0599]: no function or associated item named `default` found for struct `span::Span` in the current scope
   --> compiler/src/semantic/resolver.rs:166:19
    |
166 |             Span::default(),
    |                   ^^^^^^^ function or associated item not found in `span::Span`
    |
   ::: compiler/src/span.rs:31:1
    |
 31 | pub struct Span {
    | --------------- function or associated item `default` not found for this struct
    |
note: if you're trying to build a new `span::Span`, consider using `span::Span::new` which returns `span::Span`
   --> compiler/src/span.rs:37:5
    |
 37 |     pub fn new(start: Position, end: Position) -> Self {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    = help: items from traits can only be used if the trait is implemented and in scope
    = note: the following trait defines an item `default`, perhaps you need to implement it:
            candidate #1: `Default`

error[E0599]: no variant or associated item named `DuplicateSymbol` found for enum `error::ErrorKind` in the current scope
   --> compiler/src/semantic/resolver.rs:171:50
    |
171 |             self.add_error(Error::new(ErrorKind::DuplicateSymbol, e));
    |                                                  ^^^^^^^^^^^^^^^ variant or associated item not found in `error::ErrorKind`
    |
   ::: compiler/src/error.rs:18:1
    |
 18 | pub enum ErrorKind {
    | ------------------ variant or associated item `DuplicateSymbol` not found for this enum

error[E0599]: no function or associated item named `default` found for struct `span::Span` in the current scope
   --> compiler/src/semantic/resolver.rs:185:23
    |
185 |                 Span::default(),
    |                       ^^^^^^^ function or associated item not found in `span::Span`
    |
   ::: compiler/src/span.rs:31:1
    |
 31 | pub struct Span {
    | --------------- function or associated item `default` not found for this struct
    |
note: if you're trying to build a new `span::Span`, consider using `span::Span::new` which returns `span::Span`
   --> compiler/src/span.rs:37:5
    |
 37 |     pub fn new(start: Position, end: Position) -> Self {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    = help: items from traits can only be used if the trait is implemented and in scope
    = note: the following trait defines an item `default`, perhaps you need to implement it:
            candidate #1: `Default`

error[E0599]: no variant or associated item named `DuplicateSymbol` found for enum `error::ErrorKind` in the current scope
   --> compiler/src/semantic/resolver.rs:190:54
    |
190 |                 self.add_error(Error::new(ErrorKind::DuplicateSymbol, e));
    |                                                      ^^^^^^^^^^^^^^^ variant or associated item not found in `error::ErrorKind`
    |
   ::: compiler/src/error.rs:18:1
    |
 18 | pub enum ErrorKind {
    | ------------------ variant or associated item `DuplicateSymbol` not found for this enum

error[E0599]: no function or associated item named `default` found for struct `span::Span` in the current scope
   --> compiler/src/semantic/resolver.rs:217:19
    |
217 |             Span::default(),
    |                   ^^^^^^^ function or associated item not found in `span::Span`
    |
   ::: compiler/src/span.rs:31:1
    |
 31 | pub struct Span {
    | --------------- function or associated item `default` not found for this struct
    |
note: if you're trying to build a new `span::Span`, consider using `span::Span::new` which returns `span::Span`
   --> compiler/src/span.rs:37:5
    |
 37 |     pub fn new(start: Position, end: Position) -> Self {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    = help: items from traits can only be used if the trait is implemented and in scope
    = note: the following trait defines an item `default`, perhaps you need to implement it:
            candidate #1: `Default`

error[E0599]: no variant or associated item named `DuplicateSymbol` found for enum `error::ErrorKind` in the current scope
   --> compiler/src/semantic/resolver.rs:222:50
    |
222 |             self.add_error(Error::new(ErrorKind::DuplicateSymbol, e));
    |                                                  ^^^^^^^^^^^^^^^ variant or associated item not found in `error::ErrorKind`
    |
   ::: compiler/src/error.rs:18:1
    |
 18 | pub enum ErrorKind {
    | ------------------ variant or associated item `DuplicateSymbol` not found for this enum

error[E0599]: no function or associated item named `default` found for struct `span::Span` in the current scope
   --> compiler/src/semantic/resolver.rs:250:27
    |
250 |                     Span::default(),
    |                           ^^^^^^^ function or associated item not found in `span::Span`
    |
   ::: compiler/src/span.rs:31:1
    |
 31 | pub struct Span {
    | --------------- function or associated item `default` not found for this struct
    |
note: if you're trying to build a new `span::Span`, consider using `span::Span::new` which returns `span::Span`
   --> compiler/src/span.rs:37:5
    |
 37 |     pub fn new(start: Position, end: Position) -> Self {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    = help: items from traits can only be used if the trait is implemented and in scope
    = note: the following trait defines an item `default`, perhaps you need to implement it:
            candidate #1: `Default`

error[E0599]: no variant or associated item named `DuplicateSymbol` found for enum `error::ErrorKind` in the current scope
   --> compiler/src/semantic/resolver.rs:259:58
    |
259 |                     self.add_error(Error::new(ErrorKind::DuplicateSymbol, e));
    |                                                          ^^^^^^^^^^^^^^^ variant or associated item not found in `error::ErrorKind`
    |
   ::: compiler/src/error.rs:18:1
    |
 18 | pub enum ErrorKind {
    | ------------------ variant or associated item `DuplicateSymbol` not found for this enum

error[E0599]: no function or associated item named `default` found for struct `span::Span` in the current scope
   --> compiler/src/semantic/resolver.rs:357:27
    |
357 |                     Span::default(),
    |                           ^^^^^^^ function or associated item not found in `span::Span`
    |
   ::: compiler/src/span.rs:31:1
    |
 31 | pub struct Span {
    | --------------- function or associated item `default` not found for this struct
    |
note: if you're trying to build a new `span::Span`, consider using `span::Span::new` which returns `span::Span`
   --> compiler/src/span.rs:37:5
    |
 37 |     pub fn new(start: Position, end: Position) -> Self {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    = help: items from traits can only be used if the trait is implemented and in scope
    = note: the following trait defines an item `default`, perhaps you need to implement it:
            candidate #1: `Default`

error[E0599]: no variant or associated item named `DuplicateSymbol` found for enum `error::ErrorKind` in the current scope
   --> compiler/src/semantic/resolver.rs:362:58
    |
362 |                     self.add_error(Error::new(ErrorKind::DuplicateSymbol, e));
    |                                                          ^^^^^^^^^^^^^^^ variant or associated item not found in `error::ErrorKind`
    |
   ::: compiler/src/error.rs:18:1
    |
 18 | pub enum ErrorKind {
    | ------------------ variant or associated item `DuplicateSymbol` not found for this enum

error[E0599]: no function or associated item named `default` found for struct `span::Span` in the current scope
   --> compiler/src/semantic/resolver.rs:407:27
    |
407 |                     Span::default(),
    |                           ^^^^^^^ function or associated item not found in `span::Span`
    |
   ::: compiler/src/span.rs:31:1
    |
 31 | pub struct Span {
    | --------------- function or associated item `default` not found for this struct
    |
note: if you're trying to build a new `span::Span`, consider using `span::Span::new` which returns `span::Span`
   --> compiler/src/span.rs:37:5
    |
 37 |     pub fn new(start: Position, end: Position) -> Self {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    = help: items from traits can only be used if the trait is implemented and in scope
    = note: the following trait defines an item `default`, perhaps you need to implement it:
            candidate #1: `Default`

error[E0599]: no variant or associated item named `DuplicateSymbol` found for enum `error::ErrorKind` in the current scope
   --> compiler/src/semantic/resolver.rs:412:58
    |
412 |                     self.add_error(Error::new(ErrorKind::DuplicateSymbol, e));
    |                                                          ^^^^^^^^^^^^^^^ variant or associated item not found in `error::ErrorKind`
    |
   ::: compiler/src/error.rs:18:1
    |
 18 | pub enum ErrorKind {
    | ------------------ variant or associated item `DuplicateSymbol` not found for this enum

error[E0599]: no variant or associated item named `TypeError` found for enum `error::ErrorKind` in the current scope
   --> compiler/src/semantic/type_env.rs:239:36
    |
239 |                         ErrorKind::TypeError,
    |                                    ^^^^^^^^^ variant or associated item not found in `error::ErrorKind`
    |
   ::: compiler/src/error.rs:18:1
    |
 18 | pub enum ErrorKind {
    | ------------------ variant or associated item `TypeError` not found for this enum
    |
help: there is a variant with a similar name
    |
239 -                         ErrorKind::TypeError,
240 -                         "Occurs check failed: infinite type"
241 -                     ))
239 +                         ErrorKind::MoveError)
    |

error[E0599]: no variant or associated item named `TypeError` found for enum `error::ErrorKind` in the current scope
   --> compiler/src/semantic/type_env.rs:253:36
    |
253 |                         ErrorKind::TypeError,
    |                                    ^^^^^^^^^ variant or associated item not found in `error::ErrorKind`
    |
   ::: compiler/src/error.rs:18:1
    |
 18 | pub enum ErrorKind {
    | ------------------ variant or associated item `TypeError` not found for this enum
    |
help: there is a variant with a similar name
    |
253 -                         ErrorKind::TypeError,
254 -                         format!("Function arity mismatch: {} vs {}", params1.len(), params2.len())
255 -                     ));
253 +                         ErrorKind::MoveError);
    |

error[E0599]: no variant or associated item named `TypeError` found for enum `error::ErrorKind` in the current scope
   --> compiler/src/semantic/type_env.rs:275:36
    |
275 |                         ErrorKind::TypeError,
    |                                    ^^^^^^^^^ variant or associated item not found in `error::ErrorKind`
    |
   ::: compiler/src/error.rs:18:1
    |
 18 | pub enum ErrorKind {
    | ------------------ variant or associated item `TypeError` not found for this enum
    |
help: there is a variant with a similar name
    |
275 -                         ErrorKind::TypeError,
276 -                         format!("Type mismatch: {} vs {}", name1, name2)
277 -                     ));
275 +                         ErrorKind::MoveError);
    |

error[E0599]: no variant or associated item named `TypeError` found for enum `error::ErrorKind` in the current scope
   --> compiler/src/semantic/type_env.rs:282:36
    |
282 |                         ErrorKind::TypeError,
    |                                    ^^^^^^^^^ variant or associated item not found in `error::ErrorKind`
    |
   ::: compiler/src/error.rs:18:1
    |
 18 | pub enum ErrorKind {
    | ------------------ variant or associated item `TypeError` not found for this enum
    |
help: there is a variant with a similar name
    |
282 -                         ErrorKind::TypeError,
283 -                         "Generic argument count mismatch"
284 -                     ));
282 +                         ErrorKind::MoveError);
    |

error[E0599]: no variant or associated item named `TypeError` found for enum `error::ErrorKind` in the current scope
   --> compiler/src/semantic/type_env.rs:300:36
    |
300 |                         ErrorKind::TypeError,
    |                                    ^^^^^^^^^ variant or associated item not found in `error::ErrorKind`
    |
   ::: compiler/src/error.rs:18:1
    |
 18 | pub enum ErrorKind {
    | ------------------ variant or associated item `TypeError` not found for this enum
    |
help: there is a variant with a similar name
    |
300 -                         ErrorKind::TypeError,
301 -                         "Tuple size mismatch"
302 -                     ));
300 +                         ErrorKind::MoveError);
    |

error[E0599]: no variant or associated item named `TypeError` found for enum `error::ErrorKind` in the current scope
   --> compiler/src/semantic/type_env.rs:318:36
    |
318 |                         ErrorKind::TypeError,
    |                                    ^^^^^^^^^ variant or associated item not found in `error::ErrorKind`
    |
   ::: compiler/src/error.rs:18:1
    |
 18 | pub enum ErrorKind {
    | ------------------ variant or associated item `TypeError` not found for this enum
    |
help: there is a variant with a similar name
    |
318 -                         ErrorKind::TypeError,
319 -                         "Array size mismatch"
320 -                     ));
318 +                         ErrorKind::MoveError);
    |

error[E0599]: no variant or associated item named `TypeError` found for enum `error::ErrorKind` in the current scope
   --> compiler/src/semantic/type_env.rs:341:36
    |
341 |                         ErrorKind::TypeError,
    |                                    ^^^^^^^^^ variant or associated item not found in `error::ErrorKind`
    |
   ::: compiler/src/error.rs:18:1
    |
 18 | pub enum ErrorKind {
    | ------------------ variant or associated item `TypeError` not found for this enum
    |
help: there is a variant with a similar name
    |
341 -                         ErrorKind::TypeError,
342 -                         format!("Type mismatch: {} vs {}", n1, n2)
343 -                     ))
341 +                         ErrorKind::MoveError)
    |

error[E0599]: no variant or associated item named `TypeError` found for enum `error::ErrorKind` in the current scope
   --> compiler/src/semantic/type_env.rs:349:28
    |
349 |                 ErrorKind::TypeError,
    |                            ^^^^^^^^^ variant or associated item not found in `error::ErrorKind`
    |
   ::: compiler/src/error.rs:18:1
    |
 18 | pub enum ErrorKind {
    | ------------------ variant or associated item `TypeError` not found for this enum
    |
help: there is a variant with a similar name
    |
349 -                 ErrorKind::TypeError,
350 -                 format!("Cannot unify types: {:?} and {:?}", t1, t2)
351 -             ))
349 +                 ErrorKind::MoveError)
    |

error[E0599]: no variant or associated item named `TypeError` found for enum `error::ErrorKind` in the current scope
   --> compiler/src/semantic/type_checker.rs:144:36
    |
144 |                         ErrorKind::TypeError,
    |                                    ^^^^^^^^^ variant or associated item not found in `error::ErrorKind`
    |
   ::: compiler/src/error.rs:18:1
    |
 18 | pub enum ErrorKind {
    | ------------------ variant or associated item `TypeError` not found for this enum
    |
help: there is a variant with a similar name
    |
144 -                         ErrorKind::TypeError,
145 -                         "Let binding must have type annotation or initializer"
146 -                     ));
144 +                         ErrorKind::MoveError);
    |

warning: unreachable expression
  --> compiler/src/codegen/llvm_backend.rs:46:9
   |
33 |         return "x86_64-unknown-linux-gnu".to_string();
   |         --------------------------------------------- any code following this expression is unreachable
...
46 |         "unknown-unknown-unknown".to_string()
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ unreachable expression
   |
   = note: `#[warn(unreachable_code)]` (part of `#[warn(unused)]`) on by default

error[E0599]: no variant or associated item named `I1` found for enum `IrType` in the current scope
  --> compiler/src/codegen/llvm_backend.rs:60:21
   |
60 |             IrType::I1 => "i1".to_string(),
   |                     ^^ variant or associated item not found in `IrType`
   |
  ::: compiler/src/ir/types.rs:7:1
   |
 7 | pub enum IrType {
   | --------------- variant or associated item `I1` not found for this enum
   |
help: there is a variant with a similar name
   |
60 -             IrType::I1 => "i1".to_string(),
60 +             IrType::I8 => "i1".to_string(),
   |

error[E0599]: no variant or associated item named `Ptr` found for enum `IrType` in the current scope
  --> compiler/src/codegen/llvm_backend.rs:73:21
   |
73 |             IrType::Ptr(inner) => format!("{}*", self.type_to_llvm(inner)),
   |                     ^^^ variant or associated item not found in `IrType`
   |
  ::: compiler/src/ir/types.rs:7:1
   |
 7 | pub enum IrType {
   | --------------- variant or associated item `Ptr` not found for this enum

error[E0026]: variant `Instruction::Branch` does not have fields named `true_bb`, `false_bb`
   --> compiler/src/codegen/llvm_backend.rs:290:41
    |
290 |             Instruction::Branch { cond, true_bb, false_bb } => {
    |                                         ^^^^^^^  ^^^^^^^^ variant `Instruction::Branch` does not have these fields

error[E0027]: pattern does not mention fields `then_block`, `else_block`
   --> compiler/src/codegen/llvm_backend.rs:290:13
    |
290 |             Instruction::Branch { cond, true_bb, false_bb } => {
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ missing fields `then_block`, `else_block`
    |
help: include the missing fields in the pattern
    |
290 |             Instruction::Branch { cond, true_bb, false_bb, then_block, else_block } => {
    |                                                          ++++++++++++++++++++++++
help: if you don't care about these missing fields, you can explicitly ignore them
    |
290 |             Instruction::Branch { cond, true_bb, false_bb, then_block: _, else_block: _ } => {
    |                                                          ++++++++++++++++++++++++++++++
help: or always ignore missing fields here
    |
290 |             Instruction::Branch { cond, true_bb, false_bb, .. } => {
    |                                                          ++++

error[E0609]: no field `0` on type `&usize`
   --> compiler/src/codegen/llvm_backend.rs:295:53
    |
295 |                 Ok(format!("br label %bb{}", target.0))
    |                                                     ^ unknown field

error[E0609]: no field `0` on type `&usize`
   --> compiler/src/codegen/llvm_backend.rs:305:63
    |
305 |                         format!("[ {}, %bb{} ]", val_name, bb.0)
    |                                                               ^ unknown field

error[E0599]: no variant or associated item named `I1` found for enum `IrType` in the current scope
   --> compiler/src/codegen/llvm_backend.rs:337:59
    |
337 |             Value::Constant(Constant::Bool(_)) => IrType::I1,
    |                                                           ^^ variant or associated item not found in `IrType`
    |
   ::: compiler/src/ir/types.rs:7:1
    |
  7 | pub enum IrType {
    | --------------- variant or associated item `I1` not found for this enum
    |
help: there is a variant with a similar name
    |
337 -             Value::Constant(Constant::Bool(_)) => IrType::I1,
337 +             Value::Constant(Constant::Bool(_)) => IrType::I8,
    |

error[E0599]: no variant named `MacroCall` found for enum `ast::Expr`
  --> compiler/src/macro_system/expander.rs:25:19
   |
25 |             Expr::MacroCall { name, args, span } => {
   |                   ^^^^^^^^^ variant not found in `ast::Expr`
   |
  ::: compiler/src/parser/ast.rs:94:1
   |
94 | pub enum Expr {
   | ------------- variant `MacroCall` not found here

error[E0769]: tuple variant `Expr::Binary` written as struct variant
  --> compiler/src/macro_system/expander.rs:28:13
   |
28 |             Expr::Binary { op, left, right, span } => {
   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
help: use the tuple variant pattern syntax instead
   |
28 -             Expr::Binary { op, left, right, span } => {
28 +             Expr::Binary(_, _, _) => {
   |

error[E0769]: tuple variant `Expr::Call` written as struct variant
  --> compiler/src/macro_system/expander.rs:38:13
   |
38 |             Expr::Call { func, args, span } => {
   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
help: use the tuple variant pattern syntax instead
   |
38 -             Expr::Call { func, args, span } => {
38 +             Expr::Call(_, _) => {
   |

error[E0769]: tuple variant `Expr::Block` written as struct variant
  --> compiler/src/macro_system/expander.rs:49:13
   |
49 |             Expr::Block { stmts, span } => {
   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
help: use the tuple variant pattern syntax instead
   |
49 -             Expr::Block { stmts, span } => {
49 +             Expr::Block(_) => {
   |

error[E0559]: variant `ast::Expr::Binary` has no field named `op`
  --> compiler/src/macro_system/expander.rs:32:21
   |
32 |                     op: *op,
   |                     ^^ field does not exist
   |
  ::: compiler/src/parser/ast.rs:97:5
   |
97 |     Binary(Box<Expr>, BinOp, Box<Expr>),
   |     ------ `ast::Expr::Binary` defined here
   |
help: `ast::Expr::Binary` is a tuple variant, use the appropriate syntax
   |
31 -                 Ok(Expr::Binary {
32 -                     op: *op,
33 -                     left,
34 -                     right,
35 -                     span: *span,
36 -                 })
31 +                 Ok(Expr::Binary(/* Box<ast::Expr> */, /* ast::BinOp */, /* Box<ast::Expr> */))
   |

error[E0559]: variant `ast::Expr::Binary` has no field named `left`
  --> compiler/src/macro_system/expander.rs:33:21
   |
33 |                     left,
   |                     ^^^^ field does not exist
   |
  ::: compiler/src/parser/ast.rs:97:5
   |
97 |     Binary(Box<Expr>, BinOp, Box<Expr>),
   |     ------ `ast::Expr::Binary` defined here
   |
help: `ast::Expr::Binary` is a tuple variant, use the appropriate syntax
   |
31 -                 Ok(Expr::Binary {
32 -                     op: *op,
33 -                     left,
34 -                     right,
35 -                     span: *span,
36 -                 })
31 +                 Ok(Expr::Binary(/* Box<ast::Expr> */, /* ast::BinOp */, /* Box<ast::Expr> */))
   |

error[E0559]: variant `ast::Expr::Binary` has no field named `right`
  --> compiler/src/macro_system/expander.rs:34:21
   |
34 |                     right,
   |                     ^^^^^ field does not exist
   |
  ::: compiler/src/parser/ast.rs:97:5
   |
97 |     Binary(Box<Expr>, BinOp, Box<Expr>),
   |     ------ `ast::Expr::Binary` defined here
   |
help: `ast::Expr::Binary` is a tuple variant, use the appropriate syntax
   |
31 -                 Ok(Expr::Binary {
32 -                     op: *op,
33 -                     left,
34 -                     right,
35 -                     span: *span,
36 -                 })
31 +                 Ok(Expr::Binary(/* Box<ast::Expr> */, /* ast::BinOp */, /* Box<ast::Expr> */))
   |

error[E0559]: variant `ast::Expr::Binary` has no field named `span`
  --> compiler/src/macro_system/expander.rs:35:21
   |
35 |                     span: *span,
   |                     ^^^^ field does not exist
   |
  ::: compiler/src/parser/ast.rs:97:5
   |
97 |     Binary(Box<Expr>, BinOp, Box<Expr>),
   |     ------ `ast::Expr::Binary` defined here
   |
help: `ast::Expr::Binary` is a tuple variant, use the appropriate syntax
   |
31 -                 Ok(Expr::Binary {
32 -                     op: *op,
33 -                     left,
34 -                     right,
35 -                     span: *span,
36 -                 })
31 +                 Ok(Expr::Binary(/* Box<ast::Expr> */, /* ast::BinOp */, /* Box<ast::Expr> */))
   |

error[E0559]: variant `ast::Expr::Call` has no field named `func`
  --> compiler/src/macro_system/expander.rs:44:21
   |
44 |                     func,
   |                     ^^^^ field does not exist
   |
  ::: compiler/src/parser/ast.rs:99:5
   |
99 |     Call(Box<Expr>, Vec<Expr>),
   |     ---- `ast::Expr::Call` defined here
   |
help: `ast::Expr::Call` is a tuple variant, use the appropriate syntax
   |
43 -                 Ok(Expr::Call {
44 -                     func,
45 -                     args,
46 -                     span: *span,
47 -                 })
43 +                 Ok(Expr::Call(/* Box<ast::Expr> */, /* Vec<ast::Expr> */))
   |

error[E0559]: variant `ast::Expr::Call` has no field named `args`
  --> compiler/src/macro_system/expander.rs:45:21
   |
45 |                     args,
   |                     ^^^^ field does not exist
   |
  ::: compiler/src/parser/ast.rs:99:5
   |
99 |     Call(Box<Expr>, Vec<Expr>),
   |     ---- `ast::Expr::Call` defined here
   |
help: `ast::Expr::Call` is a tuple variant, use the appropriate syntax
   |
43 -                 Ok(Expr::Call {
44 -                     func,
45 -                     args,
46 -                     span: *span,
47 -                 })
43 +                 Ok(Expr::Call(/* Box<ast::Expr> */, /* Vec<ast::Expr> */))
   |

error[E0559]: variant `ast::Expr::Call` has no field named `span`
  --> compiler/src/macro_system/expander.rs:46:21
   |
46 |                     span: *span,
   |                     ^^^^ field does not exist
   |
  ::: compiler/src/parser/ast.rs:99:5
   |
99 |     Call(Box<Expr>, Vec<Expr>),
   |     ---- `ast::Expr::Call` defined here
   |
help: `ast::Expr::Call` is a tuple variant, use the appropriate syntax
   |
43 -                 Ok(Expr::Call {
44 -                     func,
45 -                     args,
46 -                     span: *span,
47 -                 })
43 +                 Ok(Expr::Call(/* Box<ast::Expr> */, /* Vec<ast::Expr> */))
   |

error[E0559]: variant `ast::Expr::Block` has no field named `stmts`
   --> compiler/src/macro_system/expander.rs:54:21
    |
 54 |                     stmts,
    |                     ^^^^^ field does not exist
    |
   ::: compiler/src/parser/ast.rs:103:5
    |
103 |     Block(Vec<Stmt>),
    |     ----- `ast::Expr::Block` defined here
    |
help: `ast::Expr::Block` is a tuple variant, use the appropriate syntax
    |
 53 -                 Ok(Expr::Block {
 54 -                     stmts,
 55 -                     span: *span,
 56 -                 })
 53 +                 Ok(Expr::Block(/* Vec<ast::Stmt> */))
    |

error[E0559]: variant `ast::Expr::Block` has no field named `span`
   --> compiler/src/macro_system/expander.rs:55:21
    |
 55 |                     span: *span,
    |                     ^^^^ field does not exist
    |
   ::: compiler/src/parser/ast.rs:103:5
    |
103 |     Block(Vec<Stmt>),
    |     ----- `ast::Expr::Block` defined here
    |
help: `ast::Expr::Block` is a tuple variant, use the appropriate syntax
    |
 53 -                 Ok(Expr::Block {
 54 -                     stmts,
 55 -                     span: *span,
 56 -                 })
 53 +                 Ok(Expr::Block(/* Vec<ast::Stmt> */))
    |

error[E0769]: tuple variant `Stmt::Let` written as struct variant
  --> compiler/src/macro_system/expander.rs:67:13
   |
67 |             Stmt::Let { pattern, ty, init, span } => {
   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
help: use the tuple variant pattern syntax instead
   |
67 -             Stmt::Let { pattern, ty, init, span } => {
67 +             Stmt::Let(_, _, _) => {
   |

error[E0559]: variant `ast::Stmt::Let` has no field named `pattern`
  --> compiler/src/macro_system/expander.rs:73:21
   |
73 |                     pattern: pattern.clone(),
   |                     ^^^^^^^ field does not exist
   |
  ::: compiler/src/parser/ast.rs:87:5
   |
87 |     Let(String, Option<Type>, Option<Expr>),
   |     --- `ast::Stmt::Let` defined here
   |
help: `ast::Stmt::Let` is a tuple variant, use the appropriate syntax
   |
72 -                 Ok(Stmt::Let {
73 -                     pattern: pattern.clone(),
74 -                     ty: ty.clone(),
75 -                     init,
76 -                     span: *span,
77 -                 })
72 +                 Ok(Stmt::Let(/* String */, /* Option<ast::Type> */, /* Option<ast::Expr> */))
   |

error[E0559]: variant `ast::Stmt::Let` has no field named `ty`
  --> compiler/src/macro_system/expander.rs:74:21
   |
74 |                     ty: ty.clone(),
   |                     ^^ field does not exist
   |
  ::: compiler/src/parser/ast.rs:87:5
   |
87 |     Let(String, Option<Type>, Option<Expr>),
   |     --- `ast::Stmt::Let` defined here
   |
help: `ast::Stmt::Let` is a tuple variant, use the appropriate syntax
   |
72 -                 Ok(Stmt::Let {
73 -                     pattern: pattern.clone(),
74 -                     ty: ty.clone(),
75 -                     init,
76 -                     span: *span,
77 -                 })
72 +                 Ok(Stmt::Let(/* String */, /* Option<ast::Type> */, /* Option<ast::Expr> */))
   |

error[E0559]: variant `ast::Stmt::Let` has no field named `init`
  --> compiler/src/macro_system/expander.rs:75:21
   |
75 |                     init,
   |                     ^^^^ field does not exist
   |
  ::: compiler/src/parser/ast.rs:87:5
   |
87 |     Let(String, Option<Type>, Option<Expr>),
   |     --- `ast::Stmt::Let` defined here
   |
help: `ast::Stmt::Let` is a tuple variant, use the appropriate syntax
   |
72 -                 Ok(Stmt::Let {
73 -                     pattern: pattern.clone(),
74 -                     ty: ty.clone(),
75 -                     init,
76 -                     span: *span,
77 -                 })
72 +                 Ok(Stmt::Let(/* String */, /* Option<ast::Type> */, /* Option<ast::Expr> */))
   |

error[E0559]: variant `ast::Stmt::Let` has no field named `span`
  --> compiler/src/macro_system/expander.rs:76:21
   |
76 |                     span: *span,
   |                     ^^^^ field does not exist
   |
  ::: compiler/src/parser/ast.rs:87:5
   |
87 |     Let(String, Option<Type>, Option<Expr>),
   |     --- `ast::Stmt::Let` defined here
   |
help: `ast::Stmt::Let` is a tuple variant, use the appropriate syntax
   |
72 -                 Ok(Stmt::Let {
73 -                     pattern: pattern.clone(),
74 -                     ty: ty.clone(),
75 -                     init,
76 -                     span: *span,
77 -                 })
72 +                 Ok(Stmt::Let(/* String */, /* Option<ast::Type> */, /* Option<ast::Expr> */))
   |

error[E0308]: mismatched types
  --> compiler/src/macro_system/expander.rs:86:17
   |
86 |                 format!("macro expansion depth exceeded (max: {})", self.max_depth),
   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `String`
   |
   = note: this error originates in the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0277]: the trait bound `String: From<span::Span>` is not satisfied
  --> compiler/src/macro_system/expander.rs:87:17
   |
85 |             return Err(Error::new(
   |                        ---------- required by a bound introduced by this call
86 |                 format!("macro expansion depth exceeded (max: {})", self.max_depth),
87 |                 span,
   |                 ^^^^ the trait `From<span::Span>` is not implemented for `String`
   |
   = help: the following other types implement trait `From<T>`:
             `String` implements `From<&String>`
             `String` implements `From<&mut str>`
             `String` implements `From<&str>`
             `String` implements `From<Box<str>>`
             `String` implements `From<Cow<'_, str>>`
             `String` implements `From<char>`
             `String` implements `From<clap::Id>`
             `String` implements `From<clap::builder::Str>`
   = note: required for `span::Span` to implement `Into<String>`
note: required by a bound in `error::Error::new`
  --> compiler/src/error.rs:47:47
   |
47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
   |                                               ^^^^^^^^^^^^ required by this bound in `Error::new`

error[E0308]: mismatched types
  --> compiler/src/macro_system/expander.rs:92:39
   |
92 |             .ok_or_else(|| Error::new(format!("undefined macro: {}", name), span))?;
   |                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `String`
   |
   = note: this error originates in the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0277]: the trait bound `String: From<span::Span>` is not satisfied
  --> compiler/src/macro_system/expander.rs:92:77
   |
92 |             .ok_or_else(|| Error::new(format!("undefined macro: {}", name), span))?;
   |                            ----------                                       ^^^^ the trait `From<span::Span>` is not implemented for `String`
   |                            |
   |                            required by a bound introduced by this call
   |
   = help: the following other types implement trait `From<T>`:
             `String` implements `From<&String>`
             `String` implements `From<&mut str>`
             `String` implements `From<&str>`
             `String` implements `From<Box<str>>`
             `String` implements `From<Cow<'_, str>>`
             `String` implements `From<char>`
             `String` implements `From<clap::Id>`
             `String` implements `From<clap::builder::Str>`
   = note: required for `span::Span` to implement `Into<String>`
note: required by a bound in `error::Error::new`
  --> compiler/src/error.rs:47:47
   |
47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
   |                                               ^^^^^^^^^^^^ required by this bound in `Error::new`

error[E0308]: mismatched types
   --> compiler/src/macro_system/expander.rs:110:21
    |
110 |                     format!("no matching macro rule for {}", def.name),
    |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `String`
    |
    = note: this error originates in the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0277]: the trait bound `String: From<span::Span>` is not satisfied
   --> compiler/src/macro_system/expander.rs:111:21
    |
109 |                 Err(Error::new(
    |                     ---------- required by a bound introduced by this call
110 |                     format!("no matching macro rule for {}", def.name),
111 |                     span,
    |                     ^^^^ the trait `From<span::Span>` is not implemented for `String`
    |
    = help: the following other types implement trait `From<T>`:
              `String` implements `From<&String>`
              `String` implements `From<&mut str>`
              `String` implements `From<&str>`
              `String` implements `From<Box<str>>`
              `String` implements `From<Cow<'_, str>>`
              `String` implements `From<char>`
              `String` implements `From<clap::Id>`
              `String` implements `From<clap::builder::Str>`
    = note: required for `span::Span` to implement `Into<String>`
note: required by a bound in `error::Error::new`
   --> compiler/src/error.rs:47:47
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |                                               ^^^^^^^^^^^^ required by this bound in `Error::new`

error[E0277]: the trait bound `String: From<span::Span>` is not satisfied
   --> compiler/src/macro_system/expander.rs:116:73
    |
116 |                 Err(Error::new("procedural macros not yet implemented", span))
    |                     ----------                                          ^^^^ the trait `From<span::Span>` is not implemented for `String`
    |                     |
    |                     required by a bound introduced by this call
    |
    = help: the following other types implement trait `From<T>`:
              `String` implements `From<&String>`
              `String` implements `From<&mut str>`
              `String` implements `From<&str>`
              `String` implements `From<Box<str>>`
              `String` implements `From<Cow<'_, str>>`
              `String` implements `From<char>`
              `String` implements `From<clap::Id>`
              `String` implements `From<clap::builder::Str>`
    = note: required for `span::Span` to implement `Into<String>`
note: required by a bound in `error::Error::new`
   --> compiler/src/error.rs:47:47
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |                                               ^^^^^^^^^^^^ required by this bound in `Error::new`

error[E0308]: mismatched types
   --> compiler/src/macro_system/expander.rs:116:32
    |
116 |                 Err(Error::new("procedural macros not yet implemented", span))
    |                     ---------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `&str`
    |                     |
    |                     arguments to this function are incorrect
    |
note: associated function defined here
   --> compiler/src/error.rs:47:12
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |            ^^^ ---------------

error[E0559]: variant `ast::Expr::Block` has no field named `stmts`
   --> compiler/src/macro_system/expander.rs:224:13
    |
224 |             stmts: vec![],
    |             ^^^^^ field does not exist
    |
   ::: compiler/src/parser/ast.rs:103:5
    |
103 |     Block(Vec<Stmt>),
    |     ----- `ast::Expr::Block` defined here
    |
help: `ast::Expr::Block` is a tuple variant, use the appropriate syntax
    |
223 -         Ok(Expr::Block {
224 -             stmts: vec![],
225 -             span,
226 -         })
223 +         Ok(Expr::Block(/* Vec<ast::Stmt> */))
    |

error[E0559]: variant `ast::Expr::Block` has no field named `span`
   --> compiler/src/macro_system/expander.rs:225:13
    |
225 |             span,
    |             ^^^^ field does not exist
    |
   ::: compiler/src/parser/ast.rs:103:5
    |
103 |     Block(Vec<Stmt>),
    |     ----- `ast::Expr::Block` defined here
    |
help: `ast::Expr::Block` is a tuple variant, use the appropriate syntax
    |
223 -         Ok(Expr::Block {
224 -             stmts: vec![],
225 -             span,
226 -         })
223 +         Ok(Expr::Block(/* Vec<ast::Stmt> */))
    |

error[E0599]: no function or associated item named `dummy` found for struct `span::Span` in the current scope
   --> compiler/src/macro_system/mod.rs:132:29
    |
132 |                 span: Span::dummy(),
    |                             ^^^^^ function or associated item not found in `span::Span`
    |
   ::: compiler/src/span.rs:31:1
    |
 31 | pub struct Span {
    | --------------- function or associated item `dummy` not found for this struct
    |
note: if you're trying to build a new `span::Span`, consider using `span::Span::new` which returns `span::Span`
   --> compiler/src/span.rs:37:5
    |
 37 |     pub fn new(start: Position, end: Position) -> Self {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0599]: no function or associated item named `dummy` found for struct `span::Span` in the current scope
   --> compiler/src/macro_system/mod.rs:187:29
    |
187 |                 span: Span::dummy(),
    |                             ^^^^^ function or associated item not found in `span::Span`
    |
   ::: compiler/src/span.rs:31:1
    |
 31 | pub struct Span {
    | --------------- function or associated item `dummy` not found for this struct
    |
note: if you're trying to build a new `span::Span`, consider using `span::Span::new` which returns `span::Span`
   --> compiler/src/span.rs:37:5
    |
 37 |     pub fn new(start: Position, end: Position) -> Self {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0599]: no function or associated item named `dummy` found for struct `span::Span` in the current scope
   --> compiler/src/macro_system/mod.rs:209:29
    |
209 |                 span: Span::dummy(),
    |                             ^^^^^ function or associated item not found in `span::Span`
    |
   ::: compiler/src/span.rs:31:1
    |
 31 | pub struct Span {
    | --------------- function or associated item `dummy` not found for this struct
    |
note: if you're trying to build a new `span::Span`, consider using `span::Span::new` which returns `span::Span`
   --> compiler/src/span.rs:37:5
    |
 37 |     pub fn new(start: Position, end: Position) -> Self {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0282]: type annotations needed
   --> compiler/src/async_runtime/executor.rs:132:25
    |
132 |                         task.poll(&waker);
    |                         ^^^^ cannot infer type

error[E0599]: no function or associated item named `from_millis` found for struct `async_runtime::Duration` in the current scope
   --> compiler/src/async_runtime/executor.rs:135:49
    |
135 |                         Thread::sleep(Duration::from_millis(10));
    |                                                 ^^^^^^^^^^^ function or associated item not found in `async_runtime::Duration`
    |
   ::: compiler/src/async_runtime/mod.rs:142:1
    |
142 | pub struct Duration {
    | ------------------- function or associated item `from_millis` not found for this struct

error[E0026]: variant `ast::Expr::Literal` does not have a field named `value`
   --> compiler/src/verification/smt_solver.rs:109:29
    |
109 |             Expr::Literal { value, .. } => {
    |                             ^^^^^
    |                             |
    |                             variant `ast::Expr::Literal` does not have this field
    |                             help: `ast::Expr::Literal` has a field named `0`

error[E0599]: no variant named `Variable` found for enum `ast::Expr`
   --> compiler/src/verification/smt_solver.rs:116:19
    |
116 |             Expr::Variable { name, .. } => Ok(name.clone()),
    |                   ^^^^^^^^ variant not found in `ast::Expr`
    |
   ::: compiler/src/parser/ast.rs:94:1
    |
 94 | pub enum Expr {
    | ------------- variant `Variable` not found here

error[E0026]: variant `ast::Expr::Binary` does not have fields named `op`, `left`, `right`
   --> compiler/src/verification/smt_solver.rs:117:28
    |
117 |             Expr::Binary { op, left, right, .. } => {
    |                            ^^  ^^^^  ^^^^^ variant `ast::Expr::Binary` does not have these fields

error[E0026]: variant `ast::Expr::Unary` does not have fields named `op`, `operand`
   --> compiler/src/verification/smt_solver.rs:139:27
    |
139 |             Expr::Unary { op, operand, .. } => {
    |                           ^^  ^^^^^^^ variant `ast::Expr::Unary` does not have these fields

error[E0308]: mismatched types
   --> compiler/src/verification/smt_solver.rs:113:41
    |
113 |                     _ => Err(Error::new("Unsupported literal type for SMT", Span::dummy())),
    |                              ---------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `&str`
    |                              |
    |                              arguments to this function are incorrect
    |
note: associated function defined here
   --> compiler/src/error.rs:47:12
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |            ^^^ ---------------

error[E0308]: mismatched types
   --> compiler/src/verification/smt_solver.rs:134:48
    |
134 |                     _ => return Err(Error::new("Unsupported binary operator for SMT", Span::dummy())),
    |                                     ---------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `&str`
    |                                     |
    |                                     arguments to this function are incorrect
    |
note: associated function defined here
   --> compiler/src/error.rs:47:12
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |            ^^^ ---------------

error[E0308]: mismatched types
   --> compiler/src/verification/smt_solver.rs:145:48
    |
145 |                     _ => return Err(Error::new("Unsupported unary operator for SMT", Span::dummy())),
    |                                     ---------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `&str`
    |                                     |
    |                                     arguments to this function are incorrect
    |
note: associated function defined here
   --> compiler/src/error.rs:47:12
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |            ^^^ ---------------

error[E0308]: mismatched types
   --> compiler/src/verification/smt_solver.rs:150:33
    |
150 |             _ => Err(Error::new("Unsupported expression type for SMT", Span::dummy())),
    |                      ---------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `&str`
    |                      |
    |                      arguments to this function are incorrect
    |
note: associated function defined here
   --> compiler/src/error.rs:47:12
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |            ^^^ ---------------

error[E0599]: no variant named `Variable` found for enum `ast::Expr`
   --> compiler/src/verification/smt_solver.rs:164:19
    |
164 |             Expr::Variable { name, .. } => {
    |                   ^^^^^^^^ variant not found in `ast::Expr`
    |
   ::: compiler/src/parser/ast.rs:94:1
    |
 94 | pub enum Expr {
    | ------------- variant `Variable` not found here

error[E0026]: variant `ast::Expr::Binary` does not have fields named `left`, `right`
   --> compiler/src/verification/smt_solver.rs:167:28
    |
167 |             Expr::Binary { left, right, .. } => {
    |                            ^^^^  ^^^^^ variant `ast::Expr::Binary` does not have these fields

error[E0026]: variant `ast::Expr::Unary` does not have a field named `operand`
   --> compiler/src/verification/smt_solver.rs:171:27
    |
171 |             Expr::Unary { operand, .. } => {
    |                           ^^^^^^^ variant `ast::Expr::Unary` does not have this field

error[E0308]: mismatched types
   --> compiler/src/verification/smt_solver.rs:195:37
    |
195 |             .map_err(|e| Error::new(format!("Failed to spawn SMT solver: {}", e), Span::dummy()))?;
    |                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `String`
    |
    = note: this error originates in the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0308]: mismatched types
   --> compiler/src/verification/smt_solver.rs:199:41
    |
199 |                 .map_err(|e| Error::new(format!("Failed to write to SMT solver: {}", e), Span::dummy()))?;
    |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `String`
    |
    = note: this error originates in the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0308]: mismatched types
   --> compiler/src/verification/smt_solver.rs:203:37
    |
203 |             .map_err(|e| Error::new(format!("Failed to read SMT solver output: {}", e), Span::dummy()))?;
    |                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `String`
    |
    = note: this error originates in the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0599]: no method named `prove_postcondition` found for mutable reference `&mut FormalVerifier` in the current scope
   --> compiler/src/verification/mod.rs:115:30
    |
115 |             let proof = self.prove_postcondition(func, post)?;
    |                              ^^^^^^^^^^^^^^^^^^^
    |
help: there is a method `verify_postcondition` with a similar name
    |
115 -             let proof = self.prove_postcondition(func, post)?;
115 +             let proof = self.verify_postcondition(func, post)?;
    |

error[E0599]: no method named `check_memory_safety` found for mutable reference `&mut FormalVerifier` in the current scope
   --> compiler/src/verification/mod.rs:120:34
    |
120 |         let memory_safety = self.check_memory_safety(func)?;
    |                                  ^^^^^^^^^^^^^^^^^^^
    |
help: there is a method `check_null_safety` with a similar name
    |
120 -         let memory_safety = self.check_memory_safety(func)?;
120 +         let memory_safety = self.check_null_safety(func)?;
    |

error[E0599]: no method named `prove_invariant_init` found for mutable reference `&mut FormalVerifier` in the current scope
   --> compiler/src/verification/mod.rs:136:31
    |
136 |         let init_proof = self.prove_invariant_init(&invariant)?;
    |                               ^^^^^^^^^^^^^^^^^^^^
    |
help: there is a method `verify_invariant_init` with a similar name
    |
136 -         let init_proof = self.prove_invariant_init(&invariant)?;
136 +         let init_proof = self.verify_invariant_init(&invariant)?;
    |

error[E0599]: no method named `prove_invariant_maintained` found for mutable reference `&mut FormalVerifier` in the current scope
   --> compiler/src/verification/mod.rs:142:35
    |
142 |         let maintain_proof = self.prove_invariant_maintained(&invariant, loop_stmt)?;
    |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^ method not found in `&mut FormalVerifier`

error[E0609]: no field `attributes` on type `&ast::Function`
   --> compiler/src/verification/mod.rs:204:27
    |
204 |         for attr in &func.attributes {
    |                           ^^^^^^^^^^ unknown field
    |
    = note: available fields are: `name`, `generics`, `params`, `return_type`, `where_clause`, `body`

error[E0282]: type annotations needed
   --> compiler/src/verification/mod.rs:207:40
    |
207 |                     preconditions.push(expr.clone());
    |                                        ^^^^ cannot infer type

error[E0609]: no field `attributes` on type `&ast::Function`
   --> compiler/src/verification/mod.rs:219:27
    |
219 |         for attr in &func.attributes {
    |                           ^^^^^^^^^^ unknown field
    |
    = note: available fields are: `name`, `generics`, `params`, `return_type`, `where_clause`, `body`

error[E0282]: type annotations needed
   --> compiler/src/verification/mod.rs:222:41
    |
222 |                     postconditions.push(expr.clone());
    |                                         ^^^^ cannot infer type

error[E0026]: variant `ast::Stmt::Let` does not have fields named `pattern`, `init`
   --> compiler/src/gpu/mod.rs:243:25
    |
243 |             Stmt::Let { pattern, init, .. } => {
    |                         ^^^^^^^  ^^^^ variant `ast::Stmt::Let` does not have these fields

error[E0026]: variant `ast::Expr::Literal` does not have a field named `value`
   --> compiler/src/gpu/mod.rs:259:29
    |
259 |             Expr::Literal { value, .. } => {
    |                             ^^^^^
    |                             |
    |                             variant `ast::Expr::Literal` does not have this field
    |                             help: `ast::Expr::Literal` has a field named `0`

error[E0599]: no variant named `Variable` found for enum `ast::Expr`
   --> compiler/src/gpu/mod.rs:267:19
    |
267 |             Expr::Variable { name, .. } => Ok(name.clone()),
    |                   ^^^^^^^^ variant not found in `ast::Expr`
    |
   ::: compiler/src/parser/ast.rs:94:1
    |
 94 | pub enum Expr {
    | ------------- variant `Variable` not found here

error[E0026]: variant `ast::Expr::Binary` does not have fields named `op`, `left`, `right`
   --> compiler/src/gpu/mod.rs:268:28
    |
268 |             Expr::Binary { op, left, right, .. } => {
    |                            ^^  ^^^^  ^^^^^ variant `ast::Expr::Binary` does not have these fields

error[E0599]: no variant or associated item named `I32` found for enum `ast::Type` in the current scope
   --> compiler/src/gpu/mod.rs:304:19
    |
304 |             Type::I32 => Ok("int".to_string()),
    |                   ^^^ variant or associated item not found in `ast::Type`
    |
   ::: compiler/src/parser/ast.rs:73:1
    |
 73 | pub enum Type {
    | ------------- variant or associated item `I32` not found for this enum

error[E0599]: no variant or associated item named `I64` found for enum `ast::Type` in the current scope
   --> compiler/src/gpu/mod.rs:305:19
    |
305 |             Type::I64 => Ok("long".to_string()),
    |                   ^^^ variant or associated item not found in `ast::Type`
    |
   ::: compiler/src/parser/ast.rs:73:1
    |
 73 | pub enum Type {
    | ------------- variant or associated item `I64` not found for this enum

error[E0599]: no variant or associated item named `F32` found for enum `ast::Type` in the current scope
   --> compiler/src/gpu/mod.rs:306:19
    |
306 |             Type::F32 => Ok("float".to_string()),
    |                   ^^^ variant or associated item not found in `ast::Type`
    |
   ::: compiler/src/parser/ast.rs:73:1
    |
 73 | pub enum Type {
    | ------------- variant or associated item `F32` not found for this enum

error[E0599]: no variant or associated item named `F64` found for enum `ast::Type` in the current scope
   --> compiler/src/gpu/mod.rs:307:19
    |
307 |             Type::F64 => Ok("double".to_string()),
    |                   ^^^ variant or associated item not found in `ast::Type`
    |
   ::: compiler/src/parser/ast.rs:73:1
    |
 73 | pub enum Type {
    | ------------- variant or associated item `F64` not found for this enum

error[E0599]: no variant or associated item named `Pointer` found for enum `ast::Type` in the current scope
   --> compiler/src/gpu/mod.rs:308:19
    |
308 |             Type::Pointer(inner) => Ok(format!("{}*", self.cuda_type(inner)?)),
    |                   ^^^^^^^ variant or associated item not found in `ast::Type`
    |
   ::: compiler/src/parser/ast.rs:73:1
    |
 73 | pub enum Type {
    | ------------- variant or associated item `Pointer` not found for this enum

error[E0599]: no variant or associated item named `I32` found for enum `ast::Type` in the current scope
   --> compiler/src/gpu/mod.rs:315:19
    |
315 |             Type::I32 => Ok("device int*".to_string()),
    |                   ^^^ variant or associated item not found in `ast::Type`
    |
   ::: compiler/src/parser/ast.rs:73:1
    |
 73 | pub enum Type {
    | ------------- variant or associated item `I32` not found for this enum

error[E0599]: no variant or associated item named `I64` found for enum `ast::Type` in the current scope
   --> compiler/src/gpu/mod.rs:316:19
    |
316 |             Type::I64 => Ok("device long*".to_string()),
    |                   ^^^ variant or associated item not found in `ast::Type`
    |
   ::: compiler/src/parser/ast.rs:73:1
    |
 73 | pub enum Type {
    | ------------- variant or associated item `I64` not found for this enum

error[E0599]: no variant or associated item named `F32` found for enum `ast::Type` in the current scope
   --> compiler/src/gpu/mod.rs:317:19
    |
317 |             Type::F32 => Ok("device float*".to_string()),
    |                   ^^^ variant or associated item not found in `ast::Type`
    |
   ::: compiler/src/parser/ast.rs:73:1
    |
 73 | pub enum Type {
    | ------------- variant or associated item `F32` not found for this enum

error[E0599]: no variant or associated item named `F64` found for enum `ast::Type` in the current scope
   --> compiler/src/gpu/mod.rs:318:19
    |
318 |             Type::F64 => Ok("device double*".to_string()),
    |                   ^^^ variant or associated item not found in `ast::Type`
    |
   ::: compiler/src/parser/ast.rs:73:1
    |
 73 | pub enum Type {
    | ------------- variant or associated item `F64` not found for this enum

error[E0599]: no variant or associated item named `I32` found for enum `ast::Type` in the current scope
   --> compiler/src/gpu/mod.rs:325:19
    |
325 |             Type::I32 => Ok("int".to_string()),
    |                   ^^^ variant or associated item not found in `ast::Type`
    |
   ::: compiler/src/parser/ast.rs:73:1
    |
 73 | pub enum Type {
    | ------------- variant or associated item `I32` not found for this enum

error[E0599]: no variant or associated item named `I64` found for enum `ast::Type` in the current scope
   --> compiler/src/gpu/mod.rs:326:19
    |
326 |             Type::I64 => Ok("int64_t".to_string()),
    |                   ^^^ variant or associated item not found in `ast::Type`
    |
   ::: compiler/src/parser/ast.rs:73:1
    |
 73 | pub enum Type {
    | ------------- variant or associated item `I64` not found for this enum

error[E0599]: no variant or associated item named `F32` found for enum `ast::Type` in the current scope
   --> compiler/src/gpu/mod.rs:327:19
    |
327 |             Type::F32 => Ok("float".to_string()),
    |                   ^^^ variant or associated item not found in `ast::Type`
    |
   ::: compiler/src/parser/ast.rs:73:1
    |
 73 | pub enum Type {
    | ------------- variant or associated item `F32` not found for this enum

error[E0599]: no variant or associated item named `F64` found for enum `ast::Type` in the current scope
   --> compiler/src/gpu/mod.rs:328:19
    |
328 |             Type::F64 => Ok("double".to_string()),
    |                   ^^^ variant or associated item not found in `ast::Type`
    |
   ::: compiler/src/parser/ast.rs:73:1
    |
 73 | pub enum Type {
    | ------------- variant or associated item `F64` not found for this enum

error[E0599]: no variant or associated item named `I32` found for enum `ast::Type` in the current scope
   --> compiler/src/gpu/mod.rs:335:19
    |
335 |             Type::I32 => Ok("int*".to_string()),
    |                   ^^^ variant or associated item not found in `ast::Type`
    |
   ::: compiler/src/parser/ast.rs:73:1
    |
 73 | pub enum Type {
    | ------------- variant or associated item `I32` not found for this enum

error[E0599]: no variant or associated item named `I64` found for enum `ast::Type` in the current scope
   --> compiler/src/gpu/mod.rs:336:19
    |
336 |             Type::I64 => Ok("long*".to_string()),
    |                   ^^^ variant or associated item not found in `ast::Type`
    |
   ::: compiler/src/parser/ast.rs:73:1
    |
 73 | pub enum Type {
    | ------------- variant or associated item `I64` not found for this enum

error[E0599]: no variant or associated item named `F32` found for enum `ast::Type` in the current scope
   --> compiler/src/gpu/mod.rs:337:19
    |
337 |             Type::F32 => Ok("float*".to_string()),
    |                   ^^^ variant or associated item not found in `ast::Type`
    |
   ::: compiler/src/parser/ast.rs:73:1
    |
 73 | pub enum Type {
    | ------------- variant or associated item `F32` not found for this enum

error[E0599]: no variant or associated item named `F64` found for enum `ast::Type` in the current scope
   --> compiler/src/gpu/mod.rs:338:19
    |
338 |             Type::F64 => Ok("double*".to_string()),
    |                   ^^^ variant or associated item not found in `ast::Type`
    |
   ::: compiler/src/parser/ast.rs:73:1
    |
 73 | pub enum Type {
    | ------------- variant or associated item `F64` not found for this enum

error[E0026]: variant `ast::Expr::Literal` does not have a field named `value`
  --> compiler/src/consteval/mod.rs:61:29
   |
61 |             Expr::Literal { value, .. } => self.eval_literal(value),
   |                             ^^^^^
   |                             |
   |                             variant `ast::Expr::Literal` does not have this field
   |                             help: `ast::Expr::Literal` has a field named `0`

error[E0599]: no variant named `Variable` found for enum `ast::Expr`
  --> compiler/src/consteval/mod.rs:63:19
   |
63 |             Expr::Variable { name, .. } => {
   |                   ^^^^^^^^ variant not found in `ast::Expr`
   |
  ::: compiler/src/parser/ast.rs:94:1
   |
94 | pub enum Expr {
   | ------------- variant `Variable` not found here

error[E0026]: variant `ast::Expr::Binary` does not have fields named `op`, `left`, `right`
  --> compiler/src/consteval/mod.rs:72:28
   |
72 |             Expr::Binary { op, left, right, .. } => {
   |                            ^^  ^^^^  ^^^^^ variant `ast::Expr::Binary` does not have these fields

error[E0026]: variant `ast::Expr::Unary` does not have fields named `op`, `operand`
  --> compiler/src/consteval/mod.rs:78:27
   |
78 |             Expr::Unary { op, operand, .. } => {
   |                           ^^  ^^^^^^^ variant `ast::Expr::Unary` does not have these fields

error[E0026]: variant `ast::Expr::Call` does not have fields named `func`, `args`
  --> compiler/src/consteval/mod.rs:83:26
   |
83 |             Expr::Call { func, args, .. } => {
   |                          ^^^^  ^^^^ variant `ast::Expr::Call` does not have these fields

error[E0026]: variant `ast::Expr::If` does not have fields named `condition`, `then_branch`, `else_branch`
  --> compiler/src/consteval/mod.rs:87:24
   |
87 |             Expr::If { condition, then_branch, else_branch, .. } => {
   |                        ^^^^^^^^^  ^^^^^^^^^^^  ^^^^^^^^^^^ variant `ast::Expr::If` does not have these fields

error[E0026]: variant `ast::Expr::Array` does not have a field named `elements`
  --> compiler/src/consteval/mod.rs:98:27
   |
98 |             Expr::Array { elements, .. } => {
   |                           ^^^^^^^^
   |                           |
   |                           variant `ast::Expr::Array` does not have this field
   |                           help: `ast::Expr::Array` has a field named `0`

error[E0308]: mismatched types
  --> compiler/src/consteval/mod.rs:67:25
   |
67 |                         format!("Undefined constant: {}", name),
   |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `String`
   |
   = note: this error originates in the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0308]: mismatched types
   --> compiler/src/consteval/mod.rs:107:17
    |
106 |             _ => Err(Error::new(
    |                      ---------- arguments to this function are incorrect
107 |                 "Expression cannot be evaluated at compile time",
    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `&str`
    |
note: associated function defined here
   --> compiler/src/error.rs:47:12
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |            ^^^ ---------------

error[E0308]: mismatched types
   --> compiler/src/consteval/mod.rs:132:51
    |
132 | ...                   return Err(Error::new("Division by zero", Span::dummy()));
    |                                  ---------- ^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `&str`
    |                                  |
    |                                  arguments to this function are incorrect
    |
note: associated function defined here
   --> compiler/src/error.rs:47:12
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |            ^^^ ---------------

error[E0308]: mismatched types
   --> compiler/src/consteval/mod.rs:148:48
    |
148 |                     _ => return Err(Error::new("Unsupported binary operation", Span::dummy())),
    |                                     ---------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `&str`
    |                                     |
    |                                     arguments to this function are incorrect
    |
note: associated function defined here
   --> compiler/src/error.rs:47:12
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |            ^^^ ---------------

error[E0308]: mismatched types
   --> compiler/src/consteval/mod.rs:165:48
    |
165 |                     _ => return Err(Error::new("Unsupported binary operation", Span::dummy())),
    |                                     ---------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `&str`
    |                                     |
    |                                     arguments to this function are incorrect
    |
note: associated function defined here
   --> compiler/src/error.rs:47:12
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |            ^^^ ---------------

error[E0308]: mismatched types
   --> compiler/src/consteval/mod.rs:176:48
    |
176 |                     _ => return Err(Error::new("Unsupported binary operation", Span::dummy())),
    |                                     ---------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `&str`
    |                                     |
    |                                     arguments to this function are incorrect
    |
note: associated function defined here
   --> compiler/src/error.rs:47:12
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |            ^^^ ---------------

error[E0308]: mismatched types
   --> compiler/src/consteval/mod.rs:181:33
    |
181 |             _ => Err(Error::new("Type mismatch in binary operation", Span::dummy())),
    |                      ---------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `&str`
    |                      |
    |                      arguments to this function are incorrect
    |
note: associated function defined here
   --> compiler/src/error.rs:47:12
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |            ^^^ ---------------

error[E0308]: mismatched types
   --> compiler/src/consteval/mod.rs:192:48
    |
192 |                     _ => return Err(Error::new("Unsupported unary operation", Span::dummy())),
    |                                     ---------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `&str`
    |                                     |
    |                                     arguments to this function are incorrect
    |
note: associated function defined here
   --> compiler/src/error.rs:47:12
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |            ^^^ ---------------

error[E0308]: mismatched types
   --> compiler/src/consteval/mod.rs:200:48
    |
200 |                     _ => return Err(Error::new("Unsupported unary operation", Span::dummy())),
    |                                     ---------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `&str`
    |                                     |
    |                                     arguments to this function are incorrect
    |
note: associated function defined here
   --> compiler/src/error.rs:47:12
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |            ^^^ ---------------

error[E0308]: mismatched types
   --> compiler/src/consteval/mod.rs:208:48
    |
208 |                     _ => return Err(Error::new("Unsupported unary operation", Span::dummy())),
    |                                     ---------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `&str`
    |                                     |
    |                                     arguments to this function are incorrect
    |
note: associated function defined here
   --> compiler/src/error.rs:47:12
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |            ^^^ ---------------

error[E0308]: mismatched types
   --> compiler/src/consteval/mod.rs:213:33
    |
213 |             _ => Err(Error::new("Type mismatch in unary operation", Span::dummy())),
    |                      ---------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `&str`
    |                      |
    |                      arguments to this function are incorrect
    |
note: associated function defined here
   --> compiler/src/error.rs:47:12
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |            ^^^ ---------------

error[E0599]: no variant named `Variable` found for enum `ast::Expr`
   --> compiler/src/consteval/mod.rs:220:19
    |
220 |             Expr::Variable { name, .. } => name,
    |                   ^^^^^^^^ variant not found in `ast::Expr`
    |
   ::: compiler/src/parser/ast.rs:94:1
    |
 94 | pub enum Expr {
    | ------------- variant `Variable` not found here

error[E0308]: mismatched types
   --> compiler/src/consteval/mod.rs:221:40
    |
221 |             _ => return Err(Error::new("Invalid function call", Span::dummy())),
    |                             ---------- ^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `&str`
    |                             |
    |                             arguments to this function are incorrect
    |
note: associated function defined here
   --> compiler/src/error.rs:47:12
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |            ^^^ ---------------

error[E0308]: mismatched types
   --> compiler/src/consteval/mod.rs:238:17
    |
238 |                 format!("Unknown compile-time function: {}", func_name),
    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `String`
    |
    = note: this error originates in the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0308]: mismatched types
   --> compiler/src/consteval/mod.rs:246:35
    |
246 |             return Err(Error::new("abs expects 1 argument", Span::dummy()));
    |                        ---------- ^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `&str`
    |                        |
    |                        arguments to this function are incorrect
    |
note: associated function defined here
   --> compiler/src/error.rs:47:12
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |            ^^^ ---------------

error[E0308]: mismatched types
   --> compiler/src/consteval/mod.rs:252:33
    |
252 |             _ => Err(Error::new("abs expects numeric argument", Span::dummy())),
    |                      ---------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `&str`
    |                      |
    |                      arguments to this function are incorrect
    |
note: associated function defined here
   --> compiler/src/error.rs:47:12
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |            ^^^ ---------------

error[E0308]: mismatched types
   --> compiler/src/consteval/mod.rs:258:35
    |
258 |             return Err(Error::new("min expects 2 arguments", Span::dummy()));
    |                        ---------- ^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `&str`
    |                        |
    |                        arguments to this function are incorrect
    |
note: associated function defined here
   --> compiler/src/error.rs:47:12
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |            ^^^ ---------------

error[E0308]: mismatched types
   --> compiler/src/consteval/mod.rs:264:33
    |
264 |             _ => Err(Error::new("min expects numeric arguments", Span::dummy())),
    |                      ---------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `&str`
    |                      |
    |                      arguments to this function are incorrect
    |
note: associated function defined here
   --> compiler/src/error.rs:47:12
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |            ^^^ ---------------

error[E0308]: mismatched types
   --> compiler/src/consteval/mod.rs:270:35
    |
270 |             return Err(Error::new("max expects 2 arguments", Span::dummy()));
    |                        ---------- ^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `&str`
    |                        |
    |                        arguments to this function are incorrect
    |
note: associated function defined here
   --> compiler/src/error.rs:47:12
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |            ^^^ ---------------

error[E0308]: mismatched types
   --> compiler/src/consteval/mod.rs:276:33
    |
276 |             _ => Err(Error::new("max expects numeric arguments", Span::dummy())),
    |                      ---------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `&str`
    |                      |
    |                      arguments to this function are incorrect
    |
note: associated function defined here
   --> compiler/src/error.rs:47:12
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |            ^^^ ---------------

error[E0308]: mismatched types
   --> compiler/src/consteval/mod.rs:282:35
    |
282 |             return Err(Error::new("pow expects 2 arguments", Span::dummy()));
    |                        ---------- ^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `&str`
    |                        |
    |                        arguments to this function are incorrect
    |
note: associated function defined here
   --> compiler/src/error.rs:47:12
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |            ^^^ ---------------

error[E0308]: mismatched types
   --> compiler/src/consteval/mod.rs:291:43
    |
291 |                     return Err(Error::new("Negative exponent for integer pow", Span::dummy()));
    |                                ---------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `&str`
    |                                |
    |                                arguments to this function are incorrect
    |
note: associated function defined here
   --> compiler/src/error.rs:47:12
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |            ^^^ ---------------

error[E0308]: mismatched types
   --> compiler/src/consteval/mod.rs:295:33
    |
295 |             _ => Err(Error::new("pow expects numeric arguments", Span::dummy())),
    |                      ---------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `&str`
    |                      |
    |                      arguments to this function are incorrect
    |
note: associated function defined here
   --> compiler/src/error.rs:47:12
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |            ^^^ ---------------

error[E0308]: mismatched types
   --> compiler/src/consteval/mod.rs:301:35
    |
301 |             return Err(Error::new("sqrt expects 1 argument", Span::dummy()));
    |                        ---------- ^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `&str`
    |                        |
    |                        arguments to this function are incorrect
    |
note: associated function defined here
   --> compiler/src/error.rs:47:12
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |            ^^^ ---------------

error[E0308]: mismatched types
   --> compiler/src/consteval/mod.rs:307:43
    |
307 |                     return Err(Error::new("sqrt of negative number", Span::dummy()));
    |                                ---------- ^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `&str`
    |                                |
    |                                arguments to this function are incorrect
    |
note: associated function defined here
   --> compiler/src/error.rs:47:12
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |            ^^^ ---------------

error[E0308]: mismatched types
   --> compiler/src/consteval/mod.rs:311:33
    |
311 |             _ => Err(Error::new("sqrt expects float argument", Span::dummy())),
    |                      ---------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `&str`
    |                      |
    |                      arguments to this function are incorrect
    |
note: associated function defined here
   --> compiler/src/error.rs:47:12
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |            ^^^ ---------------

warning: unused variable: `func`
   --> compiler/src/verification/mod.rs:194:41
    |
194 |     fn check_overflow_safety(&mut self, func: &Function) -> Result<bool> {
    |                                         ^^^^ help: if this is intentional, prefix it with an underscore: `_func`
    |
    = note: `#[warn(unused_variables)]` (part of `#[warn(unused)]`) on by default

error[E0594]: cannot assign to `proof.status`, as `proof` is not declared as mutable
   --> compiler/src/verification/mod.rs:247:13
    |
247 |             proof.status = ProofStatus::Proven;
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ cannot assign
    |
help: consider changing this to be mutable
    |
237 |         let mut proof = Proof {
    |             +++

error[E0594]: cannot assign to `proof.status`, as `proof` is not declared as mutable
   --> compiler/src/verification/mod.rs:249:13
    |
249 |             proof.status = ProofStatus::Failed;
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ cannot assign
    |
help: consider changing this to be mutable
    |
237 |         let mut proof = Proof {
    |             +++

warning: variable does not need to be mutable
   --> compiler/src/verification/mod.rs:268:13
    |
268 |         let mut proof = Proof {
    |             ----^^^^^
    |             |
    |             help: remove this `mut`
    |
    = note: `#[warn(unused_mut)]` (part of `#[warn(unused)]`) on by default

Some errors have detailed explanations: E0023, E0026, E0027, E0277, E0282, E0308, E0412, E0432, E0433...
For more information about an error, try `rustc --explain E0023`.
warning: `vez_compiler` (lib) generated 14 warnings
error: could not compile `vez_compiler` (lib) due to 288 previous errors; 14 warnings emitted
warning: build failed, waiting for other jobs to finish...
[0;32mâœ“[0m All workspace packages built successfully

==========================================
4. Binary Verification
==========================================
[1;33mâ†’[0m Checking for vezc binary...
[0;31mâœ—[0m vezc binary not found
[1;33mâ†’[0m Checking for vpm binary...
[1;33mâš [0m vpm binary not found (may not have main.rs)
[1;33mâ†’[0m Checking for vez-lsp binary...
[1;33mâš [0m vez-lsp binary not found (may not have main.rs)

==========================================
5. Unit Tests
==========================================
[1;33mâ†’[0m Running compiler tests...
warning: profiles for the non root package will be ignored, specify profiles at the workspace root:
package:   /run/media/zarigata/42A0B8BDA0B8B8AD/ARTIFICIAL-INTELIGENCE/ArtificialProgramingLanguage/compiler/Cargo.toml
workspace: /run/media/zarigata/42A0B8BDA0B8B8AD/ARTIFICIAL-INTELIGENCE/ArtificialProgramingLanguage/Cargo.toml
   Compiling vez_compiler v0.1.0 (/run/media/zarigata/42A0B8BDA0B8B8AD/ARTIFICIAL-INTELIGENCE/ArtificialProgramingLanguage/compiler)
error[E0583]: file not found for module `hygiene`
 --> compiler/src/macro_system/mod.rs:5:1
  |
5 | pub mod hygiene;
  | ^^^^^^^^^^^^^^^^
  |
  = help: to create the module `hygiene`, create file "compiler/src/macro_system/hygiene.rs" or "compiler/src/macro_system/hygiene/mod.rs"
  = note: if there is a `mod hygiene` elsewhere in the crate already, import it with `use crate::...` instead

error[E0583]: file not found for module `parser`
 --> compiler/src/macro_system/mod.rs:6:1
  |
6 | pub mod parser;
  | ^^^^^^^^^^^^^^^
  |
  = help: to create the module `parser`, create file "compiler/src/macro_system/parser.rs" or "compiler/src/macro_system/parser/mod.rs"
  = note: if there is a `mod parser` elsewhere in the crate already, import it with `use crate::...` instead

error[E0583]: file not found for module `builtin`
 --> compiler/src/macro_system/mod.rs:7:1
  |
7 | pub mod builtin;
  | ^^^^^^^^^^^^^^^^
  |
  = help: to create the module `builtin`, create file "compiler/src/macro_system/builtin.rs" or "compiler/src/macro_system/builtin/mod.rs"
  = note: if there is a `mod builtin` elsewhere in the crate already, import it with `use crate::...` instead

error[E0583]: file not found for module `future`
 --> compiler/src/async_runtime/mod.rs:4:1
  |
4 | pub mod future;
  | ^^^^^^^^^^^^^^^
  |
  = help: to create the module `future`, create file "compiler/src/async_runtime/future.rs" or "compiler/src/async_runtime/future/mod.rs"
  = note: if there is a `mod future` elsewhere in the crate already, import it with `use crate::...` instead

error[E0583]: file not found for module `task`
 --> compiler/src/async_runtime/mod.rs:6:1
  |
6 | pub mod task;
  | ^^^^^^^^^^^^^
  |
  = help: to create the module `task`, create file "compiler/src/async_runtime/task.rs" or "compiler/src/async_runtime/task/mod.rs"
  = note: if there is a `mod task` elsewhere in the crate already, import it with `use crate::...` instead

error[E0583]: file not found for module `waker`
 --> compiler/src/async_runtime/mod.rs:7:1
  |
7 | pub mod waker;
  | ^^^^^^^^^^^^^^
  |
  = help: to create the module `waker`, create file "compiler/src/async_runtime/waker.rs" or "compiler/src/async_runtime/waker/mod.rs"
  = note: if there is a `mod waker` elsewhere in the crate already, import it with `use crate::...` instead

error[E0583]: file not found for module `proof_engine`
 --> compiler/src/verification/mod.rs:5:1
  |
5 | pub mod proof_engine;
  | ^^^^^^^^^^^^^^^^^^^^^
  |
  = help: to create the module `proof_engine`, create file "compiler/src/verification/proof_engine.rs" or "compiler/src/verification/proof_engine/mod.rs"
  = note: if there is a `mod proof_engine` elsewhere in the crate already, import it with `use crate::...` instead

error[E0583]: file not found for module `safety_checker`
 --> compiler/src/verification/mod.rs:6:1
  |
6 | pub mod safety_checker;
  | ^^^^^^^^^^^^^^^^^^^^^^^
  |
  = help: to create the module `safety_checker`, create file "compiler/src/verification/safety_checker.rs" or "compiler/src/verification/safety_checker/mod.rs"
  = note: if there is a `mod safety_checker` elsewhere in the crate already, import it with `use crate::...` instead

error[E0583]: file not found for module `contracts`
 --> compiler/src/verification/mod.rs:7:1
  |
7 | pub mod contracts;
  | ^^^^^^^^^^^^^^^^^^
  |
  = help: to create the module `contracts`, create file "compiler/src/verification/contracts.rs" or "compiler/src/verification/contracts/mod.rs"
  = note: if there is a `mod contracts` elsewhere in the crate already, import it with `use crate::...` instead

error[E0583]: file not found for module `cuda`
 --> compiler/src/gpu/mod.rs:4:1
  |
4 | pub mod cuda;
  | ^^^^^^^^^^^^^
  |
  = help: to create the module `cuda`, create file "compiler/src/gpu/cuda.rs" or "compiler/src/gpu/cuda/mod.rs"
  = note: if there is a `mod cuda` elsewhere in the crate already, import it with `use crate::...` instead

error[E0583]: file not found for module `metal`
 --> compiler/src/gpu/mod.rs:5:1
  |
5 | pub mod metal;
  | ^^^^^^^^^^^^^^
  |
  = help: to create the module `metal`, create file "compiler/src/gpu/metal.rs" or "compiler/src/gpu/metal/mod.rs"
  = note: if there is a `mod metal` elsewhere in the crate already, import it with `use crate::...` instead

error[E0583]: file not found for module `vulkan`
 --> compiler/src/gpu/mod.rs:6:1
  |
6 | pub mod vulkan;
  | ^^^^^^^^^^^^^^^
  |
  = help: to create the module `vulkan`, create file "compiler/src/gpu/vulkan.rs" or "compiler/src/gpu/vulkan/mod.rs"
  = note: if there is a `mod vulkan` elsewhere in the crate already, import it with `use crate::...` instead

error[E0583]: file not found for module `kernel`
 --> compiler/src/gpu/mod.rs:7:1
  |
7 | pub mod kernel;
  | ^^^^^^^^^^^^^^^
  |
  = help: to create the module `kernel`, create file "compiler/src/gpu/kernel.rs" or "compiler/src/gpu/kernel/mod.rs"
  = note: if there is a `mod kernel` elsewhere in the crate already, import it with `use crate::...` instead

error[E0428]: the name `tests` is defined multiple times
   --> compiler/src/lexer/mod.rs:849:1
    |
  5 | mod tests;
    | ---------- previous definition of the module `tests` here
...
849 | mod tests {
    | ^^^^^^^^^ `tests` redefined here
    |
    = note: `tests` must be defined only once in the type namespace of this module

error[E0432]: unresolved import `crate::semantic::types`
  --> compiler/src/verification/mod.rs:10:22
   |
10 | use crate::semantic::types::Type;
   |                      ^^^^^ could not find `types` in `semantic`

error[E0432]: unresolved import `crate::semantic::types`
 --> compiler/src/consteval/mod.rs:5:22
  |
5 | use crate::semantic::types::Type;
  |                      ^^^^^ could not find `types` in `semantic`

error[E0432]: unresolved import `crate::error::CompilerError`
 --> compiler/src/codegen/llvm_backend.rs:6:28
  |
6 | use crate::error::{Result, CompilerError};
  |                            ^^^^^^^^^^^^^ no `CompilerError` in `error`

error[E0432]: unresolved import `crate::error::CompilerError`
 --> compiler/src/codegen/target.rs:3:28
  |
3 | use crate::error::{Result, CompilerError};
  |                            ^^^^^^^^^^^^^ no `CompilerError` in `error`

error[E0432]: unresolved import `crate::error::CompilerError`
 --> compiler/src/codegen/linker.rs:3:28
  |
3 | use crate::error::{Result, CompilerError};
  |                            ^^^^^^^^^^^^^ no `CompilerError` in `error`

error[E0432]: unresolved import `crate::error::CompilerError`
 --> compiler/src/codegen/target.rs:3:28
  |
3 | use crate::error::{Result, CompilerError};
  |                            ^^^^^^^^^^^^^ no `CompilerError` in `error`
  |
  = note: unresolved item `crate::codegen::llvm_backend::tests::CompilerError` exists but is inaccessible

error[E0432]: unresolved import `crate::error::CompilerError`
 --> compiler/src/codegen/linker.rs:3:28
  |
3 | use crate::error::{Result, CompilerError};
  |                            ^^^^^^^^^^^^^ no `CompilerError` in `error`
  |
  = note: unresolved item `crate::codegen::target::tests::CompilerError` exists but is inaccessible

error[E0532]: expected tuple struct or tuple variant, found unit variant `Constant::Null`
   --> compiler/src/codegen/llvm_backend.rs:129:13
    |
129 |             Constant::Null(ty) => format!("{} null", self.type_to_llvm(ty)),
    |             ^^^^^^^^^^^^^^^^^^ help: use this syntax instead: `Constant::Null`
    |
   ::: compiler/src/ir/ssa.rs:30:5
    |
 30 |     Null,
    |     ---- `Constant::Null` defined here

error[E0532]: expected tuple struct or tuple variant, found unit variant `Constant::Undef`
   --> compiler/src/codegen/llvm_backend.rs:130:13
    |
130 |             Constant::Undef(ty) => format!("{} undef", self.type_to_llvm(ty)),
    |             ^^^^^^^^^^^^^^^^^^^ help: use this syntax instead: `Constant::Undef`
    |
   ::: compiler/src/ir/ssa.rs:31:5
    |
 31 |     Undef,
    |     ----- `Constant::Undef` defined here

error[E0433]: failed to resolve: use of undeclared type `Pin`
  --> compiler/src/async_runtime/executor.rs:64:19
   |
64 |             match Pin::new(&mut future).poll(&waker) {
   |                   ^^^ use of undeclared type `Pin`
   |
help: consider importing this struct
   |
 4 + use std::pin::Pin;
   |

error[E0412]: cannot find type `Thread` in this scope
   --> compiler/src/async_runtime/executor.rs:112:18
    |
112 |     threads: Vec<Thread>,
    |                  ^^^^^^ not found in this scope
    |
help: consider importing this struct
    |
  4 + use std::thread::Thread;
    |

error[E0412]: cannot find type `Arc` in this scope
   --> compiler/src/async_runtime/executor.rs:113:17
    |
113 |     task_queue: Arc<Mutex<VecDeque<Box<dyn Task>>>>,
    |                 ^^^ not found in this scope
    |
help: consider importing this struct
    |
  4 + use std::sync::Arc;
    |

error[E0412]: cannot find type `Mutex` in this scope
   --> compiler/src/async_runtime/executor.rs:113:21
    |
113 |     task_queue: Arc<Mutex<VecDeque<Box<dyn Task>>>>,
    |                     ^^^^^ not found in this scope
    |
help: consider importing one of these structs
    |
  4 + use std::sync::Mutex;
    |
  4 + use std::sync::nonpoison::Mutex;
    |

error[E0433]: failed to resolve: use of undeclared type `Arc`
   --> compiler/src/async_runtime/executor.rs:118:26
    |
118 |         let task_queue = Arc::new(Mutex::new(VecDeque::new()));
    |                          ^^^ use of undeclared type `Arc`
    |
help: consider importing this struct
    |
  4 + use std::sync::Arc;
    |

error[E0433]: failed to resolve: use of undeclared type `Mutex`
   --> compiler/src/async_runtime/executor.rs:118:35
    |
118 |         let task_queue = Arc::new(Mutex::new(VecDeque::new()));
    |                                   ^^^^^ use of undeclared type `Mutex`
    |
help: consider importing one of these structs
    |
  4 + use std::sync::Mutex;
    |
  4 + use std::sync::nonpoison::Mutex;
    |

error[E0433]: failed to resolve: use of undeclared type `Thread`
   --> compiler/src/async_runtime/executor.rs:123:26
    |
123 |             let thread = Thread::spawn(move || {
    |                          ^^^^^^ use of undeclared type `Thread`
    |
help: consider importing this struct
    |
  4 + use std::thread::Thread;
    |

error[E0433]: failed to resolve: use of undeclared type `Thread`
   --> compiler/src/async_runtime/executor.rs:135:25
    |
135 |                         Thread::sleep(Duration::from_millis(10));
    |                         ^^^^^^ use of undeclared type `Thread`
    |
help: consider importing this struct
    |
  4 + use std::thread::Thread;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/verification/smt_solver.rs:113:77
    |
113 |                     _ => Err(Error::new("Unsupported literal type for SMT", Span::dummy())),
    |                                                                             ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/verification/smt_solver.rs:122:21
    |
122 |                     BinaryOp::Add => "+",
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/verification/smt_solver.rs:123:21
    |
123 |                     BinaryOp::Sub => "-",
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/verification/smt_solver.rs:124:21
    |
124 |                     BinaryOp::Mul => "*",
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/verification/smt_solver.rs:125:21
    |
125 |                     BinaryOp::Div => "div",
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/verification/smt_solver.rs:126:21
    |
126 |                     BinaryOp::Eq => "=",
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/verification/smt_solver.rs:127:21
    |
127 |                     BinaryOp::Ne => "distinct",
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/verification/smt_solver.rs:128:21
    |
128 |                     BinaryOp::Lt => "<",
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/verification/smt_solver.rs:129:21
    |
129 |                     BinaryOp::Le => "<=",
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/verification/smt_solver.rs:130:21
    |
130 |                     BinaryOp::Gt => ">",
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/verification/smt_solver.rs:131:21
    |
131 |                     BinaryOp::Ge => ">=",
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/verification/smt_solver.rs:132:21
    |
132 |                     BinaryOp::And => "and",
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/verification/smt_solver.rs:133:21
    |
133 |                     BinaryOp::Or => "or",
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/verification/smt_solver.rs:134:87
    |
134 |                     _ => return Err(Error::new("Unsupported binary operator for SMT", Span::dummy())),
    |                                                                                       ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0433]: failed to resolve: use of undeclared type `UnaryOp`
   --> compiler/src/verification/smt_solver.rs:143:21
    |
143 |                     UnaryOp::Not => "not",
    |                     ^^^^^^^ use of undeclared type `UnaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::UnaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `UnaryOp`
   --> compiler/src/verification/smt_solver.rs:144:21
    |
144 |                     UnaryOp::Neg => "-",
    |                     ^^^^^^^ use of undeclared type `UnaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::UnaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/verification/smt_solver.rs:145:86
    |
145 |                     _ => return Err(Error::new("Unsupported unary operator for SMT", Span::dummy())),
    |                                                                                      ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/verification/smt_solver.rs:150:72
    |
150 |             _ => Err(Error::new("Unsupported expression type for SMT", Span::dummy())),
    |                                                                        ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/verification/smt_solver.rs:195:83
    |
195 |             .map_err(|e| Error::new(format!("Failed to spawn SMT solver: {}", e), Span::dummy()))?;
    |                                                                                   ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/verification/smt_solver.rs:199:90
    |
199 |                 .map_err(|e| Error::new(format!("Failed to write to SMT solver: {}", e), Span::dummy()))?;
    |                                                                                          ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/verification/smt_solver.rs:203:89
    |
203 |             .map_err(|e| Error::new(format!("Failed to read SMT solver output: {}", e), Span::dummy()))?;
    |                                                                                         ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0412]: cannot find type `BinaryOp` in this scope
   --> compiler/src/gpu/mod.rs:285:34
    |
285 |     fn binary_op_str(&self, op: &BinaryOp) -> &str {
    |                                  ^^^^^^^^ not found in this scope
    |
help: consider importing this enum
    |
  9 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/gpu/mod.rs:287:13
    |
287 |             BinaryOp::Add => "+",
    |             ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  9 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/gpu/mod.rs:288:13
    |
288 |             BinaryOp::Sub => "-",
    |             ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  9 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/gpu/mod.rs:289:13
    |
289 |             BinaryOp::Mul => "*",
    |             ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  9 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/gpu/mod.rs:290:13
    |
290 |             BinaryOp::Div => "/",
    |             ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  9 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/gpu/mod.rs:291:13
    |
291 |             BinaryOp::Mod => "%",
    |             ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  9 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/gpu/mod.rs:292:13
    |
292 |             BinaryOp::Eq => "==",
    |             ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  9 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/gpu/mod.rs:293:13
    |
293 |             BinaryOp::Ne => "!=",
    |             ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  9 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/gpu/mod.rs:294:13
    |
294 |             BinaryOp::Lt => "<",
    |             ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  9 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/gpu/mod.rs:295:13
    |
295 |             BinaryOp::Le => "<=",
    |             ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  9 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/gpu/mod.rs:296:13
    |
296 |             BinaryOp::Gt => ">",
    |             ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  9 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/gpu/mod.rs:297:13
    |
297 |             BinaryOp::Ge => ">=",
    |             ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  9 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
  --> compiler/src/consteval/mod.rs:68:25
   |
68 |                         Span::dummy()
   |                         ^^^^ use of undeclared type `Span`
   |
help: consider importing this struct through its public re-export
   |
 4 + use crate::prelude::Span;
   |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/consteval/mod.rs:108:17
    |
108 |                 Span::dummy()
    |                 ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0412]: cannot find type `BinaryOp` in this scope
   --> compiler/src/consteval/mod.rs:123:34
    |
123 |     fn eval_binary_op(&self, op: BinaryOp, left: &ConstValue, right: &ConstValue) -> Result<ConstValue> {
    |                                  ^^^^^^^^ not found in this scope
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:127:21
    |
127 |                     BinaryOp::Add => ConstValue::Int(l + r),
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:128:21
    |
128 |                     BinaryOp::Sub => ConstValue::Int(l - r),
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:129:21
    |
129 |                     BinaryOp::Mul => ConstValue::Int(l * r),
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:130:21
    |
130 |                     BinaryOp::Div => {
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/consteval/mod.rs:132:71
    |
132 | ...                   return Err(Error::new("Division by zero", Span::dummy()));
    |                                                                 ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:136:21
    |
136 |                     BinaryOp::Mod => ConstValue::Int(l % r),
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:137:21
    |
137 |                     BinaryOp::Eq => ConstValue::Bool(l == r),
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:138:21
    |
138 |                     BinaryOp::Ne => ConstValue::Bool(l != r),
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:139:21
    |
139 |                     BinaryOp::Lt => ConstValue::Bool(l < r),
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:140:21
    |
140 |                     BinaryOp::Le => ConstValue::Bool(l <= r),
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:141:21
    |
141 |                     BinaryOp::Gt => ConstValue::Bool(l > r),
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:142:21
    |
142 |                     BinaryOp::Ge => ConstValue::Bool(l >= r),
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:143:21
    |
143 |                     BinaryOp::BitAnd => ConstValue::Int(l & r),
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:144:21
    |
144 |                     BinaryOp::BitOr => ConstValue::Int(l | r),
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:145:21
    |
145 |                     BinaryOp::BitXor => ConstValue::Int(l ^ r),
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:146:21
    |
146 |                     BinaryOp::Shl => ConstValue::Int(l << r),
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:147:21
    |
147 |                     BinaryOp::Shr => ConstValue::Int(l >> r),
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/consteval/mod.rs:148:80
    |
148 |                     _ => return Err(Error::new("Unsupported binary operation", Span::dummy())),
    |                                                                                ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:155:21
    |
155 |                     BinaryOp::Add => ConstValue::Float(l + r),
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:156:21
    |
156 |                     BinaryOp::Sub => ConstValue::Float(l - r),
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:157:21
    |
157 |                     BinaryOp::Mul => ConstValue::Float(l * r),
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:158:21
    |
158 |                     BinaryOp::Div => ConstValue::Float(l / r),
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:159:21
    |
159 |                     BinaryOp::Eq => ConstValue::Bool(l == r),
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:160:21
    |
160 |                     BinaryOp::Ne => ConstValue::Bool(l != r),
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:161:21
    |
161 |                     BinaryOp::Lt => ConstValue::Bool(l < r),
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:162:21
    |
162 |                     BinaryOp::Le => ConstValue::Bool(l <= r),
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:163:21
    |
163 |                     BinaryOp::Gt => ConstValue::Bool(l > r),
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:164:21
    |
164 |                     BinaryOp::Ge => ConstValue::Bool(l >= r),
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/consteval/mod.rs:165:80
    |
165 |                     _ => return Err(Error::new("Unsupported binary operation", Span::dummy())),
    |                                                                                ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:172:21
    |
172 |                     BinaryOp::And => ConstValue::Bool(*l && *r),
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:173:21
    |
173 |                     BinaryOp::Or => ConstValue::Bool(*l || *r),
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:174:21
    |
174 |                     BinaryOp::Eq => ConstValue::Bool(l == r),
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:175:21
    |
175 |                     BinaryOp::Ne => ConstValue::Bool(l != r),
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/consteval/mod.rs:176:80
    |
176 |                     _ => return Err(Error::new("Unsupported binary operation", Span::dummy())),
    |                                                                                ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/consteval/mod.rs:181:70
    |
181 |             _ => Err(Error::new("Type mismatch in binary operation", Span::dummy())),
    |                                                                      ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0412]: cannot find type `UnaryOp` in this scope
   --> compiler/src/consteval/mod.rs:185:33
    |
185 |     fn eval_unary_op(&self, op: UnaryOp, val: &ConstValue) -> Result<ConstValue> {
    |                                 ^^^^^^^ not found in this scope
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::UnaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `UnaryOp`
   --> compiler/src/consteval/mod.rs:189:21
    |
189 |                     UnaryOp::Neg => ConstValue::Int(-n),
    |                     ^^^^^^^ use of undeclared type `UnaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::UnaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `UnaryOp`
   --> compiler/src/consteval/mod.rs:190:21
    |
190 |                     UnaryOp::Not => ConstValue::Bool(*n == 0),
    |                     ^^^^^^^ use of undeclared type `UnaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::UnaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `UnaryOp`
   --> compiler/src/consteval/mod.rs:191:21
    |
191 |                     UnaryOp::BitNot => ConstValue::Int(!n),
    |                     ^^^^^^^ use of undeclared type `UnaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::UnaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/consteval/mod.rs:192:79
    |
192 |                     _ => return Err(Error::new("Unsupported unary operation", Span::dummy())),
    |                                                                               ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0433]: failed to resolve: use of undeclared type `UnaryOp`
   --> compiler/src/consteval/mod.rs:199:21
    |
199 |                     UnaryOp::Neg => ConstValue::Float(-f),
    |                     ^^^^^^^ use of undeclared type `UnaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::UnaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/consteval/mod.rs:200:79
    |
200 |                     _ => return Err(Error::new("Unsupported unary operation", Span::dummy())),
    |                                                                               ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0433]: failed to resolve: use of undeclared type `UnaryOp`
   --> compiler/src/consteval/mod.rs:207:21
    |
207 |                     UnaryOp::Not => ConstValue::Bool(!b),
    |                     ^^^^^^^ use of undeclared type `UnaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::UnaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/consteval/mod.rs:208:79
    |
208 |                     _ => return Err(Error::new("Unsupported unary operation", Span::dummy())),
    |                                                                               ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/consteval/mod.rs:213:69
    |
213 |             _ => Err(Error::new("Type mismatch in unary operation", Span::dummy())),
    |                                                                     ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/consteval/mod.rs:221:65
    |
221 |             _ => return Err(Error::new("Invalid function call", Span::dummy())),
    |                                                                 ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/consteval/mod.rs:239:17
    |
239 |                 Span::dummy()
    |                 ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/consteval/mod.rs:246:61
    |
246 |             return Err(Error::new("abs expects 1 argument", Span::dummy()));
    |                                                             ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/consteval/mod.rs:252:65
    |
252 |             _ => Err(Error::new("abs expects numeric argument", Span::dummy())),
    |                                                                 ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/consteval/mod.rs:258:62
    |
258 |             return Err(Error::new("min expects 2 arguments", Span::dummy()));
    |                                                              ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/consteval/mod.rs:264:66
    |
264 |             _ => Err(Error::new("min expects numeric arguments", Span::dummy())),
    |                                                                  ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/consteval/mod.rs:270:62
    |
270 |             return Err(Error::new("max expects 2 arguments", Span::dummy()));
    |                                                              ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/consteval/mod.rs:276:66
    |
276 |             _ => Err(Error::new("max expects numeric arguments", Span::dummy())),
    |                                                                  ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/consteval/mod.rs:282:62
    |
282 |             return Err(Error::new("pow expects 2 arguments", Span::dummy()));
    |                                                              ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/consteval/mod.rs:291:80
    |
291 |                     return Err(Error::new("Negative exponent for integer pow", Span::dummy()));
    |                                                                                ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/consteval/mod.rs:295:66
    |
295 |             _ => Err(Error::new("pow expects numeric arguments", Span::dummy())),
    |                                                                  ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/consteval/mod.rs:301:62
    |
301 |             return Err(Error::new("sqrt expects 1 argument", Span::dummy()));
    |                                                              ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/consteval/mod.rs:307:70
    |
307 |                     return Err(Error::new("sqrt of negative number", Span::dummy()));
    |                                                                      ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/consteval/mod.rs:311:64
    |
311 |             _ => Err(Error::new("sqrt expects float argument", Span::dummy())),
    |                                                                ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0412]: cannot find type `BinaryOp` in this scope
  --> compiler/src/plugin/api.rs:60:40
   |
60 |     pub fn create_binary_op(&self, op: BinaryOp, left: Expr, right: Expr) -> Expr {
   |                                        ^^^^^^^^ not found in this scope
   |
help: consider importing this enum
   |
 4 + use crate::ir::instructions::BinaryOp;
   |

error[E0412]: cannot find type `Span` in this scope
   --> compiler/src/plugin/mod.rs:151:19
    |
151 |     pub location: Span,
    |                   ^^^^ not found in this scope
    |
help: consider importing this struct through its public re-export
    |
  9 + use crate::prelude::Span;
    |

error[E0659]: `Function` is ambiguous
  --> compiler/src/gpu/mod.rs:78:42
   |
78 |     pub fn generate_kernel(&self, func: &Function) -> Result<String> {
   |                                          ^^^^^^^^ ambiguous name
   |
   = note: ambiguous because of multiple glob imports of a name in the same module
note: `Function` could refer to the struct imported here
  --> compiler/src/gpu/mod.rs:9:5
   |
 9 | use crate::parser::ast::*;
   |     ^^^^^^^^^^^^^^^^^^^^^
   = help: consider adding an explicit import of `Function` to disambiguate
note: `Function` could also refer to the struct imported here
  --> compiler/src/gpu/mod.rs:10:5
   |
10 | use crate::ir::ssa::*;
   |     ^^^^^^^^^^^^^^^^^
   = help: consider adding an explicit import of `Function` to disambiguate

error[E0659]: `Function` is ambiguous
  --> compiler/src/gpu/mod.rs:87:43
   |
87 |     fn generate_cuda_kernel(&self, func: &Function) -> Result<String> {
   |                                           ^^^^^^^^ ambiguous name
   |
   = note: ambiguous because of multiple glob imports of a name in the same module
note: `Function` could refer to the struct imported here
  --> compiler/src/gpu/mod.rs:9:5
   |
 9 | use crate::parser::ast::*;
   |     ^^^^^^^^^^^^^^^^^^^^^
   = help: consider adding an explicit import of `Function` to disambiguate
note: `Function` could also refer to the struct imported here
  --> compiler/src/gpu/mod.rs:10:5
   |
10 | use crate::ir::ssa::*;
   |     ^^^^^^^^^^^^^^^^^
   = help: consider adding an explicit import of `Function` to disambiguate

error[E0659]: `Function` is ambiguous
   --> compiler/src/gpu/mod.rs:120:44
    |
120 |     fn generate_metal_kernel(&self, func: &Function) -> Result<String> {
    |                                            ^^^^^^^^ ambiguous name
    |
    = note: ambiguous because of multiple glob imports of a name in the same module
note: `Function` could refer to the struct imported here
   --> compiler/src/gpu/mod.rs:9:5
    |
  9 | use crate::parser::ast::*;
    |     ^^^^^^^^^^^^^^^^^^^^^
    = help: consider adding an explicit import of `Function` to disambiguate
note: `Function` could also refer to the struct imported here
   --> compiler/src/gpu/mod.rs:10:5
    |
 10 | use crate::ir::ssa::*;
    |     ^^^^^^^^^^^^^^^^^
    = help: consider adding an explicit import of `Function` to disambiguate

error[E0659]: `Function` is ambiguous
   --> compiler/src/gpu/mod.rs:157:45
    |
157 |     fn generate_vulkan_kernel(&self, func: &Function) -> Result<String> {
    |                                             ^^^^^^^^ ambiguous name
    |
    = note: ambiguous because of multiple glob imports of a name in the same module
note: `Function` could refer to the struct imported here
   --> compiler/src/gpu/mod.rs:9:5
    |
  9 | use crate::parser::ast::*;
    |     ^^^^^^^^^^^^^^^^^^^^^
    = help: consider adding an explicit import of `Function` to disambiguate
note: `Function` could also refer to the struct imported here
   --> compiler/src/gpu/mod.rs:10:5
    |
 10 | use crate::ir::ssa::*;
    |     ^^^^^^^^^^^^^^^^^
    = help: consider adding an explicit import of `Function` to disambiguate

error[E0659]: `Function` is ambiguous
   --> compiler/src/gpu/mod.rs:193:45
    |
193 |     fn generate_opencl_kernel(&self, func: &Function) -> Result<String> {
    |                                             ^^^^^^^^ ambiguous name
    |
    = note: ambiguous because of multiple glob imports of a name in the same module
note: `Function` could refer to the struct imported here
   --> compiler/src/gpu/mod.rs:9:5
    |
  9 | use crate::parser::ast::*;
    |     ^^^^^^^^^^^^^^^^^^^^^
    = help: consider adding an explicit import of `Function` to disambiguate
note: `Function` could also refer to the struct imported here
   --> compiler/src/gpu/mod.rs:10:5
    |
 10 | use crate::ir::ssa::*;
    |     ^^^^^^^^^^^^^^^^^
    = help: consider adding an explicit import of `Function` to disambiguate

error[E0659]: `Function` is ambiguous
   --> compiler/src/gpu/mod.rs:227:43
    |
227 |     fn generate_kernel_body(&self, func: &Function) -> Result<String> {
    |                                           ^^^^^^^^ ambiguous name
    |
    = note: ambiguous because of multiple glob imports of a name in the same module
note: `Function` could refer to the struct imported here
   --> compiler/src/gpu/mod.rs:9:5
    |
  9 | use crate::parser::ast::*;
    |     ^^^^^^^^^^^^^^^^^^^^^
    = help: consider adding an explicit import of `Function` to disambiguate
note: `Function` could also refer to the struct imported here
   --> compiler/src/gpu/mod.rs:10:5
    |
 10 | use crate::ir::ssa::*;
    |     ^^^^^^^^^^^^^^^^^
    = help: consider adding an explicit import of `Function` to disambiguate

warning: unused import: `TypeVar`
 --> compiler/src/semantic/type_checker.rs:6:69
  |
6 | use super::type_env::{TypeEnv, InferredType, Substitution, Unifier, TypeVar};
  |                                                                     ^^^^^^^
  |
  = note: `#[warn(unused_imports)]` (part of `#[warn(unused)]`) on by default

warning: unused import: `BasicBlock`
 --> compiler/src/ir/builder.rs:5:42
  |
5 | use super::ssa::{Function as IrFunction, BasicBlock, Value, ValueId, Constant, Module};
  |                                          ^^^^^^^^^^

warning: unused import: `crate::ir::types::IrType`
 --> compiler/src/optimizer/constant_folding.rs:5:5
  |
5 | use crate::ir::types::IrType;
  |     ^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `ValueId`
 --> compiler/src/optimizer/inline.rs:3:54
  |
3 | use crate::ir::ssa::{Module, Function as IrFunction, ValueId};
  |                                                      ^^^^^^^

warning: unused import: `Path`
 --> compiler/src/codegen/linker.rs:5:17
  |
5 | use std::path::{Path, PathBuf};
  |                 ^^^^

warning: unused import: `crate::parser::ast::*`
 --> compiler/src/macro_system/mod.rs:9:5
  |
9 | use crate::parser::ast::*;
  |     ^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `std::prelude::*`
 --> compiler/src/async_runtime/mod.rs:9:5
  |
9 | use std::prelude::*;
  |     ^^^^^^^^^^^^^^^

warning: unused import: `Error`
  --> compiler/src/verification/mod.rs:11:20
   |
11 | use crate::error::{Error, Result};
   |                    ^^^^^

warning: unused import: `std::collections::HashMap`
  --> compiler/src/verification/mod.rs:12:5
   |
12 | use std::collections::HashMap;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `crate::ir::ssa::*`
  --> compiler/src/gpu/mod.rs:10:5
   |
10 | use crate::ir::ssa::*;
   |     ^^^^^^^^^^^^^^^^^

warning: unused import: `Error`
  --> compiler/src/gpu/mod.rs:11:20
   |
11 | use crate::error::{Error, Result};
   |                    ^^^^^

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/verification/mod.rs:364:19
    |
364 |             span: Span::dummy(),
    |                   ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
344 +     use crate::prelude::Span;
    |

error[E0277]: `F1` is not a future
   --> compiler/src/async_runtime/mod.rs:113:17
    |
113 |     let r1 = f1.await;
    |                 ^^^^^ `F1` is not a future
    |
    = note: F1 must be a future or must implement `IntoFuture` to be awaited
    = note: required for `F1` to implement `IntoFuture`
help: remove the `.await`
    |
113 -     let r1 = f1.await;
113 +     let r1 = f1;
    |
help: consider further restricting type parameter `F1` with trait `Future`
    |
110 |     F1: Future + std::future::Future,
    |                +++++++++++++++++++++

error[E0277]: `F2` is not a future
   --> compiler/src/async_runtime/mod.rs:114:17
    |
114 |     let r2 = f2.await;
    |                 ^^^^^ `F2` is not a future
    |
    = note: F2 must be a future or must implement `IntoFuture` to be awaited
    = note: required for `F2` to implement `IntoFuture`
help: remove the `.await`
    |
114 -     let r2 = f2.await;
114 +     let r2 = f2;
    |
help: consider further restricting type parameter `F2` with trait `Future`
    |
111 |     F2: Future + std::future::Future,
    |                +++++++++++++++++++++

error[E0023]: this pattern has 1 field, but the corresponding tuple variant has 2 fields
  --> compiler/src/lexer/token.rs:66:35
   |
26 |     IntLiteral(String, Option<String>),   // value, optional suffix (i32, u64, etc.)
   |                ------  -------------- tuple variant has 2 fields
...
66 |             TokenKind::IntLiteral(_) | TokenKind::FloatLiteral(_) |
   |                                   ^ expected 2 fields, found 1
   |
help: use `_` to explicitly ignore each field
   |
66 |             TokenKind::IntLiteral(_, _) | TokenKind::FloatLiteral(_) |
   |                                    +++
help: use `..` to ignore all fields
   |
66 -             TokenKind::IntLiteral(_) | TokenKind::FloatLiteral(_) |
66 +             TokenKind::IntLiteral(..) | TokenKind::FloatLiteral(_) |
   |

error[E0023]: this pattern has 1 field, but the corresponding tuple variant has 2 fields
  --> compiler/src/lexer/token.rs:66:64
   |
27 |     FloatLiteral(String, Option<String>), // value, optional suffix (f32, f64)
   |                  ------  -------------- tuple variant has 2 fields
...
66 |             TokenKind::IntLiteral(_) | TokenKind::FloatLiteral(_) |
   |                                                                ^ expected 2 fields, found 1
   |
help: use `_` to explicitly ignore each field
   |
66 |             TokenKind::IntLiteral(_) | TokenKind::FloatLiteral(_, _) |
   |                                                                 +++
help: use `..` to ignore all fields
   |
66 -             TokenKind::IntLiteral(_) | TokenKind::FloatLiteral(_) |
66 +             TokenKind::IntLiteral(_) | TokenKind::FloatLiteral(..) |
   |

error[E0308]: mismatched types
   --> compiler/src/lexer/mod.rs:689:13
    |
682 |     fn lex_slash(&mut self) -> Result<TokenKind> {
    |                                ----------------- expected `std::result::Result<TokenKind, error::Error>` because of return type
...
689 |             self.next_token() // Skip comment and get next token
    |             ^^^^^^^^^^^^^^^^^ expected `Result<TokenKind, Error>`, found `Result<Token, Error>`
    |
    = note: expected enum `std::result::Result<TokenKind, _>`
               found enum `std::result::Result<Token, _>`

error[E0308]: mismatched types
   --> compiler/src/lexer/mod.rs:698:32
    |
682 |     fn lex_slash(&mut self) -> Result<TokenKind> {
    |                                ----------------- expected `std::result::Result<TokenKind, error::Error>` because of return type
...
698 |                         return self.next_token(); // Skip comment
    |                                ^^^^^^^^^^^^^^^^^ expected `Result<TokenKind, Error>`, found `Result<Token, Error>`
    |
    = note: expected enum `std::result::Result<TokenKind, _>`
               found enum `std::result::Result<Token, _>`

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/consteval/mod.rs:336:19
    |
336 |             span: Span::dummy(),
    |                   ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
328 +     use crate::prelude::Span;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:348:17
    |
348 |             op: BinaryOp::Add,
    |                 ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
328 +     use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/consteval/mod.rs:351:23
    |
351 |                 span: Span::dummy(),
    |                       ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
328 +     use crate::prelude::Span;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/consteval/mod.rs:355:23
    |
355 |                 span: Span::dummy(),
    |                       ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
328 +     use crate::prelude::Span;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/consteval/mod.rs:357:19
    |
357 |             span: Span::dummy(),
    |                   ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
328 +     use crate::prelude::Span;
    |

error[E0599]: no function or associated item named `default` found for struct `span::Span` in the current scope
  --> compiler/src/semantic/resolver.rs:66:19
   |
66 |             Span::default(),
   |                   ^^^^^^^ function or associated item not found in `span::Span`
   |
  ::: compiler/src/span.rs:31:1
   |
31 | pub struct Span {
   | --------------- function or associated item `default` not found for this struct
   |
note: if you're trying to build a new `span::Span`, consider using `span::Span::new` which returns `span::Span`
  --> compiler/src/span.rs:37:5
   |
37 |     pub fn new(start: Position, end: Position) -> Self {
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   = help: items from traits can only be used if the trait is implemented and in scope
   = note: the following trait defines an item `default`, perhaps you need to implement it:
           candidate #1: `Default`

error[E0599]: no variant or associated item named `DuplicateSymbol` found for enum `error::ErrorKind` in the current scope
  --> compiler/src/semantic/resolver.rs:71:50
   |
71 |             self.add_error(Error::new(ErrorKind::DuplicateSymbol, e));
   |                                                  ^^^^^^^^^^^^^^^ variant or associated item not found in `error::ErrorKind`
   |
  ::: compiler/src/error.rs:18:1
   |
18 | pub enum ErrorKind {
   | ------------------ variant or associated item `DuplicateSymbol` not found for this enum

error[E0599]: no function or associated item named `default` found for struct `span::Span` in the current scope
  --> compiler/src/semantic/resolver.rs:84:23
   |
84 |                 Span::default(),
   |                       ^^^^^^^ function or associated item not found in `span::Span`
   |
  ::: compiler/src/span.rs:31:1
   |
31 | pub struct Span {
   | --------------- function or associated item `default` not found for this struct
   |
note: if you're trying to build a new `span::Span`, consider using `span::Span::new` which returns `span::Span`
  --> compiler/src/span.rs:37:5
   |
37 |     pub fn new(start: Position, end: Position) -> Self {
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   = help: items from traits can only be used if the trait is implemented and in scope
   = note: the following trait defines an item `default`, perhaps you need to implement it:
           candidate #1: `Default`

error[E0599]: no variant or associated item named `DuplicateSymbol` found for enum `error::ErrorKind` in the current scope
  --> compiler/src/semantic/resolver.rs:89:54
   |
89 |                 self.add_error(Error::new(ErrorKind::DuplicateSymbol, e));
   |                                                      ^^^^^^^^^^^^^^^ variant or associated item not found in `error::ErrorKind`
   |
  ::: compiler/src/error.rs:18:1
   |
18 | pub enum ErrorKind {
   | ------------------ variant or associated item `DuplicateSymbol` not found for this enum

error[E0599]: no function or associated item named `default` found for struct `span::Span` in the current scope
  --> compiler/src/semantic/resolver.rs:99:23
   |
99 |                 Span::default(),
   |                       ^^^^^^^ function or associated item not found in `span::Span`
   |
  ::: compiler/src/span.rs:31:1
   |
31 | pub struct Span {
   | --------------- function or associated item `default` not found for this struct
   |
note: if you're trying to build a new `span::Span`, consider using `span::Span::new` which returns `span::Span`
  --> compiler/src/span.rs:37:5
   |
37 |     pub fn new(start: Position, end: Position) -> Self {
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   = help: items from traits can only be used if the trait is implemented and in scope
   = note: the following trait defines an item `default`, perhaps you need to implement it:
           candidate #1: `Default`

error[E0599]: no variant or associated item named `DuplicateSymbol` found for enum `error::ErrorKind` in the current scope
   --> compiler/src/semantic/resolver.rs:104:54
    |
104 |                 self.add_error(Error::new(ErrorKind::DuplicateSymbol, e));
    |                                                      ^^^^^^^^^^^^^^^ variant or associated item not found in `error::ErrorKind`
    |
   ::: compiler/src/error.rs:18:1
    |
 18 | pub enum ErrorKind {
    | ------------------ variant or associated item `DuplicateSymbol` not found for this enum

error[E0599]: no function or associated item named `default` found for struct `span::Span` in the current scope
   --> compiler/src/semantic/resolver.rs:122:19
    |
122 |             Span::default(),
    |                   ^^^^^^^ function or associated item not found in `span::Span`
    |
   ::: compiler/src/span.rs:31:1
    |
 31 | pub struct Span {
    | --------------- function or associated item `default` not found for this struct
    |
note: if you're trying to build a new `span::Span`, consider using `span::Span::new` which returns `span::Span`
   --> compiler/src/span.rs:37:5
    |
 37 |     pub fn new(start: Position, end: Position) -> Self {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    = help: items from traits can only be used if the trait is implemented and in scope
    = note: the following trait defines an item `default`, perhaps you need to implement it:
            candidate #1: `Default`

error[E0599]: no variant or associated item named `DuplicateSymbol` found for enum `error::ErrorKind` in the current scope
   --> compiler/src/semantic/resolver.rs:127:50
    |
127 |             self.add_error(Error::new(ErrorKind::DuplicateSymbol, e));
    |                                                  ^^^^^^^^^^^^^^^ variant or associated item not found in `error::ErrorKind`
    |
   ::: compiler/src/error.rs:18:1
    |
 18 | pub enum ErrorKind {
    | ------------------ variant or associated item `DuplicateSymbol` not found for this enum

warning: unused import: `crate::ir::ssa::ValueId`
   --> compiler/src/optimizer/constant_folding.rs:225:9
    |
225 |     use crate::ir::ssa::ValueId;
    |         ^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `BasicBlock`
   --> compiler/src/optimizer/dead_code.rs:117:26
    |
117 |     use crate::ir::ssa::{BasicBlock, ValueId};
    |                          ^^^^^^^^^^

error[E0599]: no function or associated item named `default` found for struct `span::Span` in the current scope
   --> compiler/src/semantic/resolver.rs:136:19
    |
136 |             Span::default(),
    |                   ^^^^^^^ function or associated item not found in `span::Span`
    |
   ::: compiler/src/span.rs:31:1
    |
 31 | pub struct Span {
    | --------------- function or associated item `default` not found for this struct
    |
note: if you're trying to build a new `span::Span`, consider using `span::Span::new` which returns `span::Span`
   --> compiler/src/span.rs:37:5
    |
 37 |     pub fn new(start: Position, end: Position) -> Self {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    = help: items from traits can only be used if the trait is implemented and in scope
    = note: the following trait defines an item `default`, perhaps you need to implement it:
            candidate #1: `Default`

error[E0599]: no variant or associated item named `DuplicateSymbol` found for enum `error::ErrorKind` in the current scope
   --> compiler/src/semantic/resolver.rs:141:50
    |
141 |             self.add_error(Error::new(ErrorKind::DuplicateSymbol, e));
    |                                                  ^^^^^^^^^^^^^^^ variant or associated item not found in `error::ErrorKind`
    |
   ::: compiler/src/error.rs:18:1
    |
 18 | pub enum ErrorKind {
    | ------------------ variant or associated item `DuplicateSymbol` not found for this enum

error[E0599]: no function or associated item named `default` found for struct `span::Span` in the current scope
   --> compiler/src/semantic/resolver.rs:151:23
    |
151 |                 Span::default(),
    |                       ^^^^^^^ function or associated item not found in `span::Span`
    |
   ::: compiler/src/span.rs:31:1
    |
 31 | pub struct Span {
    | --------------- function or associated item `default` not found for this struct
    |
note: if you're trying to build a new `span::Span`, consider using `span::Span::new` which returns `span::Span`
   --> compiler/src/span.rs:37:5
    |
 37 |     pub fn new(start: Position, end: Position) -> Self {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    = help: items from traits can only be used if the trait is implemented and in scope
    = note: the following trait defines an item `default`, perhaps you need to implement it:
            candidate #1: `Default`

error[E0599]: no variant or associated item named `DuplicateSymbol` found for enum `error::ErrorKind` in the current scope
   --> compiler/src/semantic/resolver.rs:156:54
    |
156 |                 self.add_error(Error::new(ErrorKind::DuplicateSymbol, e));
    |                                                      ^^^^^^^^^^^^^^^ variant or associated item not found in `error::ErrorKind`
    |
   ::: compiler/src/error.rs:18:1
    |
 18 | pub enum ErrorKind {
    | ------------------ variant or associated item `DuplicateSymbol` not found for this enum

error[E0599]: no function or associated item named `default` found for struct `span::Span` in the current scope
   --> compiler/src/semantic/resolver.rs:166:19
    |
166 |             Span::default(),
    |                   ^^^^^^^ function or associated item not found in `span::Span`
    |
   ::: compiler/src/span.rs:31:1
    |
 31 | pub struct Span {
    | --------------- function or associated item `default` not found for this struct
    |
note: if you're trying to build a new `span::Span`, consider using `span::Span::new` which returns `span::Span`
   --> compiler/src/span.rs:37:5
    |
 37 |     pub fn new(start: Position, end: Position) -> Self {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    = help: items from traits can only be used if the trait is implemented and in scope
    = note: the following trait defines an item `default`, perhaps you need to implement it:
            candidate #1: `Default`

error[E0599]: no variant or associated item named `DuplicateSymbol` found for enum `error::ErrorKind` in the current scope
   --> compiler/src/semantic/resolver.rs:171:50
    |
171 |             self.add_error(Error::new(ErrorKind::DuplicateSymbol, e));
    |                                                  ^^^^^^^^^^^^^^^ variant or associated item not found in `error::ErrorKind`
    |
   ::: compiler/src/error.rs:18:1
    |
 18 | pub enum ErrorKind {
    | ------------------ variant or associated item `DuplicateSymbol` not found for this enum

error[E0599]: no function or associated item named `default` found for struct `span::Span` in the current scope
   --> compiler/src/semantic/resolver.rs:185:23
    |
185 |                 Span::default(),
    |                       ^^^^^^^ function or associated item not found in `span::Span`
    |
   ::: compiler/src/span.rs:31:1
    |
 31 | pub struct Span {
    | --------------- function or associated item `default` not found for this struct
    |
note: if you're trying to build a new `span::Span`, consider using `span::Span::new` which returns `span::Span`
   --> compiler/src/span.rs:37:5
    |
 37 |     pub fn new(start: Position, end: Position) -> Self {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    = help: items from traits can only be used if the trait is implemented and in scope
    = note: the following trait defines an item `default`, perhaps you need to implement it:
            candidate #1: `Default`

error[E0599]: no variant or associated item named `DuplicateSymbol` found for enum `error::ErrorKind` in the current scope
   --> compiler/src/semantic/resolver.rs:190:54
    |
190 |                 self.add_error(Error::new(ErrorKind::DuplicateSymbol, e));
    |                                                      ^^^^^^^^^^^^^^^ variant or associated item not found in `error::ErrorKind`
    |
   ::: compiler/src/error.rs:18:1
    |
 18 | pub enum ErrorKind {
    | ------------------ variant or associated item `DuplicateSymbol` not found for this enum

error[E0599]: no function or associated item named `default` found for struct `span::Span` in the current scope
   --> compiler/src/semantic/resolver.rs:217:19
    |
217 |             Span::default(),
    |                   ^^^^^^^ function or associated item not found in `span::Span`
    |
   ::: compiler/src/span.rs:31:1
    |
 31 | pub struct Span {
    | --------------- function or associated item `default` not found for this struct
    |
note: if you're trying to build a new `span::Span`, consider using `span::Span::new` which returns `span::Span`
   --> compiler/src/span.rs:37:5
    |
 37 |     pub fn new(start: Position, end: Position) -> Self {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    = help: items from traits can only be used if the trait is implemented and in scope
    = note: the following trait defines an item `default`, perhaps you need to implement it:
            candidate #1: `Default`

error[E0599]: no variant or associated item named `DuplicateSymbol` found for enum `error::ErrorKind` in the current scope
   --> compiler/src/semantic/resolver.rs:222:50
    |
222 |             self.add_error(Error::new(ErrorKind::DuplicateSymbol, e));
    |                                                  ^^^^^^^^^^^^^^^ variant or associated item not found in `error::ErrorKind`
    |
   ::: compiler/src/error.rs:18:1
    |
 18 | pub enum ErrorKind {
    | ------------------ variant or associated item `DuplicateSymbol` not found for this enum

error[E0599]: no function or associated item named `default` found for struct `span::Span` in the current scope
   --> compiler/src/semantic/resolver.rs:250:27
    |
250 |                     Span::default(),
    |                           ^^^^^^^ function or associated item not found in `span::Span`
    |
   ::: compiler/src/span.rs:31:1
    |
 31 | pub struct Span {
    | --------------- function or associated item `default` not found for this struct
    |
note: if you're trying to build a new `span::Span`, consider using `span::Span::new` which returns `span::Span`
   --> compiler/src/span.rs:37:5
    |
 37 |     pub fn new(start: Position, end: Position) -> Self {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    = help: items from traits can only be used if the trait is implemented and in scope
    = note: the following trait defines an item `default`, perhaps you need to implement it:
            candidate #1: `Default`

error[E0599]: no variant or associated item named `DuplicateSymbol` found for enum `error::ErrorKind` in the current scope
   --> compiler/src/semantic/resolver.rs:259:58
    |
259 |                     self.add_error(Error::new(ErrorKind::DuplicateSymbol, e));
    |                                                          ^^^^^^^^^^^^^^^ variant or associated item not found in `error::ErrorKind`
    |
   ::: compiler/src/error.rs:18:1
    |
 18 | pub enum ErrorKind {
    | ------------------ variant or associated item `DuplicateSymbol` not found for this enum

error[E0599]: no function or associated item named `default` found for struct `span::Span` in the current scope
   --> compiler/src/semantic/resolver.rs:357:27
    |
357 |                     Span::default(),
    |                           ^^^^^^^ function or associated item not found in `span::Span`
    |
   ::: compiler/src/span.rs:31:1
    |
 31 | pub struct Span {
    | --------------- function or associated item `default` not found for this struct
    |
note: if you're trying to build a new `span::Span`, consider using `span::Span::new` which returns `span::Span`
   --> compiler/src/span.rs:37:5
    |
 37 |     pub fn new(start: Position, end: Position) -> Self {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    = help: items from traits can only be used if the trait is implemented and in scope
    = note: the following trait defines an item `default`, perhaps you need to implement it:
            candidate #1: `Default`

error[E0599]: no variant or associated item named `DuplicateSymbol` found for enum `error::ErrorKind` in the current scope
   --> compiler/src/semantic/resolver.rs:362:58
    |
362 |                     self.add_error(Error::new(ErrorKind::DuplicateSymbol, e));
    |                                                          ^^^^^^^^^^^^^^^ variant or associated item not found in `error::ErrorKind`
    |
   ::: compiler/src/error.rs:18:1
    |
 18 | pub enum ErrorKind {
    | ------------------ variant or associated item `DuplicateSymbol` not found for this enum

error[E0599]: no function or associated item named `default` found for struct `span::Span` in the current scope
   --> compiler/src/semantic/resolver.rs:407:27
    |
407 |                     Span::default(),
    |                           ^^^^^^^ function or associated item not found in `span::Span`
    |
   ::: compiler/src/span.rs:31:1
    |
 31 | pub struct Span {
    | --------------- function or associated item `default` not found for this struct
    |
note: if you're trying to build a new `span::Span`, consider using `span::Span::new` which returns `span::Span`
   --> compiler/src/span.rs:37:5
    |
 37 |     pub fn new(start: Position, end: Position) -> Self {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    = help: items from traits can only be used if the trait is implemented and in scope
    = note: the following trait defines an item `default`, perhaps you need to implement it:
            candidate #1: `Default`

error[E0599]: no variant or associated item named `DuplicateSymbol` found for enum `error::ErrorKind` in the current scope
   --> compiler/src/semantic/resolver.rs:412:58
    |
412 |                     self.add_error(Error::new(ErrorKind::DuplicateSymbol, e));
    |                                                          ^^^^^^^^^^^^^^^ variant or associated item not found in `error::ErrorKind`
    |
   ::: compiler/src/error.rs:18:1
    |
 18 | pub enum ErrorKind {
    | ------------------ variant or associated item `DuplicateSymbol` not found for this enum

error[E0599]: no variant or associated item named `TypeError` found for enum `error::ErrorKind` in the current scope
   --> compiler/src/semantic/type_env.rs:239:36
    |
239 |                         ErrorKind::TypeError,
    |                                    ^^^^^^^^^ variant or associated item not found in `error::ErrorKind`
    |
   ::: compiler/src/error.rs:18:1
    |
 18 | pub enum ErrorKind {
    | ------------------ variant or associated item `TypeError` not found for this enum
    |
help: there is a variant with a similar name
    |
239 -                         ErrorKind::TypeError,
240 -                         "Occurs check failed: infinite type"
241 -                     ))
239 +                         ErrorKind::MoveError)
    |

error[E0599]: no variant or associated item named `TypeError` found for enum `error::ErrorKind` in the current scope
   --> compiler/src/semantic/type_env.rs:253:36
    |
253 |                         ErrorKind::TypeError,
    |                                    ^^^^^^^^^ variant or associated item not found in `error::ErrorKind`
    |
   ::: compiler/src/error.rs:18:1
    |
 18 | pub enum ErrorKind {
    | ------------------ variant or associated item `TypeError` not found for this enum
    |
help: there is a variant with a similar name
    |
253 -                         ErrorKind::TypeError,
254 -                         format!("Function arity mismatch: {} vs {}", params1.len(), params2.len())
255 -                     ));
253 +                         ErrorKind::MoveError);
    |

error[E0599]: no variant or associated item named `TypeError` found for enum `error::ErrorKind` in the current scope
   --> compiler/src/semantic/type_env.rs:275:36
    |
275 |                         ErrorKind::TypeError,
    |                                    ^^^^^^^^^ variant or associated item not found in `error::ErrorKind`
    |
   ::: compiler/src/error.rs:18:1
    |
 18 | pub enum ErrorKind {
    | ------------------ variant or associated item `TypeError` not found for this enum
    |
help: there is a variant with a similar name
    |
275 -                         ErrorKind::TypeError,
276 -                         format!("Type mismatch: {} vs {}", name1, name2)
277 -                     ));
275 +                         ErrorKind::MoveError);
    |

error[E0599]: no variant or associated item named `TypeError` found for enum `error::ErrorKind` in the current scope
   --> compiler/src/semantic/type_env.rs:282:36
    |
282 |                         ErrorKind::TypeError,
    |                                    ^^^^^^^^^ variant or associated item not found in `error::ErrorKind`
    |
   ::: compiler/src/error.rs:18:1
    |
 18 | pub enum ErrorKind {
    | ------------------ variant or associated item `TypeError` not found for this enum
    |
help: there is a variant with a similar name
    |
282 -                         ErrorKind::TypeError,
283 -                         "Generic argument count mismatch"
284 -                     ));
282 +                         ErrorKind::MoveError);
    |

error[E0599]: no variant or associated item named `TypeError` found for enum `error::ErrorKind` in the current scope
   --> compiler/src/semantic/type_env.rs:300:36
    |
300 |                         ErrorKind::TypeError,
    |                                    ^^^^^^^^^ variant or associated item not found in `error::ErrorKind`
    |
   ::: compiler/src/error.rs:18:1
    |
 18 | pub enum ErrorKind {
    | ------------------ variant or associated item `TypeError` not found for this enum
    |
help: there is a variant with a similar name
    |
300 -                         ErrorKind::TypeError,
301 -                         "Tuple size mismatch"
302 -                     ));
300 +                         ErrorKind::MoveError);
    |

error[E0599]: no variant or associated item named `TypeError` found for enum `error::ErrorKind` in the current scope
   --> compiler/src/semantic/type_env.rs:318:36
    |
318 |                         ErrorKind::TypeError,
    |                                    ^^^^^^^^^ variant or associated item not found in `error::ErrorKind`
    |
   ::: compiler/src/error.rs:18:1
    |
 18 | pub enum ErrorKind {
    | ------------------ variant or associated item `TypeError` not found for this enum
    |
help: there is a variant with a similar name
    |
318 -                         ErrorKind::TypeError,
319 -                         "Array size mismatch"
320 -                     ));
318 +                         ErrorKind::MoveError);
    |

error[E0599]: no variant or associated item named `TypeError` found for enum `error::ErrorKind` in the current scope
   --> compiler/src/semantic/type_env.rs:341:36
    |
341 |                         ErrorKind::TypeError,
    |                                    ^^^^^^^^^ variant or associated item not found in `error::ErrorKind`
    |
   ::: compiler/src/error.rs:18:1
    |
 18 | pub enum ErrorKind {
    | ------------------ variant or associated item `TypeError` not found for this enum
    |
help: there is a variant with a similar name
    |
341 -                         ErrorKind::TypeError,
342 -                         format!("Type mismatch: {} vs {}", n1, n2)
343 -                     ))
341 +                         ErrorKind::MoveError)
    |

error[E0599]: no variant or associated item named `TypeError` found for enum `error::ErrorKind` in the current scope
   --> compiler/src/semantic/type_env.rs:349:28
    |
349 |                 ErrorKind::TypeError,
    |                            ^^^^^^^^^ variant or associated item not found in `error::ErrorKind`
    |
   ::: compiler/src/error.rs:18:1
    |
 18 | pub enum ErrorKind {
    | ------------------ variant or associated item `TypeError` not found for this enum
    |
help: there is a variant with a similar name
    |
349 -                 ErrorKind::TypeError,
350 -                 format!("Cannot unify types: {:?} and {:?}", t1, t2)
351 -             ))
349 +                 ErrorKind::MoveError)
    |

error[E0599]: no variant or associated item named `TypeError` found for enum `error::ErrorKind` in the current scope
   --> compiler/src/semantic/type_checker.rs:144:36
    |
144 |                         ErrorKind::TypeError,
    |                                    ^^^^^^^^^ variant or associated item not found in `error::ErrorKind`
    |
   ::: compiler/src/error.rs:18:1
    |
 18 | pub enum ErrorKind {
    | ------------------ variant or associated item `TypeError` not found for this enum
    |
help: there is a variant with a similar name
    |
144 -                         ErrorKind::TypeError,
145 -                         "Let binding must have type annotation or initializer"
146 -                     ));
144 +                         ErrorKind::MoveError);
    |

warning: unreachable expression
  --> compiler/src/codegen/llvm_backend.rs:46:9
   |
33 |         return "x86_64-unknown-linux-gnu".to_string();
   |         --------------------------------------------- any code following this expression is unreachable
...
46 |         "unknown-unknown-unknown".to_string()
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ unreachable expression
   |
   = note: `#[warn(unreachable_code)]` (part of `#[warn(unused)]`) on by default

error[E0599]: no variant or associated item named `I1` found for enum `IrType` in the current scope
  --> compiler/src/codegen/llvm_backend.rs:60:21
   |
60 |             IrType::I1 => "i1".to_string(),
   |                     ^^ variant or associated item not found in `IrType`
   |
  ::: compiler/src/ir/types.rs:7:1
   |
 7 | pub enum IrType {
   | --------------- variant or associated item `I1` not found for this enum
   |
help: there is a variant with a similar name
   |
60 -             IrType::I1 => "i1".to_string(),
60 +             IrType::I8 => "i1".to_string(),
   |

error[E0599]: no variant or associated item named `Ptr` found for enum `IrType` in the current scope
  --> compiler/src/codegen/llvm_backend.rs:73:21
   |
73 |             IrType::Ptr(inner) => format!("{}*", self.type_to_llvm(inner)),
   |                     ^^^ variant or associated item not found in `IrType`
   |
  ::: compiler/src/ir/types.rs:7:1
   |
 7 | pub enum IrType {
   | --------------- variant or associated item `Ptr` not found for this enum

error[E0026]: variant `Instruction::Branch` does not have fields named `true_bb`, `false_bb`
   --> compiler/src/codegen/llvm_backend.rs:290:41
    |
290 |             Instruction::Branch { cond, true_bb, false_bb } => {
    |                                         ^^^^^^^  ^^^^^^^^ variant `Instruction::Branch` does not have these fields

error[E0027]: pattern does not mention fields `then_block`, `else_block`
   --> compiler/src/codegen/llvm_backend.rs:290:13
    |
290 |             Instruction::Branch { cond, true_bb, false_bb } => {
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ missing fields `then_block`, `else_block`
    |
help: include the missing fields in the pattern
    |
290 |             Instruction::Branch { cond, true_bb, false_bb, then_block, else_block } => {
    |                                                          ++++++++++++++++++++++++
help: if you don't care about these missing fields, you can explicitly ignore them
    |
290 |             Instruction::Branch { cond, true_bb, false_bb, then_block: _, else_block: _ } => {
    |                                                          ++++++++++++++++++++++++++++++
help: or always ignore missing fields here
    |
290 |             Instruction::Branch { cond, true_bb, false_bb, .. } => {
    |                                                          ++++

error[E0609]: no field `0` on type `&usize`
   --> compiler/src/codegen/llvm_backend.rs:295:53
    |
295 |                 Ok(format!("br label %bb{}", target.0))
    |                                                     ^ unknown field

error[E0609]: no field `0` on type `&usize`
   --> compiler/src/codegen/llvm_backend.rs:305:63
    |
305 |                         format!("[ {}, %bb{} ]", val_name, bb.0)
    |                                                               ^ unknown field

error[E0599]: no variant or associated item named `I1` found for enum `IrType` in the current scope
   --> compiler/src/codegen/llvm_backend.rs:337:59
    |
337 |             Value::Constant(Constant::Bool(_)) => IrType::I1,
    |                                                           ^^ variant or associated item not found in `IrType`
    |
   ::: compiler/src/ir/types.rs:7:1
    |
  7 | pub enum IrType {
    | --------------- variant or associated item `I1` not found for this enum
    |
help: there is a variant with a similar name
    |
337 -             Value::Constant(Constant::Bool(_)) => IrType::I1,
337 +             Value::Constant(Constant::Bool(_)) => IrType::I8,
    |

error[E0599]: no variant named `MacroCall` found for enum `ast::Expr`
  --> compiler/src/macro_system/expander.rs:25:19
   |
25 |             Expr::MacroCall { name, args, span } => {
   |                   ^^^^^^^^^ variant not found in `ast::Expr`
   |
  ::: compiler/src/parser/ast.rs:94:1
   |
94 | pub enum Expr {
   | ------------- variant `MacroCall` not found here

error[E0769]: tuple variant `Expr::Binary` written as struct variant
  --> compiler/src/macro_system/expander.rs:28:13
   |
28 |             Expr::Binary { op, left, right, span } => {
   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
help: use the tuple variant pattern syntax instead
   |
28 -             Expr::Binary { op, left, right, span } => {
28 +             Expr::Binary(_, _, _) => {
   |

error[E0769]: tuple variant `Expr::Call` written as struct variant
  --> compiler/src/macro_system/expander.rs:38:13
   |
38 |             Expr::Call { func, args, span } => {
   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
help: use the tuple variant pattern syntax instead
   |
38 -             Expr::Call { func, args, span } => {
38 +             Expr::Call(_, _) => {
   |

error[E0769]: tuple variant `Expr::Block` written as struct variant
  --> compiler/src/macro_system/expander.rs:49:13
   |
49 |             Expr::Block { stmts, span } => {
   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
help: use the tuple variant pattern syntax instead
   |
49 -             Expr::Block { stmts, span } => {
49 +             Expr::Block(_) => {
   |

error[E0559]: variant `ast::Expr::Binary` has no field named `op`
  --> compiler/src/macro_system/expander.rs:32:21
   |
32 |                     op: *op,
   |                     ^^ field does not exist
   |
  ::: compiler/src/parser/ast.rs:97:5
   |
97 |     Binary(Box<Expr>, BinOp, Box<Expr>),
   |     ------ `ast::Expr::Binary` defined here
   |
help: `ast::Expr::Binary` is a tuple variant, use the appropriate syntax
   |
31 -                 Ok(Expr::Binary {
32 -                     op: *op,
33 -                     left,
34 -                     right,
35 -                     span: *span,
36 -                 })
31 +                 Ok(Expr::Binary(/* Box<ast::Expr> */, /* ast::BinOp */, /* Box<ast::Expr> */))
   |

error[E0559]: variant `ast::Expr::Binary` has no field named `left`
  --> compiler/src/macro_system/expander.rs:33:21
   |
33 |                     left,
   |                     ^^^^ field does not exist
   |
  ::: compiler/src/parser/ast.rs:97:5
   |
97 |     Binary(Box<Expr>, BinOp, Box<Expr>),
   |     ------ `ast::Expr::Binary` defined here
   |
help: `ast::Expr::Binary` is a tuple variant, use the appropriate syntax
   |
31 -                 Ok(Expr::Binary {
32 -                     op: *op,
33 -                     left,
34 -                     right,
35 -                     span: *span,
36 -                 })
31 +                 Ok(Expr::Binary(/* Box<ast::Expr> */, /* ast::BinOp */, /* Box<ast::Expr> */))
   |

error[E0559]: variant `ast::Expr::Binary` has no field named `right`
  --> compiler/src/macro_system/expander.rs:34:21
   |
34 |                     right,
   |                     ^^^^^ field does not exist
   |
  ::: compiler/src/parser/ast.rs:97:5
   |
97 |     Binary(Box<Expr>, BinOp, Box<Expr>),
   |     ------ `ast::Expr::Binary` defined here
   |
help: `ast::Expr::Binary` is a tuple variant, use the appropriate syntax
   |
31 -                 Ok(Expr::Binary {
32 -                     op: *op,
33 -                     left,
34 -                     right,
35 -                     span: *span,
36 -                 })
31 +                 Ok(Expr::Binary(/* Box<ast::Expr> */, /* ast::BinOp */, /* Box<ast::Expr> */))
   |

error[E0559]: variant `ast::Expr::Binary` has no field named `span`
  --> compiler/src/macro_system/expander.rs:35:21
   |
35 |                     span: *span,
   |                     ^^^^ field does not exist
   |
  ::: compiler/src/parser/ast.rs:97:5
   |
97 |     Binary(Box<Expr>, BinOp, Box<Expr>),
   |     ------ `ast::Expr::Binary` defined here
   |
help: `ast::Expr::Binary` is a tuple variant, use the appropriate syntax
   |
31 -                 Ok(Expr::Binary {
32 -                     op: *op,
33 -                     left,
34 -                     right,
35 -                     span: *span,
36 -                 })
31 +                 Ok(Expr::Binary(/* Box<ast::Expr> */, /* ast::BinOp */, /* Box<ast::Expr> */))
   |

error[E0559]: variant `ast::Expr::Call` has no field named `func`
  --> compiler/src/macro_system/expander.rs:44:21
   |
44 |                     func,
   |                     ^^^^ field does not exist
   |
  ::: compiler/src/parser/ast.rs:99:5
   |
99 |     Call(Box<Expr>, Vec<Expr>),
   |     ---- `ast::Expr::Call` defined here
   |
help: `ast::Expr::Call` is a tuple variant, use the appropriate syntax
   |
43 -                 Ok(Expr::Call {
44 -                     func,
45 -                     args,
46 -                     span: *span,
47 -                 })
43 +                 Ok(Expr::Call(/* Box<ast::Expr> */, /* Vec<ast::Expr> */))
   |

error[E0559]: variant `ast::Expr::Call` has no field named `args`
  --> compiler/src/macro_system/expander.rs:45:21
   |
45 |                     args,
   |                     ^^^^ field does not exist
   |
  ::: compiler/src/parser/ast.rs:99:5
   |
99 |     Call(Box<Expr>, Vec<Expr>),
   |     ---- `ast::Expr::Call` defined here
   |
help: `ast::Expr::Call` is a tuple variant, use the appropriate syntax
   |
43 -                 Ok(Expr::Call {
44 -                     func,
45 -                     args,
46 -                     span: *span,
47 -                 })
43 +                 Ok(Expr::Call(/* Box<ast::Expr> */, /* Vec<ast::Expr> */))
   |

error[E0559]: variant `ast::Expr::Call` has no field named `span`
  --> compiler/src/macro_system/expander.rs:46:21
   |
46 |                     span: *span,
   |                     ^^^^ field does not exist
   |
  ::: compiler/src/parser/ast.rs:99:5
   |
99 |     Call(Box<Expr>, Vec<Expr>),
   |     ---- `ast::Expr::Call` defined here
   |
help: `ast::Expr::Call` is a tuple variant, use the appropriate syntax
   |
43 -                 Ok(Expr::Call {
44 -                     func,
45 -                     args,
46 -                     span: *span,
47 -                 })
43 +                 Ok(Expr::Call(/* Box<ast::Expr> */, /* Vec<ast::Expr> */))
   |

error[E0559]: variant `ast::Expr::Block` has no field named `stmts`
   --> compiler/src/macro_system/expander.rs:54:21
    |
 54 |                     stmts,
    |                     ^^^^^ field does not exist
    |
   ::: compiler/src/parser/ast.rs:103:5
    |
103 |     Block(Vec<Stmt>),
    |     ----- `ast::Expr::Block` defined here
    |
help: `ast::Expr::Block` is a tuple variant, use the appropriate syntax
    |
 53 -                 Ok(Expr::Block {
 54 -                     stmts,
 55 -                     span: *span,
 56 -                 })
 53 +                 Ok(Expr::Block(/* Vec<ast::Stmt> */))
    |

error[E0559]: variant `ast::Expr::Block` has no field named `span`
   --> compiler/src/macro_system/expander.rs:55:21
    |
 55 |                     span: *span,
    |                     ^^^^ field does not exist
    |
   ::: compiler/src/parser/ast.rs:103:5
    |
103 |     Block(Vec<Stmt>),
    |     ----- `ast::Expr::Block` defined here
    |
help: `ast::Expr::Block` is a tuple variant, use the appropriate syntax
    |
 53 -                 Ok(Expr::Block {
 54 -                     stmts,
 55 -                     span: *span,
 56 -                 })
 53 +                 Ok(Expr::Block(/* Vec<ast::Stmt> */))
    |

error[E0769]: tuple variant `Stmt::Let` written as struct variant
  --> compiler/src/macro_system/expander.rs:67:13
   |
67 |             Stmt::Let { pattern, ty, init, span } => {
   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
help: use the tuple variant pattern syntax instead
   |
67 -             Stmt::Let { pattern, ty, init, span } => {
67 +             Stmt::Let(_, _, _) => {
   |

error[E0559]: variant `ast::Stmt::Let` has no field named `pattern`
  --> compiler/src/macro_system/expander.rs:73:21
   |
73 |                     pattern: pattern.clone(),
   |                     ^^^^^^^ field does not exist
   |
  ::: compiler/src/parser/ast.rs:87:5
   |
87 |     Let(String, Option<Type>, Option<Expr>),
   |     --- `ast::Stmt::Let` defined here
   |
help: `ast::Stmt::Let` is a tuple variant, use the appropriate syntax
   |
72 -                 Ok(Stmt::Let {
73 -                     pattern: pattern.clone(),
74 -                     ty: ty.clone(),
75 -                     init,
76 -                     span: *span,
77 -                 })
72 +                 Ok(Stmt::Let(/* String */, /* Option<ast::Type> */, /* Option<ast::Expr> */))
   |

error[E0559]: variant `ast::Stmt::Let` has no field named `ty`
  --> compiler/src/macro_system/expander.rs:74:21
   |
74 |                     ty: ty.clone(),
   |                     ^^ field does not exist
   |
  ::: compiler/src/parser/ast.rs:87:5
   |
87 |     Let(String, Option<Type>, Option<Expr>),
   |     --- `ast::Stmt::Let` defined here
   |
help: `ast::Stmt::Let` is a tuple variant, use the appropriate syntax
   |
72 -                 Ok(Stmt::Let {
73 -                     pattern: pattern.clone(),
74 -                     ty: ty.clone(),
75 -                     init,
76 -                     span: *span,
77 -                 })
72 +                 Ok(Stmt::Let(/* String */, /* Option<ast::Type> */, /* Option<ast::Expr> */))
   |

error[E0559]: variant `ast::Stmt::Let` has no field named `init`
  --> compiler/src/macro_system/expander.rs:75:21
   |
75 |                     init,
   |                     ^^^^ field does not exist
   |
  ::: compiler/src/parser/ast.rs:87:5
   |
87 |     Let(String, Option<Type>, Option<Expr>),
   |     --- `ast::Stmt::Let` defined here
   |
help: `ast::Stmt::Let` is a tuple variant, use the appropriate syntax
   |
72 -                 Ok(Stmt::Let {
73 -                     pattern: pattern.clone(),
74 -                     ty: ty.clone(),
75 -                     init,
76 -                     span: *span,
77 -                 })
72 +                 Ok(Stmt::Let(/* String */, /* Option<ast::Type> */, /* Option<ast::Expr> */))
   |

error[E0559]: variant `ast::Stmt::Let` has no field named `span`
  --> compiler/src/macro_system/expander.rs:76:21
   |
76 |                     span: *span,
   |                     ^^^^ field does not exist
   |
  ::: compiler/src/parser/ast.rs:87:5
   |
87 |     Let(String, Option<Type>, Option<Expr>),
   |     --- `ast::Stmt::Let` defined here
   |
help: `ast::Stmt::Let` is a tuple variant, use the appropriate syntax
   |
72 -                 Ok(Stmt::Let {
73 -                     pattern: pattern.clone(),
74 -                     ty: ty.clone(),
75 -                     init,
76 -                     span: *span,
77 -                 })
72 +                 Ok(Stmt::Let(/* String */, /* Option<ast::Type> */, /* Option<ast::Expr> */))
   |

error[E0308]: mismatched types
  --> compiler/src/macro_system/expander.rs:86:17
   |
86 |                 format!("macro expansion depth exceeded (max: {})", self.max_depth),
   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `String`
   |
   = note: this error originates in the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0277]: the trait bound `String: From<span::Span>` is not satisfied
  --> compiler/src/macro_system/expander.rs:87:17
   |
85 |             return Err(Error::new(
   |                        ---------- required by a bound introduced by this call
86 |                 format!("macro expansion depth exceeded (max: {})", self.max_depth),
87 |                 span,
   |                 ^^^^ the trait `From<span::Span>` is not implemented for `String`
   |
   = help: the following other types implement trait `From<T>`:
             `String` implements `From<&String>`
             `String` implements `From<&mut str>`
             `String` implements `From<&str>`
             `String` implements `From<Box<str>>`
             `String` implements `From<Cow<'_, str>>`
             `String` implements `From<char>`
             `String` implements `From<clap::Id>`
             `String` implements `From<clap::builder::Str>`
   = note: required for `span::Span` to implement `Into<String>`
note: required by a bound in `error::Error::new`
  --> compiler/src/error.rs:47:47
   |
47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
   |                                               ^^^^^^^^^^^^ required by this bound in `Error::new`

error[E0308]: mismatched types
  --> compiler/src/macro_system/expander.rs:92:39
   |
92 |             .ok_or_else(|| Error::new(format!("undefined macro: {}", name), span))?;
   |                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `String`
   |
   = note: this error originates in the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0277]: the trait bound `String: From<span::Span>` is not satisfied
  --> compiler/src/macro_system/expander.rs:92:77
   |
92 |             .ok_or_else(|| Error::new(format!("undefined macro: {}", name), span))?;
   |                            ----------                                       ^^^^ the trait `From<span::Span>` is not implemented for `String`
   |                            |
   |                            required by a bound introduced by this call
   |
   = help: the following other types implement trait `From<T>`:
             `String` implements `From<&String>`
             `String` implements `From<&mut str>`
             `String` implements `From<&str>`
             `String` implements `From<Box<str>>`
             `String` implements `From<Cow<'_, str>>`
             `String` implements `From<char>`
             `String` implements `From<clap::Id>`
             `String` implements `From<clap::builder::Str>`
   = note: required for `span::Span` to implement `Into<String>`
note: required by a bound in `error::Error::new`
  --> compiler/src/error.rs:47:47
   |
47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
   |                                               ^^^^^^^^^^^^ required by this bound in `Error::new`

error[E0308]: mismatched types
   --> compiler/src/macro_system/expander.rs:110:21
    |
110 |                     format!("no matching macro rule for {}", def.name),
    |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `String`
    |
    = note: this error originates in the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0277]: the trait bound `String: From<span::Span>` is not satisfied
   --> compiler/src/macro_system/expander.rs:111:21
    |
109 |                 Err(Error::new(
    |                     ---------- required by a bound introduced by this call
110 |                     format!("no matching macro rule for {}", def.name),
111 |                     span,
    |                     ^^^^ the trait `From<span::Span>` is not implemented for `String`
    |
    = help: the following other types implement trait `From<T>`:
              `String` implements `From<&String>`
              `String` implements `From<&mut str>`
              `String` implements `From<&str>`
              `String` implements `From<Box<str>>`
              `String` implements `From<Cow<'_, str>>`
              `String` implements `From<char>`
              `String` implements `From<clap::Id>`
              `String` implements `From<clap::builder::Str>`
    = note: required for `span::Span` to implement `Into<String>`
note: required by a bound in `error::Error::new`
   --> compiler/src/error.rs:47:47
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |                                               ^^^^^^^^^^^^ required by this bound in `Error::new`

error[E0277]: the trait bound `String: From<span::Span>` is not satisfied
   --> compiler/src/macro_system/expander.rs:116:73
    |
116 |                 Err(Error::new("procedural macros not yet implemented", span))
    |                     ----------                                          ^^^^ the trait `From<span::Span>` is not implemented for `String`
    |                     |
    |                     required by a bound introduced by this call
    |
    = help: the following other types implement trait `From<T>`:
              `String` implements `From<&String>`
              `String` implements `From<&mut str>`
              `String` implements `From<&str>`
              `String` implements `From<Box<str>>`
              `String` implements `From<Cow<'_, str>>`
              `String` implements `From<char>`
              `String` implements `From<clap::Id>`
              `String` implements `From<clap::builder::Str>`
    = note: required for `span::Span` to implement `Into<String>`
note: required by a bound in `error::Error::new`
   --> compiler/src/error.rs:47:47
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |                                               ^^^^^^^^^^^^ required by this bound in `Error::new`

error[E0308]: mismatched types
   --> compiler/src/macro_system/expander.rs:116:32
    |
116 |                 Err(Error::new("procedural macros not yet implemented", span))
    |                     ---------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `&str`
    |                     |
    |                     arguments to this function are incorrect
    |
note: associated function defined here
   --> compiler/src/error.rs:47:12
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |            ^^^ ---------------

error[E0559]: variant `ast::Expr::Block` has no field named `stmts`
   --> compiler/src/macro_system/expander.rs:224:13
    |
224 |             stmts: vec![],
    |             ^^^^^ field does not exist
    |
   ::: compiler/src/parser/ast.rs:103:5
    |
103 |     Block(Vec<Stmt>),
    |     ----- `ast::Expr::Block` defined here
    |
help: `ast::Expr::Block` is a tuple variant, use the appropriate syntax
    |
223 -         Ok(Expr::Block {
224 -             stmts: vec![],
225 -             span,
226 -         })
223 +         Ok(Expr::Block(/* Vec<ast::Stmt> */))
    |

error[E0559]: variant `ast::Expr::Block` has no field named `span`
   --> compiler/src/macro_system/expander.rs:225:13
    |
225 |             span,
    |             ^^^^ field does not exist
    |
   ::: compiler/src/parser/ast.rs:103:5
    |
103 |     Block(Vec<Stmt>),
    |     ----- `ast::Expr::Block` defined here
    |
help: `ast::Expr::Block` is a tuple variant, use the appropriate syntax
    |
223 -         Ok(Expr::Block {
224 -             stmts: vec![],
225 -             span,
226 -         })
223 +         Ok(Expr::Block(/* Vec<ast::Stmt> */))
    |

error[E0599]: no function or associated item named `dummy` found for struct `span::Span` in the current scope
   --> compiler/src/macro_system/mod.rs:132:29
    |
132 |                 span: Span::dummy(),
    |                             ^^^^^ function or associated item not found in `span::Span`
    |
   ::: compiler/src/span.rs:31:1
    |
 31 | pub struct Span {
    | --------------- function or associated item `dummy` not found for this struct
    |
note: if you're trying to build a new `span::Span`, consider using `span::Span::new` which returns `span::Span`
   --> compiler/src/span.rs:37:5
    |
 37 |     pub fn new(start: Position, end: Position) -> Self {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0599]: no function or associated item named `dummy` found for struct `span::Span` in the current scope
   --> compiler/src/macro_system/mod.rs:187:29
    |
187 |                 span: Span::dummy(),
    |                             ^^^^^ function or associated item not found in `span::Span`
    |
   ::: compiler/src/span.rs:31:1
    |
 31 | pub struct Span {
    | --------------- function or associated item `dummy` not found for this struct
    |
note: if you're trying to build a new `span::Span`, consider using `span::Span::new` which returns `span::Span`
   --> compiler/src/span.rs:37:5
    |
 37 |     pub fn new(start: Position, end: Position) -> Self {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0599]: no function or associated item named `dummy` found for struct `span::Span` in the current scope
   --> compiler/src/macro_system/mod.rs:209:29
    |
209 |                 span: Span::dummy(),
    |                             ^^^^^ function or associated item not found in `span::Span`
    |
   ::: compiler/src/span.rs:31:1
    |
 31 | pub struct Span {
    | --------------- function or associated item `dummy` not found for this struct
    |
note: if you're trying to build a new `span::Span`, consider using `span::Span::new` which returns `span::Span`
   --> compiler/src/span.rs:37:5
    |
 37 |     pub fn new(start: Position, end: Position) -> Self {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0282]: type annotations needed
   --> compiler/src/async_runtime/executor.rs:132:25
    |
132 |                         task.poll(&waker);
    |                         ^^^^ cannot infer type

error[E0599]: no function or associated item named `from_millis` found for struct `async_runtime::Duration` in the current scope
   --> compiler/src/async_runtime/executor.rs:135:49
    |
135 |                         Thread::sleep(Duration::from_millis(10));
    |                                                 ^^^^^^^^^^^ function or associated item not found in `async_runtime::Duration`
    |
   ::: compiler/src/async_runtime/mod.rs:142:1
    |
142 | pub struct Duration {
    | ------------------- function or associated item `from_millis` not found for this struct

error[E0026]: variant `ast::Expr::Literal` does not have a field named `value`
   --> compiler/src/verification/smt_solver.rs:109:29
    |
109 |             Expr::Literal { value, .. } => {
    |                             ^^^^^
    |                             |
    |                             variant `ast::Expr::Literal` does not have this field
    |                             help: `ast::Expr::Literal` has a field named `0`

error[E0599]: no variant named `Variable` found for enum `ast::Expr`
   --> compiler/src/verification/smt_solver.rs:116:19
    |
116 |             Expr::Variable { name, .. } => Ok(name.clone()),
    |                   ^^^^^^^^ variant not found in `ast::Expr`
    |
   ::: compiler/src/parser/ast.rs:94:1
    |
 94 | pub enum Expr {
    | ------------- variant `Variable` not found here

error[E0026]: variant `ast::Expr::Binary` does not have fields named `op`, `left`, `right`
   --> compiler/src/verification/smt_solver.rs:117:28
    |
117 |             Expr::Binary { op, left, right, .. } => {
    |                            ^^  ^^^^  ^^^^^ variant `ast::Expr::Binary` does not have these fields

error[E0026]: variant `ast::Expr::Unary` does not have fields named `op`, `operand`
   --> compiler/src/verification/smt_solver.rs:139:27
    |
139 |             Expr::Unary { op, operand, .. } => {
    |                           ^^  ^^^^^^^ variant `ast::Expr::Unary` does not have these fields

error[E0308]: mismatched types
   --> compiler/src/verification/smt_solver.rs:113:41
    |
113 |                     _ => Err(Error::new("Unsupported literal type for SMT", Span::dummy())),
    |                              ---------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `&str`
    |                              |
    |                              arguments to this function are incorrect
    |
note: associated function defined here
   --> compiler/src/error.rs:47:12
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |            ^^^ ---------------

error[E0308]: mismatched types
   --> compiler/src/verification/smt_solver.rs:134:48
    |
134 |                     _ => return Err(Error::new("Unsupported binary operator for SMT", Span::dummy())),
    |                                     ---------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `&str`
    |                                     |
    |                                     arguments to this function are incorrect
    |
note: associated function defined here
   --> compiler/src/error.rs:47:12
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |            ^^^ ---------------

error[E0308]: mismatched types
   --> compiler/src/verification/smt_solver.rs:145:48
    |
145 |                     _ => return Err(Error::new("Unsupported unary operator for SMT", Span::dummy())),
    |                                     ---------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `&str`
    |                                     |
    |                                     arguments to this function are incorrect
    |
note: associated function defined here
   --> compiler/src/error.rs:47:12
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |            ^^^ ---------------

error[E0308]: mismatched types
   --> compiler/src/verification/smt_solver.rs:150:33
    |
150 |             _ => Err(Error::new("Unsupported expression type for SMT", Span::dummy())),
    |                      ---------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `&str`
    |                      |
    |                      arguments to this function are incorrect
    |
note: associated function defined here
   --> compiler/src/error.rs:47:12
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |            ^^^ ---------------

error[E0599]: no variant named `Variable` found for enum `ast::Expr`
   --> compiler/src/verification/smt_solver.rs:164:19
    |
164 |             Expr::Variable { name, .. } => {
    |                   ^^^^^^^^ variant not found in `ast::Expr`
    |
   ::: compiler/src/parser/ast.rs:94:1
    |
 94 | pub enum Expr {
    | ------------- variant `Variable` not found here

error[E0026]: variant `ast::Expr::Binary` does not have fields named `left`, `right`
   --> compiler/src/verification/smt_solver.rs:167:28
    |
167 |             Expr::Binary { left, right, .. } => {
    |                            ^^^^  ^^^^^ variant `ast::Expr::Binary` does not have these fields

error[E0026]: variant `ast::Expr::Unary` does not have a field named `operand`
   --> compiler/src/verification/smt_solver.rs:171:27
    |
171 |             Expr::Unary { operand, .. } => {
    |                           ^^^^^^^ variant `ast::Expr::Unary` does not have this field

error[E0308]: mismatched types
   --> compiler/src/verification/smt_solver.rs:195:37
    |
195 |             .map_err(|e| Error::new(format!("Failed to spawn SMT solver: {}", e), Span::dummy()))?;
    |                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `String`
    |
    = note: this error originates in the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0308]: mismatched types
   --> compiler/src/verification/smt_solver.rs:199:41
    |
199 |                 .map_err(|e| Error::new(format!("Failed to write to SMT solver: {}", e), Span::dummy()))?;
    |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `String`
    |
    = note: this error originates in the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0308]: mismatched types
   --> compiler/src/verification/smt_solver.rs:203:37
    |
203 |             .map_err(|e| Error::new(format!("Failed to read SMT solver output: {}", e), Span::dummy()))?;
    |                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `String`
    |
    = note: this error originates in the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0599]: no method named `prove_postcondition` found for mutable reference `&mut FormalVerifier` in the current scope
   --> compiler/src/verification/mod.rs:115:30
    |
115 |             let proof = self.prove_postcondition(func, post)?;
    |                              ^^^^^^^^^^^^^^^^^^^
    |
help: there is a method `verify_postcondition` with a similar name
    |
115 -             let proof = self.prove_postcondition(func, post)?;
115 +             let proof = self.verify_postcondition(func, post)?;
    |

error[E0599]: no method named `check_memory_safety` found for mutable reference `&mut FormalVerifier` in the current scope
   --> compiler/src/verification/mod.rs:120:34
    |
120 |         let memory_safety = self.check_memory_safety(func)?;
    |                                  ^^^^^^^^^^^^^^^^^^^
    |
help: there is a method `check_null_safety` with a similar name
    |
120 -         let memory_safety = self.check_memory_safety(func)?;
120 +         let memory_safety = self.check_null_safety(func)?;
    |

error[E0599]: no method named `prove_invariant_init` found for mutable reference `&mut FormalVerifier` in the current scope
   --> compiler/src/verification/mod.rs:136:31
    |
136 |         let init_proof = self.prove_invariant_init(&invariant)?;
    |                               ^^^^^^^^^^^^^^^^^^^^
    |
help: there is a method `verify_invariant_init` with a similar name
    |
136 -         let init_proof = self.prove_invariant_init(&invariant)?;
136 +         let init_proof = self.verify_invariant_init(&invariant)?;
    |

error[E0599]: no method named `prove_invariant_maintained` found for mutable reference `&mut FormalVerifier` in the current scope
   --> compiler/src/verification/mod.rs:142:35
    |
142 |         let maintain_proof = self.prove_invariant_maintained(&invariant, loop_stmt)?;
    |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^ method not found in `&mut FormalVerifier`

error[E0308]: mismatched types
   --> compiler/src/lexer/mod.rs:689:13
    |
682 |     fn lex_slash(&mut self) -> Result<TokenKind> {
    |                                ----------------- expected `std::result::Result<token::TokenKind, error::Error>` because of return type
...
689 |             self.next_token() // Skip comment and get next token
    |             ^^^^^^^^^^^^^^^^^ expected `Result<TokenKind, Error>`, found `Result<Token, Error>`
    |
    = note: expected enum `std::result::Result<token::TokenKind, _>`
               found enum `std::result::Result<Token, _>`

error[E0609]: no field `attributes` on type `&ast::Function`
   --> compiler/src/verification/mod.rs:204:27
    |
204 |         for attr in &func.attributes {
    |                           ^^^^^^^^^^ unknown field
    |
    = note: available fields are: `name`, `generics`, `params`, `return_type`, `where_clause`, `body`

error[E0308]: mismatched types
   --> compiler/src/lexer/mod.rs:698:32
    |
682 |     fn lex_slash(&mut self) -> Result<TokenKind> {
    |                                ----------------- expected `std::result::Result<token::TokenKind, error::Error>` because of return type
...
698 |                         return self.next_token(); // Skip comment
    |                                ^^^^^^^^^^^^^^^^^ expected `Result<TokenKind, Error>`, found `Result<Token, Error>`
    |
    = note: expected enum `std::result::Result<token::TokenKind, _>`
               found enum `std::result::Result<Token, _>`

error[E0282]: type annotations needed
   --> compiler/src/verification/mod.rs:207:40
    |
207 |                     preconditions.push(expr.clone());
    |                                        ^^^^ cannot infer type

error[E0609]: no field `attributes` on type `&ast::Function`
   --> compiler/src/verification/mod.rs:219:27
    |
219 |         for attr in &func.attributes {
    |                           ^^^^^^^^^^ unknown field
    |
    = note: available fields are: `name`, `generics`, `params`, `return_type`, `where_clause`, `body`

error[E0282]: type annotations needed
   --> compiler/src/verification/mod.rs:222:41
    |
222 |                     postconditions.push(expr.clone());
    |                                         ^^^^ cannot infer type

error[E0026]: variant `ast::Stmt::Let` does not have fields named `pattern`, `init`
   --> compiler/src/gpu/mod.rs:243:25
    |
243 |             Stmt::Let { pattern, init, .. } => {
    |                         ^^^^^^^  ^^^^ variant `ast::Stmt::Let` does not have these fields

error[E0026]: variant `ast::Expr::Literal` does not have a field named `value`
   --> compiler/src/gpu/mod.rs:259:29
    |
259 |             Expr::Literal { value, .. } => {
    |                             ^^^^^
    |                             |
    |                             variant `ast::Expr::Literal` does not have this field
    |                             help: `ast::Expr::Literal` has a field named `0`

error[E0599]: no variant named `Variable` found for enum `ast::Expr`
   --> compiler/src/gpu/mod.rs:267:19
    |
267 |             Expr::Variable { name, .. } => Ok(name.clone()),
    |                   ^^^^^^^^ variant not found in `ast::Expr`
    |
   ::: compiler/src/parser/ast.rs:94:1
    |
 94 | pub enum Expr {
    | ------------- variant `Variable` not found here

error[E0026]: variant `ast::Expr::Binary` does not have fields named `op`, `left`, `right`
   --> compiler/src/gpu/mod.rs:268:28
    |
268 |             Expr::Binary { op, left, right, .. } => {
    |                            ^^  ^^^^  ^^^^^ variant `ast::Expr::Binary` does not have these fields

error[E0599]: no variant or associated item named `I32` found for enum `ast::Type` in the current scope
   --> compiler/src/gpu/mod.rs:304:19
    |
304 |             Type::I32 => Ok("int".to_string()),
    |                   ^^^ variant or associated item not found in `ast::Type`
    |
   ::: compiler/src/parser/ast.rs:73:1
    |
 73 | pub enum Type {
    | ------------- variant or associated item `I32` not found for this enum

error[E0599]: no variant or associated item named `I64` found for enum `ast::Type` in the current scope
   --> compiler/src/gpu/mod.rs:305:19
    |
305 |             Type::I64 => Ok("long".to_string()),
    |                   ^^^ variant or associated item not found in `ast::Type`
    |
   ::: compiler/src/parser/ast.rs:73:1
    |
 73 | pub enum Type {
    | ------------- variant or associated item `I64` not found for this enum

error[E0599]: no variant or associated item named `F32` found for enum `ast::Type` in the current scope
   --> compiler/src/gpu/mod.rs:306:19
    |
306 |             Type::F32 => Ok("float".to_string()),
    |                   ^^^ variant or associated item not found in `ast::Type`
    |
   ::: compiler/src/parser/ast.rs:73:1
    |
 73 | pub enum Type {
    | ------------- variant or associated item `F32` not found for this enum

error[E0599]: no variant or associated item named `F64` found for enum `ast::Type` in the current scope
   --> compiler/src/gpu/mod.rs:307:19
    |
307 |             Type::F64 => Ok("double".to_string()),
    |                   ^^^ variant or associated item not found in `ast::Type`
    |
   ::: compiler/src/parser/ast.rs:73:1
    |
 73 | pub enum Type {
    | ------------- variant or associated item `F64` not found for this enum

error[E0599]: no variant or associated item named `Pointer` found for enum `ast::Type` in the current scope
   --> compiler/src/gpu/mod.rs:308:19
    |
308 |             Type::Pointer(inner) => Ok(format!("{}*", self.cuda_type(inner)?)),
    |                   ^^^^^^^ variant or associated item not found in `ast::Type`
    |
   ::: compiler/src/parser/ast.rs:73:1
    |
 73 | pub enum Type {
    | ------------- variant or associated item `Pointer` not found for this enum

error[E0599]: no variant or associated item named `I32` found for enum `ast::Type` in the current scope
   --> compiler/src/gpu/mod.rs:315:19
    |
315 |             Type::I32 => Ok("device int*".to_string()),
    |                   ^^^ variant or associated item not found in `ast::Type`
    |
   ::: compiler/src/parser/ast.rs:73:1
    |
 73 | pub enum Type {
    | ------------- variant or associated item `I32` not found for this enum

error[E0599]: no variant or associated item named `I64` found for enum `ast::Type` in the current scope
   --> compiler/src/gpu/mod.rs:316:19
    |
316 |             Type::I64 => Ok("device long*".to_string()),
    |                   ^^^ variant or associated item not found in `ast::Type`
    |
   ::: compiler/src/parser/ast.rs:73:1
    |
 73 | pub enum Type {
    | ------------- variant or associated item `I64` not found for this enum

error[E0599]: no variant or associated item named `F32` found for enum `ast::Type` in the current scope
   --> compiler/src/gpu/mod.rs:317:19
    |
317 |             Type::F32 => Ok("device float*".to_string()),
    |                   ^^^ variant or associated item not found in `ast::Type`
    |
   ::: compiler/src/parser/ast.rs:73:1
    |
 73 | pub enum Type {
    | ------------- variant or associated item `F32` not found for this enum

error[E0599]: no variant or associated item named `F64` found for enum `ast::Type` in the current scope
   --> compiler/src/gpu/mod.rs:318:19
    |
318 |             Type::F64 => Ok("device double*".to_string()),
    |                   ^^^ variant or associated item not found in `ast::Type`
    |
   ::: compiler/src/parser/ast.rs:73:1
    |
 73 | pub enum Type {
    | ------------- variant or associated item `F64` not found for this enum

error[E0599]: no variant or associated item named `I32` found for enum `ast::Type` in the current scope
   --> compiler/src/gpu/mod.rs:325:19
    |
325 |             Type::I32 => Ok("int".to_string()),
    |                   ^^^ variant or associated item not found in `ast::Type`
    |
   ::: compiler/src/parser/ast.rs:73:1
    |
 73 | pub enum Type {
    | ------------- variant or associated item `I32` not found for this enum

error[E0599]: no variant or associated item named `I64` found for enum `ast::Type` in the current scope
   --> compiler/src/gpu/mod.rs:326:19
    |
326 |             Type::I64 => Ok("int64_t".to_string()),
    |                   ^^^ variant or associated item not found in `ast::Type`
    |
   ::: compiler/src/parser/ast.rs:73:1
    |
 73 | pub enum Type {
    | ------------- variant or associated item `I64` not found for this enum

error[E0599]: no variant or associated item named `F32` found for enum `ast::Type` in the current scope
   --> compiler/src/gpu/mod.rs:327:19
    |
327 |             Type::F32 => Ok("float".to_string()),
    |                   ^^^ variant or associated item not found in `ast::Type`
    |
   ::: compiler/src/parser/ast.rs:73:1
    |
 73 | pub enum Type {
    | ------------- variant or associated item `F32` not found for this enum

error[E0599]: no variant or associated item named `F64` found for enum `ast::Type` in the current scope
   --> compiler/src/gpu/mod.rs:328:19
    |
328 |             Type::F64 => Ok("double".to_string()),
    |                   ^^^ variant or associated item not found in `ast::Type`
    |
   ::: compiler/src/parser/ast.rs:73:1
    |
 73 | pub enum Type {
    | ------------- variant or associated item `F64` not found for this enum

error[E0599]: no variant or associated item named `I32` found for enum `ast::Type` in the current scope
   --> compiler/src/gpu/mod.rs:335:19
    |
335 |             Type::I32 => Ok("int*".to_string()),
    |                   ^^^ variant or associated item not found in `ast::Type`
    |
   ::: compiler/src/parser/ast.rs:73:1
    |
 73 | pub enum Type {
    | ------------- variant or associated item `I32` not found for this enum

error[E0599]: no variant or associated item named `I64` found for enum `ast::Type` in the current scope
   --> compiler/src/gpu/mod.rs:336:19
    |
336 |             Type::I64 => Ok("long*".to_string()),
    |                   ^^^ variant or associated item not found in `ast::Type`
    |
   ::: compiler/src/parser/ast.rs:73:1
    |
 73 | pub enum Type {
    | ------------- variant or associated item `I64` not found for this enum

error[E0599]: no variant or associated item named `F32` found for enum `ast::Type` in the current scope
   --> compiler/src/gpu/mod.rs:337:19
    |
337 |             Type::F32 => Ok("float*".to_string()),
    |                   ^^^ variant or associated item not found in `ast::Type`
    |
   ::: compiler/src/parser/ast.rs:73:1
    |
 73 | pub enum Type {
    | ------------- variant or associated item `F32` not found for this enum

error[E0599]: no variant or associated item named `F64` found for enum `ast::Type` in the current scope
   --> compiler/src/gpu/mod.rs:338:19
    |
338 |             Type::F64 => Ok("double*".to_string()),
    |                   ^^^ variant or associated item not found in `ast::Type`
    |
   ::: compiler/src/parser/ast.rs:73:1
    |
 73 | pub enum Type {
    | ------------- variant or associated item `F64` not found for this enum

error[E0026]: variant `ast::Expr::Literal` does not have a field named `value`
  --> compiler/src/consteval/mod.rs:61:29
   |
61 |             Expr::Literal { value, .. } => self.eval_literal(value),
   |                             ^^^^^
   |                             |
   |                             variant `ast::Expr::Literal` does not have this field
   |                             help: `ast::Expr::Literal` has a field named `0`

error[E0599]: no variant named `Variable` found for enum `ast::Expr`
  --> compiler/src/consteval/mod.rs:63:19
   |
63 |             Expr::Variable { name, .. } => {
   |                   ^^^^^^^^ variant not found in `ast::Expr`
   |
  ::: compiler/src/parser/ast.rs:94:1
   |
94 | pub enum Expr {
   | ------------- variant `Variable` not found here

error[E0026]: variant `ast::Expr::Binary` does not have fields named `op`, `left`, `right`
  --> compiler/src/consteval/mod.rs:72:28
   |
72 |             Expr::Binary { op, left, right, .. } => {
   |                            ^^  ^^^^  ^^^^^ variant `ast::Expr::Binary` does not have these fields

error[E0026]: variant `ast::Expr::Unary` does not have fields named `op`, `operand`
  --> compiler/src/consteval/mod.rs:78:27
   |
78 |             Expr::Unary { op, operand, .. } => {
   |                           ^^  ^^^^^^^ variant `ast::Expr::Unary` does not have these fields

error[E0026]: variant `ast::Expr::Call` does not have fields named `func`, `args`
  --> compiler/src/consteval/mod.rs:83:26
   |
83 |             Expr::Call { func, args, .. } => {
   |                          ^^^^  ^^^^ variant `ast::Expr::Call` does not have these fields

error[E0026]: variant `ast::Expr::If` does not have fields named `condition`, `then_branch`, `else_branch`
  --> compiler/src/consteval/mod.rs:87:24
   |
87 |             Expr::If { condition, then_branch, else_branch, .. } => {
   |                        ^^^^^^^^^  ^^^^^^^^^^^  ^^^^^^^^^^^ variant `ast::Expr::If` does not have these fields

error[E0026]: variant `ast::Expr::Array` does not have a field named `elements`
  --> compiler/src/consteval/mod.rs:98:27
   |
98 |             Expr::Array { elements, .. } => {
   |                           ^^^^^^^^
   |                           |
   |                           variant `ast::Expr::Array` does not have this field
   |                           help: `ast::Expr::Array` has a field named `0`

error[E0308]: mismatched types
  --> compiler/src/consteval/mod.rs:67:25
   |
67 |                         format!("Undefined constant: {}", name),
   |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `String`
   |
   = note: this error originates in the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0308]: mismatched types
   --> compiler/src/consteval/mod.rs:107:17
    |
106 |             _ => Err(Error::new(
    |                      ---------- arguments to this function are incorrect
107 |                 "Expression cannot be evaluated at compile time",
    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `&str`
    |
note: associated function defined here
   --> compiler/src/error.rs:47:12
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |            ^^^ ---------------

error[E0308]: mismatched types
   --> compiler/src/consteval/mod.rs:132:51
    |
132 | ...                   return Err(Error::new("Division by zero", Span::dummy()));
    |                                  ---------- ^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `&str`
    |                                  |
    |                                  arguments to this function are incorrect
    |
note: associated function defined here
   --> compiler/src/error.rs:47:12
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |            ^^^ ---------------

error[E0308]: mismatched types
   --> compiler/src/consteval/mod.rs:148:48
    |
148 |                     _ => return Err(Error::new("Unsupported binary operation", Span::dummy())),
    |                                     ---------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `&str`
    |                                     |
    |                                     arguments to this function are incorrect
    |
note: associated function defined here
   --> compiler/src/error.rs:47:12
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |            ^^^ ---------------

error[E0308]: mismatched types
   --> compiler/src/consteval/mod.rs:165:48
    |
165 |                     _ => return Err(Error::new("Unsupported binary operation", Span::dummy())),
    |                                     ---------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `&str`
    |                                     |
    |                                     arguments to this function are incorrect
    |
note: associated function defined here
   --> compiler/src/error.rs:47:12
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |            ^^^ ---------------

error[E0308]: mismatched types
   --> compiler/src/consteval/mod.rs:176:48
    |
176 |                     _ => return Err(Error::new("Unsupported binary operation", Span::dummy())),
    |                                     ---------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `&str`
    |                                     |
    |                                     arguments to this function are incorrect
    |
note: associated function defined here
   --> compiler/src/error.rs:47:12
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |            ^^^ ---------------

error[E0308]: mismatched types
   --> compiler/src/consteval/mod.rs:181:33
    |
181 |             _ => Err(Error::new("Type mismatch in binary operation", Span::dummy())),
    |                      ---------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `&str`
    |                      |
    |                      arguments to this function are incorrect
    |
note: associated function defined here
   --> compiler/src/error.rs:47:12
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |            ^^^ ---------------

error[E0308]: mismatched types
   --> compiler/src/consteval/mod.rs:192:48
    |
192 |                     _ => return Err(Error::new("Unsupported unary operation", Span::dummy())),
    |                                     ---------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `&str`
    |                                     |
    |                                     arguments to this function are incorrect
    |
note: associated function defined here
   --> compiler/src/error.rs:47:12
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |            ^^^ ---------------

error[E0308]: mismatched types
   --> compiler/src/consteval/mod.rs:200:48
    |
200 |                     _ => return Err(Error::new("Unsupported unary operation", Span::dummy())),
    |                                     ---------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `&str`
    |                                     |
    |                                     arguments to this function are incorrect
    |
note: associated function defined here
   --> compiler/src/error.rs:47:12
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |            ^^^ ---------------

error[E0308]: mismatched types
   --> compiler/src/consteval/mod.rs:208:48
    |
208 |                     _ => return Err(Error::new("Unsupported unary operation", Span::dummy())),
    |                                     ---------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `&str`
    |                                     |
    |                                     arguments to this function are incorrect
    |
note: associated function defined here
   --> compiler/src/error.rs:47:12
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |            ^^^ ---------------

error[E0308]: mismatched types
   --> compiler/src/consteval/mod.rs:213:33
    |
213 |             _ => Err(Error::new("Type mismatch in unary operation", Span::dummy())),
    |                      ---------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `&str`
    |                      |
    |                      arguments to this function are incorrect
    |
note: associated function defined here
   --> compiler/src/error.rs:47:12
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |            ^^^ ---------------

error[E0599]: no variant named `Variable` found for enum `ast::Expr`
   --> compiler/src/consteval/mod.rs:220:19
    |
220 |             Expr::Variable { name, .. } => name,
    |                   ^^^^^^^^ variant not found in `ast::Expr`
    |
   ::: compiler/src/parser/ast.rs:94:1
    |
 94 | pub enum Expr {
    | ------------- variant `Variable` not found here

error[E0308]: mismatched types
   --> compiler/src/consteval/mod.rs:221:40
    |
221 |             _ => return Err(Error::new("Invalid function call", Span::dummy())),
    |                             ---------- ^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `&str`
    |                             |
    |                             arguments to this function are incorrect
    |
note: associated function defined here
   --> compiler/src/error.rs:47:12
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |            ^^^ ---------------

error[E0308]: mismatched types
   --> compiler/src/consteval/mod.rs:238:17
    |
238 |                 format!("Unknown compile-time function: {}", func_name),
    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `String`
    |
    = note: this error originates in the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0308]: mismatched types
   --> compiler/src/consteval/mod.rs:246:35
    |
246 |             return Err(Error::new("abs expects 1 argument", Span::dummy()));
    |                        ---------- ^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `&str`
    |                        |
    |                        arguments to this function are incorrect
    |
note: associated function defined here
   --> compiler/src/error.rs:47:12
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |            ^^^ ---------------

error[E0308]: mismatched types
   --> compiler/src/consteval/mod.rs:252:33
    |
252 |             _ => Err(Error::new("abs expects numeric argument", Span::dummy())),
    |                      ---------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `&str`
    |                      |
    |                      arguments to this function are incorrect
    |
note: associated function defined here
   --> compiler/src/error.rs:47:12
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |            ^^^ ---------------

error[E0308]: mismatched types
   --> compiler/src/consteval/mod.rs:258:35
    |
258 |             return Err(Error::new("min expects 2 arguments", Span::dummy()));
    |                        ---------- ^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `&str`
    |                        |
    |                        arguments to this function are incorrect
    |
note: associated function defined here
   --> compiler/src/error.rs:47:12
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |            ^^^ ---------------

error[E0308]: mismatched types
   --> compiler/src/consteval/mod.rs:264:33
    |
264 |             _ => Err(Error::new("min expects numeric arguments", Span::dummy())),
    |                      ---------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `&str`
    |                      |
    |                      arguments to this function are incorrect
    |
note: associated function defined here
   --> compiler/src/error.rs:47:12
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |            ^^^ ---------------

error[E0308]: mismatched types
   --> compiler/src/consteval/mod.rs:270:35
    |
270 |             return Err(Error::new("max expects 2 arguments", Span::dummy()));
    |                        ---------- ^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `&str`
    |                        |
    |                        arguments to this function are incorrect
    |
note: associated function defined here
   --> compiler/src/error.rs:47:12
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |            ^^^ ---------------

error[E0308]: mismatched types
   --> compiler/src/consteval/mod.rs:276:33
    |
276 |             _ => Err(Error::new("max expects numeric arguments", Span::dummy())),
    |                      ---------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `&str`
    |                      |
    |                      arguments to this function are incorrect
    |
note: associated function defined here
   --> compiler/src/error.rs:47:12
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |            ^^^ ---------------

error[E0308]: mismatched types
   --> compiler/src/consteval/mod.rs:282:35
    |
282 |             return Err(Error::new("pow expects 2 arguments", Span::dummy()));
    |                        ---------- ^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `&str`
    |                        |
    |                        arguments to this function are incorrect
    |
note: associated function defined here
   --> compiler/src/error.rs:47:12
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |            ^^^ ---------------

error[E0308]: mismatched types
   --> compiler/src/consteval/mod.rs:291:43
    |
291 |                     return Err(Error::new("Negative exponent for integer pow", Span::dummy()));
    |                                ---------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `&str`
    |                                |
    |                                arguments to this function are incorrect
    |
note: associated function defined here
   --> compiler/src/error.rs:47:12
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |            ^^^ ---------------

error[E0308]: mismatched types
   --> compiler/src/consteval/mod.rs:295:33
    |
295 |             _ => Err(Error::new("pow expects numeric arguments", Span::dummy())),
    |                      ---------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `&str`
    |                      |
    |                      arguments to this function are incorrect
    |
note: associated function defined here
   --> compiler/src/error.rs:47:12
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |            ^^^ ---------------

error[E0308]: mismatched types
   --> compiler/src/consteval/mod.rs:301:35
    |
301 |             return Err(Error::new("sqrt expects 1 argument", Span::dummy()));
    |                        ---------- ^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `&str`
    |                        |
    |                        arguments to this function are incorrect
    |
note: associated function defined here
   --> compiler/src/error.rs:47:12
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |            ^^^ ---------------

error[E0308]: mismatched types
   --> compiler/src/consteval/mod.rs:307:43
    |
307 |                     return Err(Error::new("sqrt of negative number", Span::dummy()));
    |                                ---------- ^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `&str`
    |                                |
    |                                arguments to this function are incorrect
    |
note: associated function defined here
   --> compiler/src/error.rs:47:12
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |            ^^^ ---------------

error[E0308]: mismatched types
   --> compiler/src/consteval/mod.rs:311:33
    |
311 |             _ => Err(Error::new("sqrt expects float argument", Span::dummy())),
    |                      ---------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `&str`
    |                      |
    |                      arguments to this function are incorrect
    |
note: associated function defined here
   --> compiler/src/error.rs:47:12
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |            ^^^ ---------------

error[E0599]: no variant or associated item named `I1` found for enum `types::IrType` in the current scope
  --> compiler/src/codegen/llvm_backend.rs:60:21
   |
60 |             IrType::I1 => "i1".to_string(),
   |                     ^^ variant or associated item not found in `types::IrType`
   |
  ::: compiler/src/ir/types.rs:7:1
   |
 7 | pub enum IrType {
   | --------------- variant or associated item `I1` not found for this enum
   |
help: there is a variant with a similar name
   |
60 -             IrType::I1 => "i1".to_string(),
60 +             IrType::I8 => "i1".to_string(),
   |

error[E0599]: no variant or associated item named `Ptr` found for enum `types::IrType` in the current scope
  --> compiler/src/codegen/llvm_backend.rs:73:21
   |
73 |             IrType::Ptr(inner) => format!("{}*", self.type_to_llvm(inner)),
   |                     ^^^ variant or associated item not found in `types::IrType`
   |
  ::: compiler/src/ir/types.rs:7:1
   |
 7 | pub enum IrType {
   | --------------- variant or associated item `Ptr` not found for this enum

error[E0026]: variant `instructions::Instruction::Branch` does not have fields named `true_bb`, `false_bb`
   --> compiler/src/codegen/llvm_backend.rs:290:41
    |
290 |             Instruction::Branch { cond, true_bb, false_bb } => {
    |                                         ^^^^^^^  ^^^^^^^^ variant `instructions::Instruction::Branch` does not have these fields

error[E0599]: no variant or associated item named `I1` found for enum `types::IrType` in the current scope
   --> compiler/src/codegen/llvm_backend.rs:337:59
    |
337 |             Value::Constant(Constant::Bool(_)) => IrType::I1,
    |                                                           ^^ variant or associated item not found in `types::IrType`
    |
   ::: compiler/src/ir/types.rs:7:1
    |
  7 | pub enum IrType {
    | --------------- variant or associated item `I1` not found for this enum
    |
help: there is a variant with a similar name
    |
337 -             Value::Constant(Constant::Bool(_)) => IrType::I1,
337 +             Value::Constant(Constant::Bool(_)) => IrType::I8,
    |

warning: unused variable: `func`
   --> compiler/src/verification/mod.rs:194:41
    |
194 |     fn check_overflow_safety(&mut self, func: &Function) -> Result<bool> {
    |                                         ^^^^ help: if this is intentional, prefix it with an underscore: `_func`
    |
    = note: `#[warn(unused_variables)]` (part of `#[warn(unused)]`) on by default

error[E0594]: cannot assign to `proof.status`, as `proof` is not declared as mutable
   --> compiler/src/verification/mod.rs:247:13
    |
247 |             proof.status = ProofStatus::Proven;
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ cannot assign
    |
help: consider changing this to be mutable
    |
237 |         let mut proof = Proof {
    |             +++

error[E0594]: cannot assign to `proof.status`, as `proof` is not declared as mutable
   --> compiler/src/verification/mod.rs:249:13
    |
249 |             proof.status = ProofStatus::Failed;
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ cannot assign
    |
help: consider changing this to be mutable
    |
237 |         let mut proof = Proof {
    |             +++

warning: variable does not need to be mutable
   --> compiler/src/verification/mod.rs:268:13
    |
268 |         let mut proof = Proof {
    |             ----^^^^^
    |             |
    |             help: remove this `mut`
    |
    = note: `#[warn(unused_mut)]` (part of `#[warn(unused)]`) on by default

error[E0599]: no variant named `MacroCall` found for enum `ast::Expr`
   --> compiler/src/macro_system/expander.rs:240:26
    |
240 |         let expr = Expr::MacroCall {
    |                          ^^^^^^^^^ variant not found in `ast::Expr`
    |
   ::: compiler/src/parser/ast.rs:94:1
    |
 94 | pub enum Expr {
    | ------------- variant `MacroCall` not found here

error[E0599]: no function or associated item named `dummy` found for struct `span::Span` in the current scope
   --> compiler/src/macro_system/expander.rs:243:25
    |
243 |             span: Span::dummy(),
    |                         ^^^^^ function or associated item not found in `span::Span`
    |
   ::: compiler/src/span.rs:31:1
    |
 31 | pub struct Span {
    | --------------- function or associated item `dummy` not found for this struct
    |
note: if you're trying to build a new `span::Span`, consider using `span::Span::new` which returns `span::Span`
   --> compiler/src/span.rs:37:5
    |
 37 |     pub fn new(start: Position, end: Position) -> Self {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Some errors have detailed explanations: E0023, E0026, E0027, E0277, E0282, E0308, E0412, E0432, E0433...
For more information about an error, try `rustc --explain E0023`.
error[E0559]: variant `ast::Expr::Literal` has no field named `value`
   --> compiler/src/verification/mod.rs:363:13
    |
363 |             value: Literal::Bool(true),
    |             ^^^^^ field does not exist
    |
   ::: compiler/src/parser/ast.rs:95:5
    |
 95 |     Literal(Literal),
    |     ------- `ast::Expr::Literal` defined here
    |
help: `ast::Expr::Literal` is a tuple variant, use the appropriate syntax
    |
362 -         let precond = Expr::Literal {
363 -             value: Literal::Bool(true),
364 -             span: Span::dummy(),
365 -         };
362 +         let precond = Expr::Literal(/* ast::Literal */);
    |

error[E0559]: variant `ast::Expr::Literal` has no field named `span`
   --> compiler/src/verification/mod.rs:364:13
    |
364 |             span: Span::dummy(),
    |             ^^^^ field does not exist
    |
   ::: compiler/src/parser/ast.rs:95:5
    |
 95 |     Literal(Literal),
    |     ------- `ast::Expr::Literal` defined here
    |
help: `ast::Expr::Literal` is a tuple variant, use the appropriate syntax
    |
362 -         let precond = Expr::Literal {
363 -             value: Literal::Bool(true),
364 -             span: Span::dummy(),
365 -         };
362 +         let precond = Expr::Literal(/* ast::Literal */);
    |

warning: `vez_compiler` (lib) generated 14 warnings
error: could not compile `vez_compiler` (lib) due to 288 previous errors; 14 warnings emitted
warning: build failed, waiting for other jobs to finish...
error[E0559]: variant `ast::Expr::Literal` has no field named `value`
   --> compiler/src/consteval/mod.rs:335:13
    |
335 |             value: Literal::Int(42),
    |             ^^^^^ field does not exist
    |
   ::: compiler/src/parser/ast.rs:95:5
    |
 95 |     Literal(Literal),
    |     ------- `ast::Expr::Literal` defined here
    |
help: `ast::Expr::Literal` is a tuple variant, use the appropriate syntax
    |
334 -         let expr = Expr::Literal {
335 -             value: Literal::Int(42),
336 -             span: Span::dummy(),
337 -         };
334 +         let expr = Expr::Literal(/* ast::Literal */);
    |

error[E0559]: variant `ast::Expr::Literal` has no field named `span`
   --> compiler/src/consteval/mod.rs:336:13
    |
336 |             span: Span::dummy(),
    |             ^^^^ field does not exist
    |
   ::: compiler/src/parser/ast.rs:95:5
    |
 95 |     Literal(Literal),
    |     ------- `ast::Expr::Literal` defined here
    |
help: `ast::Expr::Literal` is a tuple variant, use the appropriate syntax
    |
334 -         let expr = Expr::Literal {
335 -             value: Literal::Int(42),
336 -             span: Span::dummy(),
337 -         };
334 +         let expr = Expr::Literal(/* ast::Literal */);
    |

error[E0559]: variant `ast::Expr::Binary` has no field named `op`
   --> compiler/src/consteval/mod.rs:348:13
    |
348 |             op: BinaryOp::Add,
    |             ^^ field does not exist
    |
   ::: compiler/src/parser/ast.rs:97:5
    |
 97 |     Binary(Box<Expr>, BinOp, Box<Expr>),
    |     ------ `ast::Expr::Binary` defined here
    |
help: `ast::Expr::Binary` is a tuple variant, use the appropriate syntax
    |
347 -         let expr = Expr::Binary {
348 -             op: BinaryOp::Add,
349 -             left: Box::new(Expr::Literal {
350 -                 value: Literal::Int(10),
351 -                 span: Span::dummy(),
352 -             }),
353 -             right: Box::new(Expr::Literal {
354 -                 value: Literal::Int(32),
355 -                 span: Span::dummy(),
356 -             }),
357 -             span: Span::dummy(),
358 -         };
347 +         let expr = Expr::Binary(/* Box<ast::Expr> */, /* ast::BinOp */, /* Box<ast::Expr> */);
    |

error[E0559]: variant `ast::Expr::Binary` has no field named `left`
   --> compiler/src/consteval/mod.rs:349:13
    |
349 |             left: Box::new(Expr::Literal {
    |             ^^^^ field does not exist
    |
   ::: compiler/src/parser/ast.rs:97:5
    |
 97 |     Binary(Box<Expr>, BinOp, Box<Expr>),
    |     ------ `ast::Expr::Binary` defined here
    |
help: `ast::Expr::Binary` is a tuple variant, use the appropriate syntax
    |
347 -         let expr = Expr::Binary {
348 -             op: BinaryOp::Add,
349 -             left: Box::new(Expr::Literal {
350 -                 value: Literal::Int(10),
351 -                 span: Span::dummy(),
352 -             }),
353 -             right: Box::new(Expr::Literal {
354 -                 value: Literal::Int(32),
355 -                 span: Span::dummy(),
356 -             }),
357 -             span: Span::dummy(),
358 -         };
347 +         let expr = Expr::Binary(/* Box<ast::Expr> */, /* ast::BinOp */, /* Box<ast::Expr> */);
    |

error[E0559]: variant `ast::Expr::Literal` has no field named `value`
   --> compiler/src/consteval/mod.rs:350:17
    |
350 |                 value: Literal::Int(10),
    |                 ^^^^^ field does not exist
    |
   ::: compiler/src/parser/ast.rs:95:5
    |
 95 |     Literal(Literal),
    |     ------- `ast::Expr::Literal` defined here
    |
help: `ast::Expr::Literal` is a tuple variant, use the appropriate syntax
    |
349 -             left: Box::new(Expr::Literal {
350 -                 value: Literal::Int(10),
351 -                 span: Span::dummy(),
352 -             }),
349 +             left: Box::new(Expr::Literal(/* ast::Literal */)),
    |

error[E0559]: variant `ast::Expr::Literal` has no field named `span`
   --> compiler/src/consteval/mod.rs:351:17
    |
351 |                 span: Span::dummy(),
    |                 ^^^^ field does not exist
    |
   ::: compiler/src/parser/ast.rs:95:5
    |
 95 |     Literal(Literal),
    |     ------- `ast::Expr::Literal` defined here
    |
help: `ast::Expr::Literal` is a tuple variant, use the appropriate syntax
    |
349 -             left: Box::new(Expr::Literal {
350 -                 value: Literal::Int(10),
351 -                 span: Span::dummy(),
352 -             }),
349 +             left: Box::new(Expr::Literal(/* ast::Literal */)),
    |

error[E0559]: variant `ast::Expr::Binary` has no field named `right`
   --> compiler/src/consteval/mod.rs:353:13
    |
353 |             right: Box::new(Expr::Literal {
    |             ^^^^^ field does not exist
    |
   ::: compiler/src/parser/ast.rs:97:5
    |
 97 |     Binary(Box<Expr>, BinOp, Box<Expr>),
    |     ------ `ast::Expr::Binary` defined here
    |
help: `ast::Expr::Binary` is a tuple variant, use the appropriate syntax
    |
347 -         let expr = Expr::Binary {
348 -             op: BinaryOp::Add,
349 -             left: Box::new(Expr::Literal {
350 -                 value: Literal::Int(10),
351 -                 span: Span::dummy(),
352 -             }),
353 -             right: Box::new(Expr::Literal {
354 -                 value: Literal::Int(32),
355 -                 span: Span::dummy(),
356 -             }),
357 -             span: Span::dummy(),
358 -         };
347 +         let expr = Expr::Binary(/* Box<ast::Expr> */, /* ast::BinOp */, /* Box<ast::Expr> */);
    |

error[E0559]: variant `ast::Expr::Literal` has no field named `value`
   --> compiler/src/consteval/mod.rs:354:17
    |
354 |                 value: Literal::Int(32),
    |                 ^^^^^ field does not exist
    |
   ::: compiler/src/parser/ast.rs:95:5
    |
 95 |     Literal(Literal),
    |     ------- `ast::Expr::Literal` defined here
    |
help: `ast::Expr::Literal` is a tuple variant, use the appropriate syntax
    |
353 -             right: Box::new(Expr::Literal {
354 -                 value: Literal::Int(32),
355 -                 span: Span::dummy(),
356 -             }),
353 +             right: Box::new(Expr::Literal(/* ast::Literal */)),
    |

error[E0559]: variant `ast::Expr::Literal` has no field named `span`
   --> compiler/src/consteval/mod.rs:355:17
    |
355 |                 span: Span::dummy(),
    |                 ^^^^ field does not exist
    |
   ::: compiler/src/parser/ast.rs:95:5
    |
 95 |     Literal(Literal),
    |     ------- `ast::Expr::Literal` defined here
    |
help: `ast::Expr::Literal` is a tuple variant, use the appropriate syntax
    |
353 -             right: Box::new(Expr::Literal {
354 -                 value: Literal::Int(32),
355 -                 span: Span::dummy(),
356 -             }),
353 +             right: Box::new(Expr::Literal(/* ast::Literal */)),
    |

error[E0559]: variant `ast::Expr::Binary` has no field named `span`
   --> compiler/src/consteval/mod.rs:357:13
    |
357 |             span: Span::dummy(),
    |             ^^^^ field does not exist
    |
   ::: compiler/src/parser/ast.rs:97:5
    |
 97 |     Binary(Box<Expr>, BinOp, Box<Expr>),
    |     ------ `ast::Expr::Binary` defined here
    |
help: `ast::Expr::Binary` is a tuple variant, use the appropriate syntax
    |
347 -         let expr = Expr::Binary {
348 -             op: BinaryOp::Add,
349 -             left: Box::new(Expr::Literal {
350 -                 value: Literal::Int(10),
351 -                 span: Span::dummy(),
352 -             }),
353 -             right: Box::new(Expr::Literal {
354 -                 value: Literal::Int(32),
355 -                 span: Span::dummy(),
356 -             }),
357 -             span: Span::dummy(),
358 -         };
347 +         let expr = Expr::Binary(/* Box<ast::Expr> */, /* ast::BinOp */, /* Box<ast::Expr> */);
    |

warning: variable does not need to be mutable
   --> compiler/src/consteval/mod.rs:366:13
    |
366 |         let mut eval = ConstEvaluator::new();
    |             ----^^^^
    |             |
    |             help: remove this `mut`

Some errors have detailed explanations: E0023, E0026, E0027, E0277, E0282, E0308, E0412, E0428, E0432...
warning: `vez_compiler` (lib test) generated 16 warnings (13 duplicates)
error: could not compile `vez_compiler` (lib test) due to 309 previous errors; 16 warnings emitted
[0;32mâœ“[0m Compiler tests passed: 
[1;33mâ†’[0m Running all workspace tests...
warning: profiles for the non root package will be ignored, specify profiles at the workspace root:
package:   /run/media/zarigata/42A0B8BDA0B8B8AD/ARTIFICIAL-INTELIGENCE/ArtificialProgramingLanguage/compiler/Cargo.toml
workspace: /run/media/zarigata/42A0B8BDA0B8B8AD/ARTIFICIAL-INTELIGENCE/ArtificialProgramingLanguage/Cargo.toml
   Compiling serde_json v1.0.149
   Compiling serde v1.0.228
   Compiling vez_compiler v0.1.0 (/run/media/zarigata/42A0B8BDA0B8B8AD/ARTIFICIAL-INTELIGENCE/ArtificialProgramingLanguage/compiler)
error[E0583]: file not found for module `hygiene`
 --> compiler/src/macro_system/mod.rs:5:1
  |
5 | pub mod hygiene;
  | ^^^^^^^^^^^^^^^^
  |
  = help: to create the module `hygiene`, create file "compiler/src/macro_system/hygiene.rs" or "compiler/src/macro_system/hygiene/mod.rs"
  = note: if there is a `mod hygiene` elsewhere in the crate already, import it with `use crate::...` instead

error[E0583]: file not found for module `parser`
 --> compiler/src/macro_system/mod.rs:6:1
  |
6 | pub mod parser;
  | ^^^^^^^^^^^^^^^
  |
  = help: to create the module `parser`, create file "compiler/src/macro_system/parser.rs" or "compiler/src/macro_system/parser/mod.rs"
  = note: if there is a `mod parser` elsewhere in the crate already, import it with `use crate::...` instead

error[E0583]: file not found for module `builtin`
 --> compiler/src/macro_system/mod.rs:7:1
  |
7 | pub mod builtin;
  | ^^^^^^^^^^^^^^^^
  |
  = help: to create the module `builtin`, create file "compiler/src/macro_system/builtin.rs" or "compiler/src/macro_system/builtin/mod.rs"
  = note: if there is a `mod builtin` elsewhere in the crate already, import it with `use crate::...` instead

error[E0583]: file not found for module `future`
 --> compiler/src/async_runtime/mod.rs:4:1
  |
4 | pub mod future;
  | ^^^^^^^^^^^^^^^
  |
  = help: to create the module `future`, create file "compiler/src/async_runtime/future.rs" or "compiler/src/async_runtime/future/mod.rs"
  = note: if there is a `mod future` elsewhere in the crate already, import it with `use crate::...` instead

error[E0583]: file not found for module `task`
 --> compiler/src/async_runtime/mod.rs:6:1
  |
6 | pub mod task;
  | ^^^^^^^^^^^^^
  |
  = help: to create the module `task`, create file "compiler/src/async_runtime/task.rs" or "compiler/src/async_runtime/task/mod.rs"
  = note: if there is a `mod task` elsewhere in the crate already, import it with `use crate::...` instead

error[E0583]: file not found for module `waker`
 --> compiler/src/async_runtime/mod.rs:7:1
  |
7 | pub mod waker;
  | ^^^^^^^^^^^^^^
  |
  = help: to create the module `waker`, create file "compiler/src/async_runtime/waker.rs" or "compiler/src/async_runtime/waker/mod.rs"
  = note: if there is a `mod waker` elsewhere in the crate already, import it with `use crate::...` instead

error[E0583]: file not found for module `proof_engine`
 --> compiler/src/verification/mod.rs:5:1
  |
5 | pub mod proof_engine;
  | ^^^^^^^^^^^^^^^^^^^^^
  |
  = help: to create the module `proof_engine`, create file "compiler/src/verification/proof_engine.rs" or "compiler/src/verification/proof_engine/mod.rs"
  = note: if there is a `mod proof_engine` elsewhere in the crate already, import it with `use crate::...` instead

error[E0583]: file not found for module `safety_checker`
 --> compiler/src/verification/mod.rs:6:1
  |
6 | pub mod safety_checker;
  | ^^^^^^^^^^^^^^^^^^^^^^^
  |
  = help: to create the module `safety_checker`, create file "compiler/src/verification/safety_checker.rs" or "compiler/src/verification/safety_checker/mod.rs"
  = note: if there is a `mod safety_checker` elsewhere in the crate already, import it with `use crate::...` instead

error[E0583]: file not found for module `contracts`
 --> compiler/src/verification/mod.rs:7:1
  |
7 | pub mod contracts;
  | ^^^^^^^^^^^^^^^^^^
  |
  = help: to create the module `contracts`, create file "compiler/src/verification/contracts.rs" or "compiler/src/verification/contracts/mod.rs"
  = note: if there is a `mod contracts` elsewhere in the crate already, import it with `use crate::...` instead

error[E0583]: file not found for module `cuda`
 --> compiler/src/gpu/mod.rs:4:1
  |
4 | pub mod cuda;
  | ^^^^^^^^^^^^^
  |
  = help: to create the module `cuda`, create file "compiler/src/gpu/cuda.rs" or "compiler/src/gpu/cuda/mod.rs"
  = note: if there is a `mod cuda` elsewhere in the crate already, import it with `use crate::...` instead

error[E0583]: file not found for module `metal`
 --> compiler/src/gpu/mod.rs:5:1
  |
5 | pub mod metal;
  | ^^^^^^^^^^^^^^
  |
  = help: to create the module `metal`, create file "compiler/src/gpu/metal.rs" or "compiler/src/gpu/metal/mod.rs"
  = note: if there is a `mod metal` elsewhere in the crate already, import it with `use crate::...` instead

error[E0583]: file not found for module `vulkan`
 --> compiler/src/gpu/mod.rs:6:1
  |
6 | pub mod vulkan;
  | ^^^^^^^^^^^^^^^
  |
  = help: to create the module `vulkan`, create file "compiler/src/gpu/vulkan.rs" or "compiler/src/gpu/vulkan/mod.rs"
  = note: if there is a `mod vulkan` elsewhere in the crate already, import it with `use crate::...` instead

error[E0583]: file not found for module `kernel`
 --> compiler/src/gpu/mod.rs:7:1
  |
7 | pub mod kernel;
  | ^^^^^^^^^^^^^^^
  |
  = help: to create the module `kernel`, create file "compiler/src/gpu/kernel.rs" or "compiler/src/gpu/kernel/mod.rs"
  = note: if there is a `mod kernel` elsewhere in the crate already, import it with `use crate::...` instead

error[E0428]: the name `tests` is defined multiple times
   --> compiler/src/lexer/mod.rs:849:1
    |
  5 | mod tests;
    | ---------- previous definition of the module `tests` here
...
849 | mod tests {
    | ^^^^^^^^^ `tests` redefined here
    |
    = note: `tests` must be defined only once in the type namespace of this module

error[E0432]: unresolved import `crate::semantic::types`
  --> compiler/src/verification/mod.rs:10:22
   |
10 | use crate::semantic::types::Type;
   |                      ^^^^^ could not find `types` in `semantic`

error[E0432]: unresolved import `crate::semantic::types`
 --> compiler/src/consteval/mod.rs:5:22
  |
5 | use crate::semantic::types::Type;
  |                      ^^^^^ could not find `types` in `semantic`

error[E0432]: unresolved import `crate::error::CompilerError`
 --> compiler/src/codegen/llvm_backend.rs:6:28
  |
6 | use crate::error::{Result, CompilerError};
  |                            ^^^^^^^^^^^^^ no `CompilerError` in `error`

error[E0432]: unresolved import `crate::error::CompilerError`
 --> compiler/src/codegen/target.rs:3:28
  |
3 | use crate::error::{Result, CompilerError};
  |                            ^^^^^^^^^^^^^ no `CompilerError` in `error`

error[E0432]: unresolved import `crate::error::CompilerError`
 --> compiler/src/codegen/linker.rs:3:28
  |
3 | use crate::error::{Result, CompilerError};
  |                            ^^^^^^^^^^^^^ no `CompilerError` in `error`

error[E0432]: unresolved import `crate::error::CompilerError`
 --> compiler/src/codegen/target.rs:3:28
  |
3 | use crate::error::{Result, CompilerError};
  |                            ^^^^^^^^^^^^^ no `CompilerError` in `error`
  |
  = note: unresolved item `crate::codegen::llvm_backend::tests::CompilerError` exists but is inaccessible

error[E0432]: unresolved import `crate::error::CompilerError`
 --> compiler/src/codegen/linker.rs:3:28
  |
3 | use crate::error::{Result, CompilerError};
  |                            ^^^^^^^^^^^^^ no `CompilerError` in `error`
  |
  = note: unresolved item `crate::codegen::target::tests::CompilerError` exists but is inaccessible

error[E0532]: expected tuple struct or tuple variant, found unit variant `Constant::Null`
   --> compiler/src/codegen/llvm_backend.rs:129:13
    |
129 |             Constant::Null(ty) => format!("{} null", self.type_to_llvm(ty)),
    |             ^^^^^^^^^^^^^^^^^^ help: use this syntax instead: `Constant::Null`
    |
   ::: compiler/src/ir/ssa.rs:30:5
    |
 30 |     Null,
    |     ---- `Constant::Null` defined here

error[E0532]: expected tuple struct or tuple variant, found unit variant `Constant::Undef`
   --> compiler/src/codegen/llvm_backend.rs:130:13
    |
130 |             Constant::Undef(ty) => format!("{} undef", self.type_to_llvm(ty)),
    |             ^^^^^^^^^^^^^^^^^^^ help: use this syntax instead: `Constant::Undef`
    |
   ::: compiler/src/ir/ssa.rs:31:5
    |
 31 |     Undef,
    |     ----- `Constant::Undef` defined here

error[E0433]: failed to resolve: use of undeclared type `Pin`
  --> compiler/src/async_runtime/executor.rs:64:19
   |
64 |             match Pin::new(&mut future).poll(&waker) {
   |                   ^^^ use of undeclared type `Pin`
   |
help: consider importing this struct
   |
 4 + use std::pin::Pin;
   |

error[E0412]: cannot find type `Thread` in this scope
   --> compiler/src/async_runtime/executor.rs:112:18
    |
112 |     threads: Vec<Thread>,
    |                  ^^^^^^ not found in this scope
    |
help: consider importing this struct
    |
  4 + use std::thread::Thread;
    |

error[E0412]: cannot find type `Arc` in this scope
   --> compiler/src/async_runtime/executor.rs:113:17
    |
113 |     task_queue: Arc<Mutex<VecDeque<Box<dyn Task>>>>,
    |                 ^^^ not found in this scope
    |
help: consider importing this struct
    |
  4 + use std::sync::Arc;
    |

error[E0412]: cannot find type `Mutex` in this scope
   --> compiler/src/async_runtime/executor.rs:113:21
    |
113 |     task_queue: Arc<Mutex<VecDeque<Box<dyn Task>>>>,
    |                     ^^^^^ not found in this scope
    |
help: consider importing one of these structs
    |
  4 + use std::sync::Mutex;
    |
  4 + use std::sync::nonpoison::Mutex;
    |

error[E0433]: failed to resolve: use of undeclared type `Arc`
   --> compiler/src/async_runtime/executor.rs:118:26
    |
118 |         let task_queue = Arc::new(Mutex::new(VecDeque::new()));
    |                          ^^^ use of undeclared type `Arc`
    |
help: consider importing this struct
    |
  4 + use std::sync::Arc;
    |

error[E0433]: failed to resolve: use of undeclared type `Mutex`
   --> compiler/src/async_runtime/executor.rs:118:35
    |
118 |         let task_queue = Arc::new(Mutex::new(VecDeque::new()));
    |                                   ^^^^^ use of undeclared type `Mutex`
    |
help: consider importing one of these structs
    |
  4 + use std::sync::Mutex;
    |
  4 + use std::sync::nonpoison::Mutex;
    |

error[E0433]: failed to resolve: use of undeclared type `Thread`
   --> compiler/src/async_runtime/executor.rs:123:26
    |
123 |             let thread = Thread::spawn(move || {
    |                          ^^^^^^ use of undeclared type `Thread`
    |
help: consider importing this struct
    |
  4 + use std::thread::Thread;
    |

error[E0433]: failed to resolve: use of undeclared type `Thread`
   --> compiler/src/async_runtime/executor.rs:135:25
    |
135 |                         Thread::sleep(Duration::from_millis(10));
    |                         ^^^^^^ use of undeclared type `Thread`
    |
help: consider importing this struct
    |
  4 + use std::thread::Thread;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/verification/smt_solver.rs:113:77
    |
113 |                     _ => Err(Error::new("Unsupported literal type for SMT", Span::dummy())),
    |                                                                             ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/verification/smt_solver.rs:122:21
    |
122 |                     BinaryOp::Add => "+",
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/verification/smt_solver.rs:123:21
    |
123 |                     BinaryOp::Sub => "-",
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/verification/smt_solver.rs:124:21
    |
124 |                     BinaryOp::Mul => "*",
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/verification/smt_solver.rs:125:21
    |
125 |                     BinaryOp::Div => "div",
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/verification/smt_solver.rs:126:21
    |
126 |                     BinaryOp::Eq => "=",
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/verification/smt_solver.rs:127:21
    |
127 |                     BinaryOp::Ne => "distinct",
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/verification/smt_solver.rs:128:21
    |
128 |                     BinaryOp::Lt => "<",
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/verification/smt_solver.rs:129:21
    |
129 |                     BinaryOp::Le => "<=",
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/verification/smt_solver.rs:130:21
    |
130 |                     BinaryOp::Gt => ">",
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/verification/smt_solver.rs:131:21
    |
131 |                     BinaryOp::Ge => ">=",
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/verification/smt_solver.rs:132:21
    |
132 |                     BinaryOp::And => "and",
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/verification/smt_solver.rs:133:21
    |
133 |                     BinaryOp::Or => "or",
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/verification/smt_solver.rs:134:87
    |
134 |                     _ => return Err(Error::new("Unsupported binary operator for SMT", Span::dummy())),
    |                                                                                       ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0433]: failed to resolve: use of undeclared type `UnaryOp`
   --> compiler/src/verification/smt_solver.rs:143:21
    |
143 |                     UnaryOp::Not => "not",
    |                     ^^^^^^^ use of undeclared type `UnaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::UnaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `UnaryOp`
   --> compiler/src/verification/smt_solver.rs:144:21
    |
144 |                     UnaryOp::Neg => "-",
    |                     ^^^^^^^ use of undeclared type `UnaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::UnaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/verification/smt_solver.rs:145:86
    |
145 |                     _ => return Err(Error::new("Unsupported unary operator for SMT", Span::dummy())),
    |                                                                                      ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/verification/smt_solver.rs:150:72
    |
150 |             _ => Err(Error::new("Unsupported expression type for SMT", Span::dummy())),
    |                                                                        ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/verification/smt_solver.rs:195:83
    |
195 |             .map_err(|e| Error::new(format!("Failed to spawn SMT solver: {}", e), Span::dummy()))?;
    |                                                                                   ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/verification/smt_solver.rs:199:90
    |
199 |                 .map_err(|e| Error::new(format!("Failed to write to SMT solver: {}", e), Span::dummy()))?;
    |                                                                                          ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/verification/smt_solver.rs:203:89
    |
203 |             .map_err(|e| Error::new(format!("Failed to read SMT solver output: {}", e), Span::dummy()))?;
    |                                                                                         ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0412]: cannot find type `BinaryOp` in this scope
   --> compiler/src/gpu/mod.rs:285:34
    |
285 |     fn binary_op_str(&self, op: &BinaryOp) -> &str {
    |                                  ^^^^^^^^ not found in this scope
    |
help: consider importing this enum
    |
  9 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/gpu/mod.rs:287:13
    |
287 |             BinaryOp::Add => "+",
    |             ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  9 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/gpu/mod.rs:288:13
    |
288 |             BinaryOp::Sub => "-",
    |             ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  9 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/gpu/mod.rs:289:13
    |
289 |             BinaryOp::Mul => "*",
    |             ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  9 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/gpu/mod.rs:290:13
    |
290 |             BinaryOp::Div => "/",
    |             ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  9 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/gpu/mod.rs:291:13
    |
291 |             BinaryOp::Mod => "%",
    |             ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  9 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/gpu/mod.rs:292:13
    |
292 |             BinaryOp::Eq => "==",
    |             ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  9 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/gpu/mod.rs:293:13
    |
293 |             BinaryOp::Ne => "!=",
    |             ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  9 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/gpu/mod.rs:294:13
    |
294 |             BinaryOp::Lt => "<",
    |             ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  9 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/gpu/mod.rs:295:13
    |
295 |             BinaryOp::Le => "<=",
    |             ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  9 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/gpu/mod.rs:296:13
    |
296 |             BinaryOp::Gt => ">",
    |             ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  9 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/gpu/mod.rs:297:13
    |
297 |             BinaryOp::Ge => ">=",
    |             ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  9 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
  --> compiler/src/consteval/mod.rs:68:25
   |
68 |                         Span::dummy()
   |                         ^^^^ use of undeclared type `Span`
   |
help: consider importing this struct through its public re-export
   |
 4 + use crate::prelude::Span;
   |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/consteval/mod.rs:108:17
    |
108 |                 Span::dummy()
    |                 ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0412]: cannot find type `BinaryOp` in this scope
   --> compiler/src/consteval/mod.rs:123:34
    |
123 |     fn eval_binary_op(&self, op: BinaryOp, left: &ConstValue, right: &ConstValue) -> Result<ConstValue> {
    |                                  ^^^^^^^^ not found in this scope
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:127:21
    |
127 |                     BinaryOp::Add => ConstValue::Int(l + r),
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:128:21
    |
128 |                     BinaryOp::Sub => ConstValue::Int(l - r),
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:129:21
    |
129 |                     BinaryOp::Mul => ConstValue::Int(l * r),
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:130:21
    |
130 |                     BinaryOp::Div => {
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/consteval/mod.rs:132:71
    |
132 | ...                   return Err(Error::new("Division by zero", Span::dummy()));
    |                                                                 ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:136:21
    |
136 |                     BinaryOp::Mod => ConstValue::Int(l % r),
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:137:21
    |
137 |                     BinaryOp::Eq => ConstValue::Bool(l == r),
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:138:21
    |
138 |                     BinaryOp::Ne => ConstValue::Bool(l != r),
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:139:21
    |
139 |                     BinaryOp::Lt => ConstValue::Bool(l < r),
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:140:21
    |
140 |                     BinaryOp::Le => ConstValue::Bool(l <= r),
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:141:21
    |
141 |                     BinaryOp::Gt => ConstValue::Bool(l > r),
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:142:21
    |
142 |                     BinaryOp::Ge => ConstValue::Bool(l >= r),
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:143:21
    |
143 |                     BinaryOp::BitAnd => ConstValue::Int(l & r),
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:144:21
    |
144 |                     BinaryOp::BitOr => ConstValue::Int(l | r),
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:145:21
    |
145 |                     BinaryOp::BitXor => ConstValue::Int(l ^ r),
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:146:21
    |
146 |                     BinaryOp::Shl => ConstValue::Int(l << r),
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:147:21
    |
147 |                     BinaryOp::Shr => ConstValue::Int(l >> r),
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/consteval/mod.rs:148:80
    |
148 |                     _ => return Err(Error::new("Unsupported binary operation", Span::dummy())),
    |                                                                                ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:155:21
    |
155 |                     BinaryOp::Add => ConstValue::Float(l + r),
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:156:21
    |
156 |                     BinaryOp::Sub => ConstValue::Float(l - r),
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:157:21
    |
157 |                     BinaryOp::Mul => ConstValue::Float(l * r),
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:158:21
    |
158 |                     BinaryOp::Div => ConstValue::Float(l / r),
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:159:21
    |
159 |                     BinaryOp::Eq => ConstValue::Bool(l == r),
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:160:21
    |
160 |                     BinaryOp::Ne => ConstValue::Bool(l != r),
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:161:21
    |
161 |                     BinaryOp::Lt => ConstValue::Bool(l < r),
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:162:21
    |
162 |                     BinaryOp::Le => ConstValue::Bool(l <= r),
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:163:21
    |
163 |                     BinaryOp::Gt => ConstValue::Bool(l > r),
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:164:21
    |
164 |                     BinaryOp::Ge => ConstValue::Bool(l >= r),
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/consteval/mod.rs:165:80
    |
165 |                     _ => return Err(Error::new("Unsupported binary operation", Span::dummy())),
    |                                                                                ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:172:21
    |
172 |                     BinaryOp::And => ConstValue::Bool(*l && *r),
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:173:21
    |
173 |                     BinaryOp::Or => ConstValue::Bool(*l || *r),
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:174:21
    |
174 |                     BinaryOp::Eq => ConstValue::Bool(l == r),
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:175:21
    |
175 |                     BinaryOp::Ne => ConstValue::Bool(l != r),
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/consteval/mod.rs:176:80
    |
176 |                     _ => return Err(Error::new("Unsupported binary operation", Span::dummy())),
    |                                                                                ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/consteval/mod.rs:181:70
    |
181 |             _ => Err(Error::new("Type mismatch in binary operation", Span::dummy())),
    |                                                                      ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0412]: cannot find type `UnaryOp` in this scope
   --> compiler/src/consteval/mod.rs:185:33
    |
185 |     fn eval_unary_op(&self, op: UnaryOp, val: &ConstValue) -> Result<ConstValue> {
    |                                 ^^^^^^^ not found in this scope
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::UnaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `UnaryOp`
   --> compiler/src/consteval/mod.rs:189:21
    |
189 |                     UnaryOp::Neg => ConstValue::Int(-n),
    |                     ^^^^^^^ use of undeclared type `UnaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::UnaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `UnaryOp`
   --> compiler/src/consteval/mod.rs:190:21
    |
190 |                     UnaryOp::Not => ConstValue::Bool(*n == 0),
    |                     ^^^^^^^ use of undeclared type `UnaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::UnaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `UnaryOp`
   --> compiler/src/consteval/mod.rs:191:21
    |
191 |                     UnaryOp::BitNot => ConstValue::Int(!n),
    |                     ^^^^^^^ use of undeclared type `UnaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::UnaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/consteval/mod.rs:192:79
    |
192 |                     _ => return Err(Error::new("Unsupported unary operation", Span::dummy())),
    |                                                                               ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0433]: failed to resolve: use of undeclared type `UnaryOp`
   --> compiler/src/consteval/mod.rs:199:21
    |
199 |                     UnaryOp::Neg => ConstValue::Float(-f),
    |                     ^^^^^^^ use of undeclared type `UnaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::UnaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/consteval/mod.rs:200:79
    |
200 |                     _ => return Err(Error::new("Unsupported unary operation", Span::dummy())),
    |                                                                               ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0433]: failed to resolve: use of undeclared type `UnaryOp`
   --> compiler/src/consteval/mod.rs:207:21
    |
207 |                     UnaryOp::Not => ConstValue::Bool(!b),
    |                     ^^^^^^^ use of undeclared type `UnaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::UnaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/consteval/mod.rs:208:79
    |
208 |                     _ => return Err(Error::new("Unsupported unary operation", Span::dummy())),
    |                                                                               ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/consteval/mod.rs:213:69
    |
213 |             _ => Err(Error::new("Type mismatch in unary operation", Span::dummy())),
    |                                                                     ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/consteval/mod.rs:221:65
    |
221 |             _ => return Err(Error::new("Invalid function call", Span::dummy())),
    |                                                                 ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/consteval/mod.rs:239:17
    |
239 |                 Span::dummy()
    |                 ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/consteval/mod.rs:246:61
    |
246 |             return Err(Error::new("abs expects 1 argument", Span::dummy()));
    |                                                             ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/consteval/mod.rs:252:65
    |
252 |             _ => Err(Error::new("abs expects numeric argument", Span::dummy())),
    |                                                                 ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/consteval/mod.rs:258:62
    |
258 |             return Err(Error::new("min expects 2 arguments", Span::dummy()));
    |                                                              ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/consteval/mod.rs:264:66
    |
264 |             _ => Err(Error::new("min expects numeric arguments", Span::dummy())),
    |                                                                  ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/consteval/mod.rs:270:62
    |
270 |             return Err(Error::new("max expects 2 arguments", Span::dummy()));
    |                                                              ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/consteval/mod.rs:276:66
    |
276 |             _ => Err(Error::new("max expects numeric arguments", Span::dummy())),
    |                                                                  ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/consteval/mod.rs:282:62
    |
282 |             return Err(Error::new("pow expects 2 arguments", Span::dummy()));
    |                                                              ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/consteval/mod.rs:291:80
    |
291 |                     return Err(Error::new("Negative exponent for integer pow", Span::dummy()));
    |                                                                                ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/consteval/mod.rs:295:66
    |
295 |             _ => Err(Error::new("pow expects numeric arguments", Span::dummy())),
    |                                                                  ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

   Compiling serde_spanned v0.6.9
   Compiling toml_datetime v0.6.11
   Compiling vez_testing v1.0.0 (/run/media/zarigata/42A0B8BDA0B8B8AD/ARTIFICIAL-INTELIGENCE/ArtificialProgramingLanguage/tools/testing)
error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/consteval/mod.rs:301:62
    |
301 |             return Err(Error::new("sqrt expects 1 argument", Span::dummy()));
    |                                                              ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/consteval/mod.rs:307:70
    |
307 |                     return Err(Error::new("sqrt of negative number", Span::dummy()));
    |                                                                      ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/consteval/mod.rs:311:64
    |
311 |             _ => Err(Error::new("sqrt expects float argument", Span::dummy())),
    |                                                                ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0412]: cannot find type `BinaryOp` in this scope
  --> compiler/src/plugin/api.rs:60:40
   |
60 |     pub fn create_binary_op(&self, op: BinaryOp, left: Expr, right: Expr) -> Expr {
   |                                        ^^^^^^^^ not found in this scope
   |
help: consider importing this enum
   |
 4 + use crate::ir::instructions::BinaryOp;
   |

error[E0412]: cannot find type `Span` in this scope
   --> compiler/src/plugin/mod.rs:151:19
    |
151 |     pub location: Span,
    |                   ^^^^ not found in this scope
    |
help: consider importing this struct through its public re-export
    |
  9 + use crate::prelude::Span;
    |

error[E0659]: `Function` is ambiguous
  --> compiler/src/gpu/mod.rs:78:42
   |
78 |     pub fn generate_kernel(&self, func: &Function) -> Result<String> {
   |                                          ^^^^^^^^ ambiguous name
   |
   = note: ambiguous because of multiple glob imports of a name in the same module
note: `Function` could refer to the struct imported here
  --> compiler/src/gpu/mod.rs:9:5
   |
 9 | use crate::parser::ast::*;
   |     ^^^^^^^^^^^^^^^^^^^^^
   = help: consider adding an explicit import of `Function` to disambiguate
note: `Function` could also refer to the struct imported here
  --> compiler/src/gpu/mod.rs:10:5
   |
10 | use crate::ir::ssa::*;
   |     ^^^^^^^^^^^^^^^^^
   = help: consider adding an explicit import of `Function` to disambiguate

error[E0659]: `Function` is ambiguous
  --> compiler/src/gpu/mod.rs:87:43
   |
87 |     fn generate_cuda_kernel(&self, func: &Function) -> Result<String> {
   |                                           ^^^^^^^^ ambiguous name
   |
   = note: ambiguous because of multiple glob imports of a name in the same module
note: `Function` could refer to the struct imported here
  --> compiler/src/gpu/mod.rs:9:5
   |
 9 | use crate::parser::ast::*;
   |     ^^^^^^^^^^^^^^^^^^^^^
   = help: consider adding an explicit import of `Function` to disambiguate
note: `Function` could also refer to the struct imported here
  --> compiler/src/gpu/mod.rs:10:5
   |
10 | use crate::ir::ssa::*;
   |     ^^^^^^^^^^^^^^^^^
   = help: consider adding an explicit import of `Function` to disambiguate

error[E0659]: `Function` is ambiguous
   --> compiler/src/gpu/mod.rs:120:44
    |
120 |     fn generate_metal_kernel(&self, func: &Function) -> Result<String> {
    |                                            ^^^^^^^^ ambiguous name
    |
    = note: ambiguous because of multiple glob imports of a name in the same module
note: `Function` could refer to the struct imported here
   --> compiler/src/gpu/mod.rs:9:5
    |
  9 | use crate::parser::ast::*;
    |     ^^^^^^^^^^^^^^^^^^^^^
    = help: consider adding an explicit import of `Function` to disambiguate
note: `Function` could also refer to the struct imported here
   --> compiler/src/gpu/mod.rs:10:5
    |
 10 | use crate::ir::ssa::*;
    |     ^^^^^^^^^^^^^^^^^
    = help: consider adding an explicit import of `Function` to disambiguate

error[E0659]: `Function` is ambiguous
   --> compiler/src/gpu/mod.rs:157:45
    |
157 |     fn generate_vulkan_kernel(&self, func: &Function) -> Result<String> {
    |                                             ^^^^^^^^ ambiguous name
    |
    = note: ambiguous because of multiple glob imports of a name in the same module
note: `Function` could refer to the struct imported here
   --> compiler/src/gpu/mod.rs:9:5
    |
  9 | use crate::parser::ast::*;
    |     ^^^^^^^^^^^^^^^^^^^^^
    = help: consider adding an explicit import of `Function` to disambiguate
note: `Function` could also refer to the struct imported here
   --> compiler/src/gpu/mod.rs:10:5
    |
 10 | use crate::ir::ssa::*;
    |     ^^^^^^^^^^^^^^^^^
    = help: consider adding an explicit import of `Function` to disambiguate

error[E0659]: `Function` is ambiguous
   --> compiler/src/gpu/mod.rs:193:45
    |
193 |     fn generate_opencl_kernel(&self, func: &Function) -> Result<String> {
    |                                             ^^^^^^^^ ambiguous name
    |
    = note: ambiguous because of multiple glob imports of a name in the same module
note: `Function` could refer to the struct imported here
   --> compiler/src/gpu/mod.rs:9:5
    |
  9 | use crate::parser::ast::*;
    |     ^^^^^^^^^^^^^^^^^^^^^
    = help: consider adding an explicit import of `Function` to disambiguate
note: `Function` could also refer to the struct imported here
   --> compiler/src/gpu/mod.rs:10:5
    |
 10 | use crate::ir::ssa::*;
    |     ^^^^^^^^^^^^^^^^^
    = help: consider adding an explicit import of `Function` to disambiguate

error[E0659]: `Function` is ambiguous
   --> compiler/src/gpu/mod.rs:227:43
    |
227 |     fn generate_kernel_body(&self, func: &Function) -> Result<String> {
    |                                           ^^^^^^^^ ambiguous name
    |
    = note: ambiguous because of multiple glob imports of a name in the same module
note: `Function` could refer to the struct imported here
   --> compiler/src/gpu/mod.rs:9:5
    |
  9 | use crate::parser::ast::*;
    |     ^^^^^^^^^^^^^^^^^^^^^
    = help: consider adding an explicit import of `Function` to disambiguate
note: `Function` could also refer to the struct imported here
   --> compiler/src/gpu/mod.rs:10:5
    |
 10 | use crate::ir::ssa::*;
    |     ^^^^^^^^^^^^^^^^^
    = help: consider adding an explicit import of `Function` to disambiguate

warning: unused import: `TypeVar`
 --> compiler/src/semantic/type_checker.rs:6:69
  |
6 | use super::type_env::{TypeEnv, InferredType, Substitution, Unifier, TypeVar};
  |                                                                     ^^^^^^^
  |
  = note: `#[warn(unused_imports)]` (part of `#[warn(unused)]`) on by default

warning: unused import: `BasicBlock`
 --> compiler/src/ir/builder.rs:5:42
  |
5 | use super::ssa::{Function as IrFunction, BasicBlock, Value, ValueId, Constant, Module};
  |                                          ^^^^^^^^^^

warning: unused import: `crate::ir::types::IrType`
 --> compiler/src/optimizer/constant_folding.rs:5:5
  |
5 | use crate::ir::types::IrType;
  |     ^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `ValueId`
 --> compiler/src/optimizer/inline.rs:3:54
  |
3 | use crate::ir::ssa::{Module, Function as IrFunction, ValueId};
  |                                                      ^^^^^^^

warning: unused import: `Path`
 --> compiler/src/codegen/linker.rs:5:17
  |
5 | use std::path::{Path, PathBuf};
  |                 ^^^^

warning: unused import: `crate::parser::ast::*`
 --> compiler/src/macro_system/mod.rs:9:5
  |
9 | use crate::parser::ast::*;
  |     ^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `std::prelude::*`
 --> compiler/src/async_runtime/mod.rs:9:5
  |
9 | use std::prelude::*;
  |     ^^^^^^^^^^^^^^^

warning: unused import: `Error`
  --> compiler/src/verification/mod.rs:11:20
   |
11 | use crate::error::{Error, Result};
   |                    ^^^^^

warning: unused import: `std::collections::HashMap`
  --> compiler/src/verification/mod.rs:12:5
   |
12 | use std::collections::HashMap;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `crate::ir::ssa::*`
  --> compiler/src/gpu/mod.rs:10:5
   |
10 | use crate::ir::ssa::*;
   |     ^^^^^^^^^^^^^^^^^

warning: unused import: `Error`
  --> compiler/src/gpu/mod.rs:11:20
   |
11 | use crate::error::{Error, Result};
   |                    ^^^^^

warning: unused import: `std::collections::HashMap`
 --> tools/testing/src/framework.rs:4:5
  |
4 | use std::collections::HashMap;
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` (part of `#[warn(unused)]`) on by default

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/verification/mod.rs:364:19
    |
364 |             span: Span::dummy(),
    |                   ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
344 +     use crate::prelude::Span;
    |

   Compiling toml_edit v0.22.27
error[E0277]: `F1` is not a future
   --> compiler/src/async_runtime/mod.rs:113:17
    |
113 |     let r1 = f1.await;
    |                 ^^^^^ `F1` is not a future
    |
    = note: F1 must be a future or must implement `IntoFuture` to be awaited
    = note: required for `F1` to implement `IntoFuture`
help: remove the `.await`
    |
113 -     let r1 = f1.await;
113 +     let r1 = f1;
    |
help: consider further restricting type parameter `F1` with trait `Future`
    |
110 |     F1: Future + std::future::Future,
    |                +++++++++++++++++++++

error[E0277]: `F2` is not a future
   --> compiler/src/async_runtime/mod.rs:114:17
    |
114 |     let r2 = f2.await;
    |                 ^^^^^ `F2` is not a future
    |
    = note: F2 must be a future or must implement `IntoFuture` to be awaited
    = note: required for `F2` to implement `IntoFuture`
help: remove the `.await`
    |
114 -     let r2 = f2.await;
114 +     let r2 = f2;
    |
help: consider further restricting type parameter `F2` with trait `Future`
    |
111 |     F2: Future + std::future::Future,
    |                +++++++++++++++++++++

error[E0023]: this pattern has 1 field, but the corresponding tuple variant has 2 fields
  --> compiler/src/lexer/token.rs:66:35
   |
26 |     IntLiteral(String, Option<String>),   // value, optional suffix (i32, u64, etc.)
   |                ------  -------------- tuple variant has 2 fields
...
66 |             TokenKind::IntLiteral(_) | TokenKind::FloatLiteral(_) |
   |                                   ^ expected 2 fields, found 1
   |
help: use `_` to explicitly ignore each field
   |
66 |             TokenKind::IntLiteral(_, _) | TokenKind::FloatLiteral(_) |
   |                                    +++
help: use `..` to ignore all fields
   |
66 -             TokenKind::IntLiteral(_) | TokenKind::FloatLiteral(_) |
66 +             TokenKind::IntLiteral(..) | TokenKind::FloatLiteral(_) |
   |

error[E0023]: this pattern has 1 field, but the corresponding tuple variant has 2 fields
  --> compiler/src/lexer/token.rs:66:64
   |
27 |     FloatLiteral(String, Option<String>), // value, optional suffix (f32, f64)
   |                  ------  -------------- tuple variant has 2 fields
...
66 |             TokenKind::IntLiteral(_) | TokenKind::FloatLiteral(_) |
   |                                                                ^ expected 2 fields, found 1
   |
help: use `_` to explicitly ignore each field
   |
66 |             TokenKind::IntLiteral(_) | TokenKind::FloatLiteral(_, _) |
   |                                                                 +++
help: use `..` to ignore all fields
   |
66 -             TokenKind::IntLiteral(_) | TokenKind::FloatLiteral(_) |
66 +             TokenKind::IntLiteral(_) | TokenKind::FloatLiteral(..) |
   |

error[E0308]: mismatched types
   --> compiler/src/lexer/mod.rs:689:13
    |
682 |     fn lex_slash(&mut self) -> Result<TokenKind> {
    |                                ----------------- expected `std::result::Result<TokenKind, error::Error>` because of return type
...
689 |             self.next_token() // Skip comment and get next token
    |             ^^^^^^^^^^^^^^^^^ expected `Result<TokenKind, Error>`, found `Result<Token, Error>`
    |
    = note: expected enum `std::result::Result<TokenKind, _>`
               found enum `std::result::Result<Token, _>`

error[E0308]: mismatched types
   --> compiler/src/lexer/mod.rs:698:32
    |
682 |     fn lex_slash(&mut self) -> Result<TokenKind> {
    |                                ----------------- expected `std::result::Result<TokenKind, error::Error>` because of return type
...
698 |                         return self.next_token(); // Skip comment
    |                                ^^^^^^^^^^^^^^^^^ expected `Result<TokenKind, Error>`, found `Result<Token, Error>`
    |
    = note: expected enum `std::result::Result<TokenKind, _>`
               found enum `std::result::Result<Token, _>`

warning: `vez_testing` (lib) generated 1 warning (run `cargo fix --lib -p vez_testing` to apply 1 suggestion)
error[E0599]: no function or associated item named `default` found for struct `span::Span` in the current scope
  --> compiler/src/semantic/resolver.rs:66:19
   |
66 |             Span::default(),
   |                   ^^^^^^^ function or associated item not found in `span::Span`
   |
  ::: compiler/src/span.rs:31:1
   |
31 | pub struct Span {
   | --------------- function or associated item `default` not found for this struct
   |
note: if you're trying to build a new `span::Span`, consider using `span::Span::new` which returns `span::Span`
  --> compiler/src/span.rs:37:5
   |
37 |     pub fn new(start: Position, end: Position) -> Self {
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   = help: items from traits can only be used if the trait is implemented and in scope
   = note: the following trait defines an item `default`, perhaps you need to implement it:
           candidate #1: `Default`

error[E0599]: no variant or associated item named `DuplicateSymbol` found for enum `error::ErrorKind` in the current scope
  --> compiler/src/semantic/resolver.rs:71:50
   |
71 |             self.add_error(Error::new(ErrorKind::DuplicateSymbol, e));
   |                                                  ^^^^^^^^^^^^^^^ variant or associated item not found in `error::ErrorKind`
   |
  ::: compiler/src/error.rs:18:1
   |
18 | pub enum ErrorKind {
   | ------------------ variant or associated item `DuplicateSymbol` not found for this enum

error[E0599]: no function or associated item named `default` found for struct `span::Span` in the current scope
  --> compiler/src/semantic/resolver.rs:84:23
   |
84 |                 Span::default(),
   |                       ^^^^^^^ function or associated item not found in `span::Span`
   |
  ::: compiler/src/span.rs:31:1
   |
31 | pub struct Span {
   | --------------- function or associated item `default` not found for this struct
   |
note: if you're trying to build a new `span::Span`, consider using `span::Span::new` which returns `span::Span`
  --> compiler/src/span.rs:37:5
   |
37 |     pub fn new(start: Position, end: Position) -> Self {
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   = help: items from traits can only be used if the trait is implemented and in scope
   = note: the following trait defines an item `default`, perhaps you need to implement it:
           candidate #1: `Default`

error[E0599]: no variant or associated item named `DuplicateSymbol` found for enum `error::ErrorKind` in the current scope
  --> compiler/src/semantic/resolver.rs:89:54
   |
89 |                 self.add_error(Error::new(ErrorKind::DuplicateSymbol, e));
   |                                                      ^^^^^^^^^^^^^^^ variant or associated item not found in `error::ErrorKind`
   |
  ::: compiler/src/error.rs:18:1
   |
18 | pub enum ErrorKind {
   | ------------------ variant or associated item `DuplicateSymbol` not found for this enum

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/consteval/mod.rs:336:19
    |
336 |             span: Span::dummy(),
    |                   ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
328 +     use crate::prelude::Span;
    |

error[E0599]: no function or associated item named `default` found for struct `span::Span` in the current scope
  --> compiler/src/semantic/resolver.rs:99:23
   |
99 |                 Span::default(),
   |                       ^^^^^^^ function or associated item not found in `span::Span`
   |
  ::: compiler/src/span.rs:31:1
   |
31 | pub struct Span {
   | --------------- function or associated item `default` not found for this struct
   |
note: if you're trying to build a new `span::Span`, consider using `span::Span::new` which returns `span::Span`
  --> compiler/src/span.rs:37:5
   |
37 |     pub fn new(start: Position, end: Position) -> Self {
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   = help: items from traits can only be used if the trait is implemented and in scope
   = note: the following trait defines an item `default`, perhaps you need to implement it:
           candidate #1: `Default`

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:348:17
    |
348 |             op: BinaryOp::Add,
    |                 ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
328 +     use crate::ir::instructions::BinaryOp;
    |

error[E0599]: no variant or associated item named `DuplicateSymbol` found for enum `error::ErrorKind` in the current scope
   --> compiler/src/semantic/resolver.rs:104:54
    |
104 |                 self.add_error(Error::new(ErrorKind::DuplicateSymbol, e));
    |                                                      ^^^^^^^^^^^^^^^ variant or associated item not found in `error::ErrorKind`
    |
   ::: compiler/src/error.rs:18:1
    |
 18 | pub enum ErrorKind {
    | ------------------ variant or associated item `DuplicateSymbol` not found for this enum

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/consteval/mod.rs:351:23
    |
351 |                 span: Span::dummy(),
    |                       ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
328 +     use crate::prelude::Span;
    |

error[E0599]: no function or associated item named `default` found for struct `span::Span` in the current scope
   --> compiler/src/semantic/resolver.rs:122:19
    |
122 |             Span::default(),
    |                   ^^^^^^^ function or associated item not found in `span::Span`
    |
   ::: compiler/src/span.rs:31:1
    |
 31 | pub struct Span {
    | --------------- function or associated item `default` not found for this struct
    |
note: if you're trying to build a new `span::Span`, consider using `span::Span::new` which returns `span::Span`
   --> compiler/src/span.rs:37:5
    |
 37 |     pub fn new(start: Position, end: Position) -> Self {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    = help: items from traits can only be used if the trait is implemented and in scope
    = note: the following trait defines an item `default`, perhaps you need to implement it:
            candidate #1: `Default`

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/consteval/mod.rs:355:23
    |
355 |                 span: Span::dummy(),
    |                       ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
328 +     use crate::prelude::Span;
    |

error[E0599]: no variant or associated item named `DuplicateSymbol` found for enum `error::ErrorKind` in the current scope
   --> compiler/src/semantic/resolver.rs:127:50
    |
127 |             self.add_error(Error::new(ErrorKind::DuplicateSymbol, e));
    |                                                  ^^^^^^^^^^^^^^^ variant or associated item not found in `error::ErrorKind`
    |
   ::: compiler/src/error.rs:18:1
    |
 18 | pub enum ErrorKind {
    | ------------------ variant or associated item `DuplicateSymbol` not found for this enum

error[E0599]: no function or associated item named `default` found for struct `span::Span` in the current scope
   --> compiler/src/semantic/resolver.rs:136:19
    |
136 |             Span::default(),
    |                   ^^^^^^^ function or associated item not found in `span::Span`
    |
   ::: compiler/src/span.rs:31:1
    |
 31 | pub struct Span {
    | --------------- function or associated item `default` not found for this struct
    |
note: if you're trying to build a new `span::Span`, consider using `span::Span::new` which returns `span::Span`
   --> compiler/src/span.rs:37:5
    |
 37 |     pub fn new(start: Position, end: Position) -> Self {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    = help: items from traits can only be used if the trait is implemented and in scope
    = note: the following trait defines an item `default`, perhaps you need to implement it:
            candidate #1: `Default`

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/consteval/mod.rs:357:19
    |
357 |             span: Span::dummy(),
    |                   ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
328 +     use crate::prelude::Span;
    |

error[E0599]: no variant or associated item named `DuplicateSymbol` found for enum `error::ErrorKind` in the current scope
   --> compiler/src/semantic/resolver.rs:141:50
    |
141 |             self.add_error(Error::new(ErrorKind::DuplicateSymbol, e));
    |                                                  ^^^^^^^^^^^^^^^ variant or associated item not found in `error::ErrorKind`
    |
   ::: compiler/src/error.rs:18:1
    |
 18 | pub enum ErrorKind {
    | ------------------ variant or associated item `DuplicateSymbol` not found for this enum

error[E0599]: no function or associated item named `default` found for struct `span::Span` in the current scope
   --> compiler/src/semantic/resolver.rs:151:23
    |
151 |                 Span::default(),
    |                       ^^^^^^^ function or associated item not found in `span::Span`
    |
   ::: compiler/src/span.rs:31:1
    |
 31 | pub struct Span {
    | --------------- function or associated item `default` not found for this struct
    |
note: if you're trying to build a new `span::Span`, consider using `span::Span::new` which returns `span::Span`
   --> compiler/src/span.rs:37:5
    |
 37 |     pub fn new(start: Position, end: Position) -> Self {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    = help: items from traits can only be used if the trait is implemented and in scope
    = note: the following trait defines an item `default`, perhaps you need to implement it:
            candidate #1: `Default`

error[E0599]: no variant or associated item named `DuplicateSymbol` found for enum `error::ErrorKind` in the current scope
   --> compiler/src/semantic/resolver.rs:156:54
    |
156 |                 self.add_error(Error::new(ErrorKind::DuplicateSymbol, e));
    |                                                      ^^^^^^^^^^^^^^^ variant or associated item not found in `error::ErrorKind`
    |
   ::: compiler/src/error.rs:18:1
    |
 18 | pub enum ErrorKind {
    | ------------------ variant or associated item `DuplicateSymbol` not found for this enum

error[E0599]: no function or associated item named `default` found for struct `span::Span` in the current scope
   --> compiler/src/semantic/resolver.rs:166:19
    |
166 |             Span::default(),
    |                   ^^^^^^^ function or associated item not found in `span::Span`
    |
   ::: compiler/src/span.rs:31:1
    |
 31 | pub struct Span {
    | --------------- function or associated item `default` not found for this struct
    |
note: if you're trying to build a new `span::Span`, consider using `span::Span::new` which returns `span::Span`
   --> compiler/src/span.rs:37:5
    |
 37 |     pub fn new(start: Position, end: Position) -> Self {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    = help: items from traits can only be used if the trait is implemented and in scope
    = note: the following trait defines an item `default`, perhaps you need to implement it:
            candidate #1: `Default`

error[E0599]: no variant or associated item named `DuplicateSymbol` found for enum `error::ErrorKind` in the current scope
   --> compiler/src/semantic/resolver.rs:171:50
    |
171 |             self.add_error(Error::new(ErrorKind::DuplicateSymbol, e));
    |                                                  ^^^^^^^^^^^^^^^ variant or associated item not found in `error::ErrorKind`
    |
   ::: compiler/src/error.rs:18:1
    |
 18 | pub enum ErrorKind {
    | ------------------ variant or associated item `DuplicateSymbol` not found for this enum

error[E0599]: no function or associated item named `default` found for struct `span::Span` in the current scope
   --> compiler/src/semantic/resolver.rs:185:23
    |
185 |                 Span::default(),
    |                       ^^^^^^^ function or associated item not found in `span::Span`
    |
   ::: compiler/src/span.rs:31:1
    |
 31 | pub struct Span {
    | --------------- function or associated item `default` not found for this struct
    |
note: if you're trying to build a new `span::Span`, consider using `span::Span::new` which returns `span::Span`
   --> compiler/src/span.rs:37:5
    |
 37 |     pub fn new(start: Position, end: Position) -> Self {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    = help: items from traits can only be used if the trait is implemented and in scope
    = note: the following trait defines an item `default`, perhaps you need to implement it:
            candidate #1: `Default`

error[E0599]: no variant or associated item named `DuplicateSymbol` found for enum `error::ErrorKind` in the current scope
   --> compiler/src/semantic/resolver.rs:190:54
    |
190 |                 self.add_error(Error::new(ErrorKind::DuplicateSymbol, e));
    |                                                      ^^^^^^^^^^^^^^^ variant or associated item not found in `error::ErrorKind`
    |
   ::: compiler/src/error.rs:18:1
    |
 18 | pub enum ErrorKind {
    | ------------------ variant or associated item `DuplicateSymbol` not found for this enum

error[E0599]: no function or associated item named `default` found for struct `span::Span` in the current scope
   --> compiler/src/semantic/resolver.rs:217:19
    |
217 |             Span::default(),
    |                   ^^^^^^^ function or associated item not found in `span::Span`
    |
   ::: compiler/src/span.rs:31:1
    |
 31 | pub struct Span {
    | --------------- function or associated item `default` not found for this struct
    |
note: if you're trying to build a new `span::Span`, consider using `span::Span::new` which returns `span::Span`
   --> compiler/src/span.rs:37:5
    |
 37 |     pub fn new(start: Position, end: Position) -> Self {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    = help: items from traits can only be used if the trait is implemented and in scope
    = note: the following trait defines an item `default`, perhaps you need to implement it:
            candidate #1: `Default`

error[E0599]: no variant or associated item named `DuplicateSymbol` found for enum `error::ErrorKind` in the current scope
   --> compiler/src/semantic/resolver.rs:222:50
    |
222 |             self.add_error(Error::new(ErrorKind::DuplicateSymbol, e));
    |                                                  ^^^^^^^^^^^^^^^ variant or associated item not found in `error::ErrorKind`
    |
   ::: compiler/src/error.rs:18:1
    |
 18 | pub enum ErrorKind {
    | ------------------ variant or associated item `DuplicateSymbol` not found for this enum

warning: unused import: `crate::ir::ssa::ValueId`
   --> compiler/src/optimizer/constant_folding.rs:225:9
    |
225 |     use crate::ir::ssa::ValueId;
    |         ^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `BasicBlock`
   --> compiler/src/optimizer/dead_code.rs:117:26
    |
117 |     use crate::ir::ssa::{BasicBlock, ValueId};
    |                          ^^^^^^^^^^

error[E0599]: no function or associated item named `default` found for struct `span::Span` in the current scope
   --> compiler/src/semantic/resolver.rs:250:27
    |
250 |                     Span::default(),
    |                           ^^^^^^^ function or associated item not found in `span::Span`
    |
   ::: compiler/src/span.rs:31:1
    |
 31 | pub struct Span {
    | --------------- function or associated item `default` not found for this struct
    |
note: if you're trying to build a new `span::Span`, consider using `span::Span::new` which returns `span::Span`
   --> compiler/src/span.rs:37:5
    |
 37 |     pub fn new(start: Position, end: Position) -> Self {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    = help: items from traits can only be used if the trait is implemented and in scope
    = note: the following trait defines an item `default`, perhaps you need to implement it:
            candidate #1: `Default`

error[E0599]: no variant or associated item named `DuplicateSymbol` found for enum `error::ErrorKind` in the current scope
   --> compiler/src/semantic/resolver.rs:259:58
    |
259 |                     self.add_error(Error::new(ErrorKind::DuplicateSymbol, e));
    |                                                          ^^^^^^^^^^^^^^^ variant or associated item not found in `error::ErrorKind`
    |
   ::: compiler/src/error.rs:18:1
    |
 18 | pub enum ErrorKind {
    | ------------------ variant or associated item `DuplicateSymbol` not found for this enum

error[E0599]: no function or associated item named `default` found for struct `span::Span` in the current scope
   --> compiler/src/semantic/resolver.rs:357:27
    |
357 |                     Span::default(),
    |                           ^^^^^^^ function or associated item not found in `span::Span`
    |
   ::: compiler/src/span.rs:31:1
    |
 31 | pub struct Span {
    | --------------- function or associated item `default` not found for this struct
    |
note: if you're trying to build a new `span::Span`, consider using `span::Span::new` which returns `span::Span`
   --> compiler/src/span.rs:37:5
    |
 37 |     pub fn new(start: Position, end: Position) -> Self {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    = help: items from traits can only be used if the trait is implemented and in scope
    = note: the following trait defines an item `default`, perhaps you need to implement it:
            candidate #1: `Default`

error[E0599]: no variant or associated item named `DuplicateSymbol` found for enum `error::ErrorKind` in the current scope
   --> compiler/src/semantic/resolver.rs:362:58
    |
362 |                     self.add_error(Error::new(ErrorKind::DuplicateSymbol, e));
    |                                                          ^^^^^^^^^^^^^^^ variant or associated item not found in `error::ErrorKind`
    |
   ::: compiler/src/error.rs:18:1
    |
 18 | pub enum ErrorKind {
    | ------------------ variant or associated item `DuplicateSymbol` not found for this enum

error[E0599]: no function or associated item named `default` found for struct `span::Span` in the current scope
   --> compiler/src/semantic/resolver.rs:407:27
    |
407 |                     Span::default(),
    |                           ^^^^^^^ function or associated item not found in `span::Span`
    |
   ::: compiler/src/span.rs:31:1
    |
 31 | pub struct Span {
    | --------------- function or associated item `default` not found for this struct
    |
note: if you're trying to build a new `span::Span`, consider using `span::Span::new` which returns `span::Span`
   --> compiler/src/span.rs:37:5
    |
 37 |     pub fn new(start: Position, end: Position) -> Self {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    = help: items from traits can only be used if the trait is implemented and in scope
    = note: the following trait defines an item `default`, perhaps you need to implement it:
            candidate #1: `Default`

error[E0599]: no variant or associated item named `DuplicateSymbol` found for enum `error::ErrorKind` in the current scope
   --> compiler/src/semantic/resolver.rs:412:58
    |
412 |                     self.add_error(Error::new(ErrorKind::DuplicateSymbol, e));
    |                                                          ^^^^^^^^^^^^^^^ variant or associated item not found in `error::ErrorKind`
    |
   ::: compiler/src/error.rs:18:1
    |
 18 | pub enum ErrorKind {
    | ------------------ variant or associated item `DuplicateSymbol` not found for this enum

error[E0599]: no variant or associated item named `TypeError` found for enum `error::ErrorKind` in the current scope
   --> compiler/src/semantic/type_env.rs:239:36
    |
239 |                         ErrorKind::TypeError,
    |                                    ^^^^^^^^^ variant or associated item not found in `error::ErrorKind`
    |
   ::: compiler/src/error.rs:18:1
    |
 18 | pub enum ErrorKind {
    | ------------------ variant or associated item `TypeError` not found for this enum
    |
help: there is a variant with a similar name
    |
239 -                         ErrorKind::TypeError,
240 -                         "Occurs check failed: infinite type"
241 -                     ))
239 +                         ErrorKind::MoveError)
    |

error[E0599]: no variant or associated item named `TypeError` found for enum `error::ErrorKind` in the current scope
   --> compiler/src/semantic/type_env.rs:253:36
    |
253 |                         ErrorKind::TypeError,
    |                                    ^^^^^^^^^ variant or associated item not found in `error::ErrorKind`
    |
   ::: compiler/src/error.rs:18:1
    |
 18 | pub enum ErrorKind {
    | ------------------ variant or associated item `TypeError` not found for this enum
    |
help: there is a variant with a similar name
    |
253 -                         ErrorKind::TypeError,
254 -                         format!("Function arity mismatch: {} vs {}", params1.len(), params2.len())
255 -                     ));
253 +                         ErrorKind::MoveError);
    |

error[E0599]: no variant or associated item named `TypeError` found for enum `error::ErrorKind` in the current scope
   --> compiler/src/semantic/type_env.rs:275:36
    |
275 |                         ErrorKind::TypeError,
    |                                    ^^^^^^^^^ variant or associated item not found in `error::ErrorKind`
    |
   ::: compiler/src/error.rs:18:1
    |
 18 | pub enum ErrorKind {
    | ------------------ variant or associated item `TypeError` not found for this enum
    |
help: there is a variant with a similar name
    |
275 -                         ErrorKind::TypeError,
276 -                         format!("Type mismatch: {} vs {}", name1, name2)
277 -                     ));
275 +                         ErrorKind::MoveError);
    |

error[E0599]: no variant or associated item named `TypeError` found for enum `error::ErrorKind` in the current scope
   --> compiler/src/semantic/type_env.rs:282:36
    |
282 |                         ErrorKind::TypeError,
    |                                    ^^^^^^^^^ variant or associated item not found in `error::ErrorKind`
    |
   ::: compiler/src/error.rs:18:1
    |
 18 | pub enum ErrorKind {
    | ------------------ variant or associated item `TypeError` not found for this enum
    |
help: there is a variant with a similar name
    |
282 -                         ErrorKind::TypeError,
283 -                         "Generic argument count mismatch"
284 -                     ));
282 +                         ErrorKind::MoveError);
    |

error[E0599]: no variant or associated item named `TypeError` found for enum `error::ErrorKind` in the current scope
   --> compiler/src/semantic/type_env.rs:300:36
    |
300 |                         ErrorKind::TypeError,
    |                                    ^^^^^^^^^ variant or associated item not found in `error::ErrorKind`
    |
   ::: compiler/src/error.rs:18:1
    |
 18 | pub enum ErrorKind {
    | ------------------ variant or associated item `TypeError` not found for this enum
    |
help: there is a variant with a similar name
    |
300 -                         ErrorKind::TypeError,
301 -                         "Tuple size mismatch"
302 -                     ));
300 +                         ErrorKind::MoveError);
    |

error[E0599]: no variant or associated item named `TypeError` found for enum `error::ErrorKind` in the current scope
   --> compiler/src/semantic/type_env.rs:318:36
    |
318 |                         ErrorKind::TypeError,
    |                                    ^^^^^^^^^ variant or associated item not found in `error::ErrorKind`
    |
   ::: compiler/src/error.rs:18:1
    |
 18 | pub enum ErrorKind {
    | ------------------ variant or associated item `TypeError` not found for this enum
    |
help: there is a variant with a similar name
    |
318 -                         ErrorKind::TypeError,
319 -                         "Array size mismatch"
320 -                     ));
318 +                         ErrorKind::MoveError);
    |

error[E0599]: no variant or associated item named `TypeError` found for enum `error::ErrorKind` in the current scope
   --> compiler/src/semantic/type_env.rs:341:36
    |
341 |                         ErrorKind::TypeError,
    |                                    ^^^^^^^^^ variant or associated item not found in `error::ErrorKind`
    |
   ::: compiler/src/error.rs:18:1
    |
 18 | pub enum ErrorKind {
    | ------------------ variant or associated item `TypeError` not found for this enum
    |
help: there is a variant with a similar name
    |
341 -                         ErrorKind::TypeError,
342 -                         format!("Type mismatch: {} vs {}", n1, n2)
343 -                     ))
341 +                         ErrorKind::MoveError)
    |

error[E0599]: no variant or associated item named `TypeError` found for enum `error::ErrorKind` in the current scope
   --> compiler/src/semantic/type_env.rs:349:28
    |
349 |                 ErrorKind::TypeError,
    |                            ^^^^^^^^^ variant or associated item not found in `error::ErrorKind`
    |
   ::: compiler/src/error.rs:18:1
    |
 18 | pub enum ErrorKind {
    | ------------------ variant or associated item `TypeError` not found for this enum
    |
help: there is a variant with a similar name
    |
349 -                 ErrorKind::TypeError,
350 -                 format!("Cannot unify types: {:?} and {:?}", t1, t2)
351 -             ))
349 +                 ErrorKind::MoveError)
    |

error[E0599]: no variant or associated item named `TypeError` found for enum `error::ErrorKind` in the current scope
   --> compiler/src/semantic/type_checker.rs:144:36
    |
144 |                         ErrorKind::TypeError,
    |                                    ^^^^^^^^^ variant or associated item not found in `error::ErrorKind`
    |
   ::: compiler/src/error.rs:18:1
    |
 18 | pub enum ErrorKind {
    | ------------------ variant or associated item `TypeError` not found for this enum
    |
help: there is a variant with a similar name
    |
144 -                         ErrorKind::TypeError,
145 -                         "Let binding must have type annotation or initializer"
146 -                     ));
144 +                         ErrorKind::MoveError);
    |

warning: unreachable expression
  --> compiler/src/codegen/llvm_backend.rs:46:9
   |
33 |         return "x86_64-unknown-linux-gnu".to_string();
   |         --------------------------------------------- any code following this expression is unreachable
...
46 |         "unknown-unknown-unknown".to_string()
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ unreachable expression
   |
   = note: `#[warn(unreachable_code)]` (part of `#[warn(unused)]`) on by default

error[E0599]: no variant or associated item named `I1` found for enum `IrType` in the current scope
  --> compiler/src/codegen/llvm_backend.rs:60:21
   |
60 |             IrType::I1 => "i1".to_string(),
   |                     ^^ variant or associated item not found in `IrType`
   |
  ::: compiler/src/ir/types.rs:7:1
   |
 7 | pub enum IrType {
   | --------------- variant or associated item `I1` not found for this enum
   |
help: there is a variant with a similar name
   |
60 -             IrType::I1 => "i1".to_string(),
60 +             IrType::I8 => "i1".to_string(),
   |

error[E0599]: no variant or associated item named `Ptr` found for enum `IrType` in the current scope
  --> compiler/src/codegen/llvm_backend.rs:73:21
   |
73 |             IrType::Ptr(inner) => format!("{}*", self.type_to_llvm(inner)),
   |                     ^^^ variant or associated item not found in `IrType`
   |
  ::: compiler/src/ir/types.rs:7:1
   |
 7 | pub enum IrType {
   | --------------- variant or associated item `Ptr` not found for this enum

error[E0026]: variant `Instruction::Branch` does not have fields named `true_bb`, `false_bb`
   --> compiler/src/codegen/llvm_backend.rs:290:41
    |
290 |             Instruction::Branch { cond, true_bb, false_bb } => {
    |                                         ^^^^^^^  ^^^^^^^^ variant `Instruction::Branch` does not have these fields

error[E0027]: pattern does not mention fields `then_block`, `else_block`
   --> compiler/src/codegen/llvm_backend.rs:290:13
    |
290 |             Instruction::Branch { cond, true_bb, false_bb } => {
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ missing fields `then_block`, `else_block`
    |
help: include the missing fields in the pattern
    |
290 |             Instruction::Branch { cond, true_bb, false_bb, then_block, else_block } => {
    |                                                          ++++++++++++++++++++++++
help: if you don't care about these missing fields, you can explicitly ignore them
    |
290 |             Instruction::Branch { cond, true_bb, false_bb, then_block: _, else_block: _ } => {
    |                                                          ++++++++++++++++++++++++++++++
help: or always ignore missing fields here
    |
290 |             Instruction::Branch { cond, true_bb, false_bb, .. } => {
    |                                                          ++++

error[E0609]: no field `0` on type `&usize`
   --> compiler/src/codegen/llvm_backend.rs:295:53
    |
295 |                 Ok(format!("br label %bb{}", target.0))
    |                                                     ^ unknown field

error[E0609]: no field `0` on type `&usize`
   --> compiler/src/codegen/llvm_backend.rs:305:63
    |
305 |                         format!("[ {}, %bb{} ]", val_name, bb.0)
    |                                                               ^ unknown field

error[E0599]: no variant or associated item named `I1` found for enum `IrType` in the current scope
   --> compiler/src/codegen/llvm_backend.rs:337:59
    |
337 |             Value::Constant(Constant::Bool(_)) => IrType::I1,
    |                                                           ^^ variant or associated item not found in `IrType`
    |
   ::: compiler/src/ir/types.rs:7:1
    |
  7 | pub enum IrType {
    | --------------- variant or associated item `I1` not found for this enum
    |
help: there is a variant with a similar name
    |
337 -             Value::Constant(Constant::Bool(_)) => IrType::I1,
337 +             Value::Constant(Constant::Bool(_)) => IrType::I8,
    |

   Compiling vez_lsp v1.0.0 (/run/media/zarigata/42A0B8BDA0B8B8AD/ARTIFICIAL-INTELIGENCE/ArtificialProgramingLanguage/tools/lsp)
error[E0599]: no variant named `MacroCall` found for enum `ast::Expr`
  --> compiler/src/macro_system/expander.rs:25:19
   |
25 |             Expr::MacroCall { name, args, span } => {
   |                   ^^^^^^^^^ variant not found in `ast::Expr`
   |
  ::: compiler/src/parser/ast.rs:94:1
   |
94 | pub enum Expr {
   | ------------- variant `MacroCall` not found here

error[E0769]: tuple variant `Expr::Binary` written as struct variant
  --> compiler/src/macro_system/expander.rs:28:13
   |
28 |             Expr::Binary { op, left, right, span } => {
   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
help: use the tuple variant pattern syntax instead
   |
28 -             Expr::Binary { op, left, right, span } => {
28 +             Expr::Binary(_, _, _) => {
   |

error[E0769]: tuple variant `Expr::Call` written as struct variant
  --> compiler/src/macro_system/expander.rs:38:13
   |
38 |             Expr::Call { func, args, span } => {
   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
help: use the tuple variant pattern syntax instead
   |
38 -             Expr::Call { func, args, span } => {
38 +             Expr::Call(_, _) => {
   |

error[E0769]: tuple variant `Expr::Block` written as struct variant
  --> compiler/src/macro_system/expander.rs:49:13
   |
49 |             Expr::Block { stmts, span } => {
   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
help: use the tuple variant pattern syntax instead
   |
49 -             Expr::Block { stmts, span } => {
49 +             Expr::Block(_) => {
   |

error[E0559]: variant `ast::Expr::Binary` has no field named `op`
  --> compiler/src/macro_system/expander.rs:32:21
   |
32 |                     op: *op,
   |                     ^^ field does not exist
   |
  ::: compiler/src/parser/ast.rs:97:5
   |
97 |     Binary(Box<Expr>, BinOp, Box<Expr>),
   |     ------ `ast::Expr::Binary` defined here
   |
help: `ast::Expr::Binary` is a tuple variant, use the appropriate syntax
   |
31 -                 Ok(Expr::Binary {
32 -                     op: *op,
33 -                     left,
34 -                     right,
35 -                     span: *span,
36 -                 })
31 +                 Ok(Expr::Binary(/* Box<ast::Expr> */, /* ast::BinOp */, /* Box<ast::Expr> */))
   |

error[E0559]: variant `ast::Expr::Binary` has no field named `left`
  --> compiler/src/macro_system/expander.rs:33:21
   |
33 |                     left,
   |                     ^^^^ field does not exist
   |
  ::: compiler/src/parser/ast.rs:97:5
   |
97 |     Binary(Box<Expr>, BinOp, Box<Expr>),
   |     ------ `ast::Expr::Binary` defined here
   |
help: `ast::Expr::Binary` is a tuple variant, use the appropriate syntax
   |
31 -                 Ok(Expr::Binary {
32 -                     op: *op,
33 -                     left,
34 -                     right,
35 -                     span: *span,
36 -                 })
31 +                 Ok(Expr::Binary(/* Box<ast::Expr> */, /* ast::BinOp */, /* Box<ast::Expr> */))
   |

error[E0559]: variant `ast::Expr::Binary` has no field named `right`
  --> compiler/src/macro_system/expander.rs:34:21
   |
34 |                     right,
   |                     ^^^^^ field does not exist
   |
  ::: compiler/src/parser/ast.rs:97:5
   |
97 |     Binary(Box<Expr>, BinOp, Box<Expr>),
   |     ------ `ast::Expr::Binary` defined here
   |
help: `ast::Expr::Binary` is a tuple variant, use the appropriate syntax
   |
31 -                 Ok(Expr::Binary {
32 -                     op: *op,
33 -                     left,
34 -                     right,
35 -                     span: *span,
36 -                 })
31 +                 Ok(Expr::Binary(/* Box<ast::Expr> */, /* ast::BinOp */, /* Box<ast::Expr> */))
   |

error[E0559]: variant `ast::Expr::Binary` has no field named `span`
  --> compiler/src/macro_system/expander.rs:35:21
   |
35 |                     span: *span,
   |                     ^^^^ field does not exist
   |
  ::: compiler/src/parser/ast.rs:97:5
   |
97 |     Binary(Box<Expr>, BinOp, Box<Expr>),
   |     ------ `ast::Expr::Binary` defined here
   |
help: `ast::Expr::Binary` is a tuple variant, use the appropriate syntax
   |
31 -                 Ok(Expr::Binary {
32 -                     op: *op,
33 -                     left,
34 -                     right,
35 -                     span: *span,
36 -                 })
31 +                 Ok(Expr::Binary(/* Box<ast::Expr> */, /* ast::BinOp */, /* Box<ast::Expr> */))
   |

error[E0559]: variant `ast::Expr::Call` has no field named `func`
  --> compiler/src/macro_system/expander.rs:44:21
   |
44 |                     func,
   |                     ^^^^ field does not exist
   |
  ::: compiler/src/parser/ast.rs:99:5
   |
99 |     Call(Box<Expr>, Vec<Expr>),
   |     ---- `ast::Expr::Call` defined here
   |
help: `ast::Expr::Call` is a tuple variant, use the appropriate syntax
   |
43 -                 Ok(Expr::Call {
44 -                     func,
45 -                     args,
46 -                     span: *span,
47 -                 })
43 +                 Ok(Expr::Call(/* Box<ast::Expr> */, /* Vec<ast::Expr> */))
   |

error[E0559]: variant `ast::Expr::Call` has no field named `args`
  --> compiler/src/macro_system/expander.rs:45:21
   |
45 |                     args,
   |                     ^^^^ field does not exist
   |
  ::: compiler/src/parser/ast.rs:99:5
   |
99 |     Call(Box<Expr>, Vec<Expr>),
   |     ---- `ast::Expr::Call` defined here
   |
help: `ast::Expr::Call` is a tuple variant, use the appropriate syntax
   |
43 -                 Ok(Expr::Call {
44 -                     func,
45 -                     args,
46 -                     span: *span,
47 -                 })
43 +                 Ok(Expr::Call(/* Box<ast::Expr> */, /* Vec<ast::Expr> */))
   |

error[E0559]: variant `ast::Expr::Call` has no field named `span`
  --> compiler/src/macro_system/expander.rs:46:21
   |
46 |                     span: *span,
   |                     ^^^^ field does not exist
   |
  ::: compiler/src/parser/ast.rs:99:5
   |
99 |     Call(Box<Expr>, Vec<Expr>),
   |     ---- `ast::Expr::Call` defined here
   |
help: `ast::Expr::Call` is a tuple variant, use the appropriate syntax
   |
43 -                 Ok(Expr::Call {
44 -                     func,
45 -                     args,
46 -                     span: *span,
47 -                 })
43 +                 Ok(Expr::Call(/* Box<ast::Expr> */, /* Vec<ast::Expr> */))
   |

error[E0559]: variant `ast::Expr::Block` has no field named `stmts`
   --> compiler/src/macro_system/expander.rs:54:21
    |
 54 |                     stmts,
    |                     ^^^^^ field does not exist
    |
   ::: compiler/src/parser/ast.rs:103:5
    |
103 |     Block(Vec<Stmt>),
    |     ----- `ast::Expr::Block` defined here
    |
help: `ast::Expr::Block` is a tuple variant, use the appropriate syntax
    |
 53 -                 Ok(Expr::Block {
 54 -                     stmts,
 55 -                     span: *span,
 56 -                 })
 53 +                 Ok(Expr::Block(/* Vec<ast::Stmt> */))
    |

error[E0559]: variant `ast::Expr::Block` has no field named `span`
   --> compiler/src/macro_system/expander.rs:55:21
    |
 55 |                     span: *span,
    |                     ^^^^ field does not exist
    |
   ::: compiler/src/parser/ast.rs:103:5
    |
103 |     Block(Vec<Stmt>),
    |     ----- `ast::Expr::Block` defined here
    |
help: `ast::Expr::Block` is a tuple variant, use the appropriate syntax
    |
 53 -                 Ok(Expr::Block {
 54 -                     stmts,
 55 -                     span: *span,
 56 -                 })
 53 +                 Ok(Expr::Block(/* Vec<ast::Stmt> */))
    |

error[E0769]: tuple variant `Stmt::Let` written as struct variant
  --> compiler/src/macro_system/expander.rs:67:13
   |
67 |             Stmt::Let { pattern, ty, init, span } => {
   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
help: use the tuple variant pattern syntax instead
   |
67 -             Stmt::Let { pattern, ty, init, span } => {
67 +             Stmt::Let(_, _, _) => {
   |

error[E0559]: variant `ast::Stmt::Let` has no field named `pattern`
  --> compiler/src/macro_system/expander.rs:73:21
   |
73 |                     pattern: pattern.clone(),
   |                     ^^^^^^^ field does not exist
   |
  ::: compiler/src/parser/ast.rs:87:5
   |
87 |     Let(String, Option<Type>, Option<Expr>),
   |     --- `ast::Stmt::Let` defined here
   |
help: `ast::Stmt::Let` is a tuple variant, use the appropriate syntax
   |
72 -                 Ok(Stmt::Let {
73 -                     pattern: pattern.clone(),
74 -                     ty: ty.clone(),
75 -                     init,
76 -                     span: *span,
77 -                 })
72 +                 Ok(Stmt::Let(/* String */, /* Option<ast::Type> */, /* Option<ast::Expr> */))
   |

error[E0559]: variant `ast::Stmt::Let` has no field named `ty`
  --> compiler/src/macro_system/expander.rs:74:21
   |
74 |                     ty: ty.clone(),
   |                     ^^ field does not exist
   |
  ::: compiler/src/parser/ast.rs:87:5
   |
87 |     Let(String, Option<Type>, Option<Expr>),
   |     --- `ast::Stmt::Let` defined here
   |
help: `ast::Stmt::Let` is a tuple variant, use the appropriate syntax
   |
72 -                 Ok(Stmt::Let {
73 -                     pattern: pattern.clone(),
74 -                     ty: ty.clone(),
75 -                     init,
76 -                     span: *span,
77 -                 })
72 +                 Ok(Stmt::Let(/* String */, /* Option<ast::Type> */, /* Option<ast::Expr> */))
   |

error[E0559]: variant `ast::Stmt::Let` has no field named `init`
  --> compiler/src/macro_system/expander.rs:75:21
   |
75 |                     init,
   |                     ^^^^ field does not exist
   |
  ::: compiler/src/parser/ast.rs:87:5
   |
87 |     Let(String, Option<Type>, Option<Expr>),
   |     --- `ast::Stmt::Let` defined here
   |
help: `ast::Stmt::Let` is a tuple variant, use the appropriate syntax
   |
72 -                 Ok(Stmt::Let {
73 -                     pattern: pattern.clone(),
74 -                     ty: ty.clone(),
75 -                     init,
76 -                     span: *span,
77 -                 })
72 +                 Ok(Stmt::Let(/* String */, /* Option<ast::Type> */, /* Option<ast::Expr> */))
   |

error[E0559]: variant `ast::Stmt::Let` has no field named `span`
  --> compiler/src/macro_system/expander.rs:76:21
   |
76 |                     span: *span,
   |                     ^^^^ field does not exist
   |
  ::: compiler/src/parser/ast.rs:87:5
   |
87 |     Let(String, Option<Type>, Option<Expr>),
   |     --- `ast::Stmt::Let` defined here
   |
help: `ast::Stmt::Let` is a tuple variant, use the appropriate syntax
   |
72 -                 Ok(Stmt::Let {
73 -                     pattern: pattern.clone(),
74 -                     ty: ty.clone(),
75 -                     init,
76 -                     span: *span,
77 -                 })
72 +                 Ok(Stmt::Let(/* String */, /* Option<ast::Type> */, /* Option<ast::Expr> */))
   |

error[E0308]: mismatched types
  --> compiler/src/macro_system/expander.rs:86:17
   |
86 |                 format!("macro expansion depth exceeded (max: {})", self.max_depth),
   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `String`
   |
   = note: this error originates in the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0277]: the trait bound `String: From<span::Span>` is not satisfied
  --> compiler/src/macro_system/expander.rs:87:17
   |
85 |             return Err(Error::new(
   |                        ---------- required by a bound introduced by this call
86 |                 format!("macro expansion depth exceeded (max: {})", self.max_depth),
87 |                 span,
   |                 ^^^^ the trait `From<span::Span>` is not implemented for `String`
   |
   = help: the following other types implement trait `From<T>`:
             `String` implements `From<&String>`
             `String` implements `From<&mut str>`
             `String` implements `From<&str>`
             `String` implements `From<Box<str>>`
             `String` implements `From<Cow<'_, str>>`
             `String` implements `From<char>`
             `String` implements `From<clap::Id>`
             `String` implements `From<clap::builder::Str>`
   = note: required for `span::Span` to implement `Into<String>`
note: required by a bound in `error::Error::new`
  --> compiler/src/error.rs:47:47
   |
47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
   |                                               ^^^^^^^^^^^^ required by this bound in `Error::new`

error[E0308]: mismatched types
  --> compiler/src/macro_system/expander.rs:92:39
   |
92 |             .ok_or_else(|| Error::new(format!("undefined macro: {}", name), span))?;
   |                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `String`
   |
   = note: this error originates in the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0277]: the trait bound `String: From<span::Span>` is not satisfied
  --> compiler/src/macro_system/expander.rs:92:77
   |
92 |             .ok_or_else(|| Error::new(format!("undefined macro: {}", name), span))?;
   |                            ----------                                       ^^^^ the trait `From<span::Span>` is not implemented for `String`
   |                            |
   |                            required by a bound introduced by this call
   |
   = help: the following other types implement trait `From<T>`:
             `String` implements `From<&String>`
             `String` implements `From<&mut str>`
             `String` implements `From<&str>`
             `String` implements `From<Box<str>>`
             `String` implements `From<Cow<'_, str>>`
             `String` implements `From<char>`
             `String` implements `From<clap::Id>`
             `String` implements `From<clap::builder::Str>`
   = note: required for `span::Span` to implement `Into<String>`
note: required by a bound in `error::Error::new`
  --> compiler/src/error.rs:47:47
   |
47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
   |                                               ^^^^^^^^^^^^ required by this bound in `Error::new`

error[E0308]: mismatched types
   --> compiler/src/macro_system/expander.rs:110:21
    |
110 |                     format!("no matching macro rule for {}", def.name),
    |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `String`
    |
    = note: this error originates in the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0277]: the trait bound `String: From<span::Span>` is not satisfied
   --> compiler/src/macro_system/expander.rs:111:21
    |
109 |                 Err(Error::new(
    |                     ---------- required by a bound introduced by this call
110 |                     format!("no matching macro rule for {}", def.name),
111 |                     span,
    |                     ^^^^ the trait `From<span::Span>` is not implemented for `String`
    |
    = help: the following other types implement trait `From<T>`:
              `String` implements `From<&String>`
              `String` implements `From<&mut str>`
              `String` implements `From<&str>`
              `String` implements `From<Box<str>>`
              `String` implements `From<Cow<'_, str>>`
              `String` implements `From<char>`
              `String` implements `From<clap::Id>`
              `String` implements `From<clap::builder::Str>`
    = note: required for `span::Span` to implement `Into<String>`
note: required by a bound in `error::Error::new`
   --> compiler/src/error.rs:47:47
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |                                               ^^^^^^^^^^^^ required by this bound in `Error::new`

error[E0277]: the trait bound `String: From<span::Span>` is not satisfied
   --> compiler/src/macro_system/expander.rs:116:73
    |
116 |                 Err(Error::new("procedural macros not yet implemented", span))
    |                     ----------                                          ^^^^ the trait `From<span::Span>` is not implemented for `String`
    |                     |
    |                     required by a bound introduced by this call
    |
    = help: the following other types implement trait `From<T>`:
              `String` implements `From<&String>`
              `String` implements `From<&mut str>`
              `String` implements `From<&str>`
              `String` implements `From<Box<str>>`
              `String` implements `From<Cow<'_, str>>`
              `String` implements `From<char>`
              `String` implements `From<clap::Id>`
              `String` implements `From<clap::builder::Str>`
    = note: required for `span::Span` to implement `Into<String>`
note: required by a bound in `error::Error::new`
   --> compiler/src/error.rs:47:47
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |                                               ^^^^^^^^^^^^ required by this bound in `Error::new`

error[E0308]: mismatched types
   --> compiler/src/macro_system/expander.rs:116:32
    |
116 |                 Err(Error::new("procedural macros not yet implemented", span))
    |                     ---------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `&str`
    |                     |
    |                     arguments to this function are incorrect
    |
note: associated function defined here
   --> compiler/src/error.rs:47:12
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |            ^^^ ---------------

error[E0559]: variant `ast::Expr::Block` has no field named `stmts`
   --> compiler/src/macro_system/expander.rs:224:13
    |
224 |             stmts: vec![],
    |             ^^^^^ field does not exist
    |
   ::: compiler/src/parser/ast.rs:103:5
    |
103 |     Block(Vec<Stmt>),
    |     ----- `ast::Expr::Block` defined here
    |
help: `ast::Expr::Block` is a tuple variant, use the appropriate syntax
    |
223 -         Ok(Expr::Block {
224 -             stmts: vec![],
225 -             span,
226 -         })
223 +         Ok(Expr::Block(/* Vec<ast::Stmt> */))
    |

error[E0559]: variant `ast::Expr::Block` has no field named `span`
   --> compiler/src/macro_system/expander.rs:225:13
    |
225 |             span,
    |             ^^^^ field does not exist
    |
   ::: compiler/src/parser/ast.rs:103:5
    |
103 |     Block(Vec<Stmt>),
    |     ----- `ast::Expr::Block` defined here
    |
help: `ast::Expr::Block` is a tuple variant, use the appropriate syntax
    |
223 -         Ok(Expr::Block {
224 -             stmts: vec![],
225 -             span,
226 -         })
223 +         Ok(Expr::Block(/* Vec<ast::Stmt> */))
    |

error[E0599]: no function or associated item named `dummy` found for struct `span::Span` in the current scope
   --> compiler/src/macro_system/mod.rs:132:29
    |
132 |                 span: Span::dummy(),
    |                             ^^^^^ function or associated item not found in `span::Span`
    |
   ::: compiler/src/span.rs:31:1
    |
 31 | pub struct Span {
    | --------------- function or associated item `dummy` not found for this struct
    |
note: if you're trying to build a new `span::Span`, consider using `span::Span::new` which returns `span::Span`
   --> compiler/src/span.rs:37:5
    |
 37 |     pub fn new(start: Position, end: Position) -> Self {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0599]: no function or associated item named `dummy` found for struct `span::Span` in the current scope
   --> compiler/src/macro_system/mod.rs:187:29
    |
187 |                 span: Span::dummy(),
    |                             ^^^^^ function or associated item not found in `span::Span`
    |
   ::: compiler/src/span.rs:31:1
    |
 31 | pub struct Span {
    | --------------- function or associated item `dummy` not found for this struct
    |
note: if you're trying to build a new `span::Span`, consider using `span::Span::new` which returns `span::Span`
   --> compiler/src/span.rs:37:5
    |
 37 |     pub fn new(start: Position, end: Position) -> Self {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0599]: no function or associated item named `dummy` found for struct `span::Span` in the current scope
   --> compiler/src/macro_system/mod.rs:209:29
    |
209 |                 span: Span::dummy(),
    |                             ^^^^^ function or associated item not found in `span::Span`
    |
   ::: compiler/src/span.rs:31:1
    |
 31 | pub struct Span {
    | --------------- function or associated item `dummy` not found for this struct
    |
note: if you're trying to build a new `span::Span`, consider using `span::Span::new` which returns `span::Span`
   --> compiler/src/span.rs:37:5
    |
 37 |     pub fn new(start: Position, end: Position) -> Self {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0282]: type annotations needed
   --> compiler/src/async_runtime/executor.rs:132:25
    |
132 |                         task.poll(&waker);
    |                         ^^^^ cannot infer type

error[E0599]: no function or associated item named `from_millis` found for struct `async_runtime::Duration` in the current scope
   --> compiler/src/async_runtime/executor.rs:135:49
    |
135 |                         Thread::sleep(Duration::from_millis(10));
    |                                                 ^^^^^^^^^^^ function or associated item not found in `async_runtime::Duration`
    |
   ::: compiler/src/async_runtime/mod.rs:142:1
    |
142 | pub struct Duration {
    | ------------------- function or associated item `from_millis` not found for this struct

error[E0026]: variant `ast::Expr::Literal` does not have a field named `value`
   --> compiler/src/verification/smt_solver.rs:109:29
    |
109 |             Expr::Literal { value, .. } => {
    |                             ^^^^^
    |                             |
    |                             variant `ast::Expr::Literal` does not have this field
    |                             help: `ast::Expr::Literal` has a field named `0`

error[E0599]: no variant named `Variable` found for enum `ast::Expr`
   --> compiler/src/verification/smt_solver.rs:116:19
    |
116 |             Expr::Variable { name, .. } => Ok(name.clone()),
    |                   ^^^^^^^^ variant not found in `ast::Expr`
    |
   ::: compiler/src/parser/ast.rs:94:1
    |
 94 | pub enum Expr {
    | ------------- variant `Variable` not found here

error[E0026]: variant `ast::Expr::Binary` does not have fields named `op`, `left`, `right`
   --> compiler/src/verification/smt_solver.rs:117:28
    |
117 |             Expr::Binary { op, left, right, .. } => {
    |                            ^^  ^^^^  ^^^^^ variant `ast::Expr::Binary` does not have these fields

error[E0026]: variant `ast::Expr::Unary` does not have fields named `op`, `operand`
   --> compiler/src/verification/smt_solver.rs:139:27
    |
139 |             Expr::Unary { op, operand, .. } => {
    |                           ^^  ^^^^^^^ variant `ast::Expr::Unary` does not have these fields

error[E0308]: mismatched types
   --> compiler/src/verification/smt_solver.rs:113:41
    |
113 |                     _ => Err(Error::new("Unsupported literal type for SMT", Span::dummy())),
    |                              ---------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `&str`
    |                              |
    |                              arguments to this function are incorrect
    |
note: associated function defined here
   --> compiler/src/error.rs:47:12
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |            ^^^ ---------------

error[E0308]: mismatched types
   --> compiler/src/verification/smt_solver.rs:134:48
    |
134 |                     _ => return Err(Error::new("Unsupported binary operator for SMT", Span::dummy())),
    |                                     ---------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `&str`
    |                                     |
    |                                     arguments to this function are incorrect
    |
note: associated function defined here
   --> compiler/src/error.rs:47:12
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |            ^^^ ---------------

error[E0308]: mismatched types
   --> compiler/src/verification/smt_solver.rs:145:48
    |
145 |                     _ => return Err(Error::new("Unsupported unary operator for SMT", Span::dummy())),
    |                                     ---------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `&str`
    |                                     |
    |                                     arguments to this function are incorrect
    |
note: associated function defined here
   --> compiler/src/error.rs:47:12
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |            ^^^ ---------------

error[E0308]: mismatched types
   --> compiler/src/verification/smt_solver.rs:150:33
    |
150 |             _ => Err(Error::new("Unsupported expression type for SMT", Span::dummy())),
    |                      ---------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `&str`
    |                      |
    |                      arguments to this function are incorrect
    |
note: associated function defined here
   --> compiler/src/error.rs:47:12
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |            ^^^ ---------------

error[E0599]: no variant named `Variable` found for enum `ast::Expr`
   --> compiler/src/verification/smt_solver.rs:164:19
    |
164 |             Expr::Variable { name, .. } => {
    |                   ^^^^^^^^ variant not found in `ast::Expr`
    |
   ::: compiler/src/parser/ast.rs:94:1
    |
 94 | pub enum Expr {
    | ------------- variant `Variable` not found here

error[E0026]: variant `ast::Expr::Binary` does not have fields named `left`, `right`
   --> compiler/src/verification/smt_solver.rs:167:28
    |
167 |             Expr::Binary { left, right, .. } => {
    |                            ^^^^  ^^^^^ variant `ast::Expr::Binary` does not have these fields

error[E0026]: variant `ast::Expr::Unary` does not have a field named `operand`
   --> compiler/src/verification/smt_solver.rs:171:27
    |
171 |             Expr::Unary { operand, .. } => {
    |                           ^^^^^^^ variant `ast::Expr::Unary` does not have this field

error[E0308]: mismatched types
   --> compiler/src/verification/smt_solver.rs:195:37
    |
195 |             .map_err(|e| Error::new(format!("Failed to spawn SMT solver: {}", e), Span::dummy()))?;
    |                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `String`
    |
    = note: this error originates in the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0308]: mismatched types
   --> compiler/src/verification/smt_solver.rs:199:41
    |
199 |                 .map_err(|e| Error::new(format!("Failed to write to SMT solver: {}", e), Span::dummy()))?;
    |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `String`
    |
    = note: this error originates in the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0308]: mismatched types
   --> compiler/src/verification/smt_solver.rs:203:37
    |
203 |             .map_err(|e| Error::new(format!("Failed to read SMT solver output: {}", e), Span::dummy()))?;
    |                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `String`
    |
    = note: this error originates in the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0599]: no method named `prove_postcondition` found for mutable reference `&mut FormalVerifier` in the current scope
   --> compiler/src/verification/mod.rs:115:30
    |
115 |             let proof = self.prove_postcondition(func, post)?;
    |                              ^^^^^^^^^^^^^^^^^^^
    |
help: there is a method `verify_postcondition` with a similar name
    |
115 -             let proof = self.prove_postcondition(func, post)?;
115 +             let proof = self.verify_postcondition(func, post)?;
    |

error[E0599]: no method named `check_memory_safety` found for mutable reference `&mut FormalVerifier` in the current scope
   --> compiler/src/verification/mod.rs:120:34
    |
120 |         let memory_safety = self.check_memory_safety(func)?;
    |                                  ^^^^^^^^^^^^^^^^^^^
    |
help: there is a method `check_null_safety` with a similar name
    |
120 -         let memory_safety = self.check_memory_safety(func)?;
120 +         let memory_safety = self.check_null_safety(func)?;
    |

error[E0599]: no method named `prove_invariant_init` found for mutable reference `&mut FormalVerifier` in the current scope
   --> compiler/src/verification/mod.rs:136:31
    |
136 |         let init_proof = self.prove_invariant_init(&invariant)?;
    |                               ^^^^^^^^^^^^^^^^^^^^
    |
help: there is a method `verify_invariant_init` with a similar name
    |
136 -         let init_proof = self.prove_invariant_init(&invariant)?;
136 +         let init_proof = self.verify_invariant_init(&invariant)?;
    |

error[E0599]: no method named `prove_invariant_maintained` found for mutable reference `&mut FormalVerifier` in the current scope
   --> compiler/src/verification/mod.rs:142:35
    |
142 |         let maintain_proof = self.prove_invariant_maintained(&invariant, loop_stmt)?;
    |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^ method not found in `&mut FormalVerifier`

error[E0609]: no field `attributes` on type `&ast::Function`
   --> compiler/src/verification/mod.rs:204:27
    |
204 |         for attr in &func.attributes {
    |                           ^^^^^^^^^^ unknown field
    |
    = note: available fields are: `name`, `generics`, `params`, `return_type`, `where_clause`, `body`

error[E0282]: type annotations needed
   --> compiler/src/verification/mod.rs:207:40
    |
207 |                     preconditions.push(expr.clone());
    |                                        ^^^^ cannot infer type

error[E0609]: no field `attributes` on type `&ast::Function`
   --> compiler/src/verification/mod.rs:219:27
    |
219 |         for attr in &func.attributes {
    |                           ^^^^^^^^^^ unknown field
    |
    = note: available fields are: `name`, `generics`, `params`, `return_type`, `where_clause`, `body`

error[E0282]: type annotations needed
   --> compiler/src/verification/mod.rs:222:41
    |
222 |                     postconditions.push(expr.clone());
    |                                         ^^^^ cannot infer type

error[E0308]: mismatched types
   --> compiler/src/lexer/mod.rs:689:13
    |
682 |     fn lex_slash(&mut self) -> Result<TokenKind> {
    |                                ----------------- expected `std::result::Result<token::TokenKind, error::Error>` because of return type
...
689 |             self.next_token() // Skip comment and get next token
    |             ^^^^^^^^^^^^^^^^^ expected `Result<TokenKind, Error>`, found `Result<Token, Error>`
    |
    = note: expected enum `std::result::Result<token::TokenKind, _>`
               found enum `std::result::Result<Token, _>`

error[E0308]: mismatched types
   --> compiler/src/lexer/mod.rs:698:32
    |
682 |     fn lex_slash(&mut self) -> Result<TokenKind> {
    |                                ----------------- expected `std::result::Result<token::TokenKind, error::Error>` because of return type
...
698 |                         return self.next_token(); // Skip comment
    |                                ^^^^^^^^^^^^^^^^^ expected `Result<TokenKind, Error>`, found `Result<Token, Error>`
    |
    = note: expected enum `std::result::Result<token::TokenKind, _>`
               found enum `std::result::Result<Token, _>`

warning: unused variable: `uri`
   --> tools/lsp/src/main.rs:242:30
    |
242 |     pub fn completion(&self, uri: &str, position: Position) -> Vec<CompletionItem> {
    |                              ^^^ help: if this is intentional, prefix it with an underscore: `_uri`
    |
    = note: `#[warn(unused_variables)]` (part of `#[warn(unused)]`) on by default

warning: unused variable: `position`
   --> tools/lsp/src/main.rs:242:41
    |
242 |     pub fn completion(&self, uri: &str, position: Position) -> Vec<CompletionItem> {
    |                                         ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_position`

error[E0026]: variant `ast::Stmt::Let` does not have fields named `pattern`, `init`
   --> compiler/src/gpu/mod.rs:243:25
    |
243 |             Stmt::Let { pattern, init, .. } => {
    |                         ^^^^^^^  ^^^^ variant `ast::Stmt::Let` does not have these fields

error[E0026]: variant `ast::Expr::Literal` does not have a field named `value`
   --> compiler/src/gpu/mod.rs:259:29
    |
259 |             Expr::Literal { value, .. } => {
    |                             ^^^^^
    |                             |
    |                             variant `ast::Expr::Literal` does not have this field
    |                             help: `ast::Expr::Literal` has a field named `0`

error[E0599]: no variant named `Variable` found for enum `ast::Expr`
   --> compiler/src/gpu/mod.rs:267:19
    |
267 |             Expr::Variable { name, .. } => Ok(name.clone()),
    |                   ^^^^^^^^ variant not found in `ast::Expr`
    |
   ::: compiler/src/parser/ast.rs:94:1
    |
 94 | pub enum Expr {
    | ------------- variant `Variable` not found here

error[E0026]: variant `ast::Expr::Binary` does not have fields named `op`, `left`, `right`
   --> compiler/src/gpu/mod.rs:268:28
    |
268 |             Expr::Binary { op, left, right, .. } => {
    |                            ^^  ^^^^  ^^^^^ variant `ast::Expr::Binary` does not have these fields

error[E0599]: no variant or associated item named `I32` found for enum `ast::Type` in the current scope
   --> compiler/src/gpu/mod.rs:304:19
    |
304 |             Type::I32 => Ok("int".to_string()),
    |                   ^^^ variant or associated item not found in `ast::Type`
    |
   ::: compiler/src/parser/ast.rs:73:1
    |
 73 | pub enum Type {
    | ------------- variant or associated item `I32` not found for this enum

warning: unused variable: `new_name`
   --> tools/lsp/src/main.rs:304:57
    |
304 |     pub fn rename(&self, uri: &str, position: Position, new_name: String) -> Vec<Location> {
    |                                                         ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_new_name`

error[E0599]: no variant or associated item named `I64` found for enum `ast::Type` in the current scope
   --> compiler/src/gpu/mod.rs:305:19
    |
305 |             Type::I64 => Ok("long".to_string()),
    |                   ^^^ variant or associated item not found in `ast::Type`
    |
   ::: compiler/src/parser/ast.rs:73:1
    |
 73 | pub enum Type {
    | ------------- variant or associated item `I64` not found for this enum

warning: unused variable: `server`
   --> tools/lsp/src/main.rs:378:9
    |
378 |     let server = LanguageServer::new();
    |         ^^^^^^ help: if this is intentional, prefix it with an underscore: `_server`

error[E0599]: no variant or associated item named `F32` found for enum `ast::Type` in the current scope
   --> compiler/src/gpu/mod.rs:306:19
    |
306 |             Type::F32 => Ok("float".to_string()),
    |                   ^^^ variant or associated item not found in `ast::Type`
    |
   ::: compiler/src/parser/ast.rs:73:1
    |
 73 | pub enum Type {
    | ------------- variant or associated item `F32` not found for this enum

error[E0599]: no variant or associated item named `F64` found for enum `ast::Type` in the current scope
   --> compiler/src/gpu/mod.rs:307:19
    |
307 |             Type::F64 => Ok("double".to_string()),
    |                   ^^^ variant or associated item not found in `ast::Type`
    |
   ::: compiler/src/parser/ast.rs:73:1
    |
 73 | pub enum Type {
    | ------------- variant or associated item `F64` not found for this enum

error[E0599]: no variant or associated item named `Pointer` found for enum `ast::Type` in the current scope
   --> compiler/src/gpu/mod.rs:308:19
    |
308 |             Type::Pointer(inner) => Ok(format!("{}*", self.cuda_type(inner)?)),
    |                   ^^^^^^^ variant or associated item not found in `ast::Type`
    |
   ::: compiler/src/parser/ast.rs:73:1
    |
 73 | pub enum Type {
    | ------------- variant or associated item `Pointer` not found for this enum

error[E0599]: no variant or associated item named `I32` found for enum `ast::Type` in the current scope
   --> compiler/src/gpu/mod.rs:315:19
    |
315 |             Type::I32 => Ok("device int*".to_string()),
    |                   ^^^ variant or associated item not found in `ast::Type`
    |
   ::: compiler/src/parser/ast.rs:73:1
    |
 73 | pub enum Type {
    | ------------- variant or associated item `I32` not found for this enum

error[E0599]: no variant or associated item named `I64` found for enum `ast::Type` in the current scope
   --> compiler/src/gpu/mod.rs:316:19
    |
316 |             Type::I64 => Ok("device long*".to_string()),
    |                   ^^^ variant or associated item not found in `ast::Type`
    |
   ::: compiler/src/parser/ast.rs:73:1
    |
 73 | pub enum Type {
    | ------------- variant or associated item `I64` not found for this enum

error[E0599]: no variant or associated item named `F32` found for enum `ast::Type` in the current scope
   --> compiler/src/gpu/mod.rs:317:19
    |
317 |             Type::F32 => Ok("device float*".to_string()),
    |                   ^^^ variant or associated item not found in `ast::Type`
    |
   ::: compiler/src/parser/ast.rs:73:1
    |
 73 | pub enum Type {
    | ------------- variant or associated item `F32` not found for this enum

error[E0599]: no variant or associated item named `F64` found for enum `ast::Type` in the current scope
   --> compiler/src/gpu/mod.rs:318:19
    |
318 |             Type::F64 => Ok("device double*".to_string()),
    |                   ^^^ variant or associated item not found in `ast::Type`
    |
   ::: compiler/src/parser/ast.rs:73:1
    |
 73 | pub enum Type {
    | ------------- variant or associated item `F64` not found for this enum

error[E0599]: no variant or associated item named `I32` found for enum `ast::Type` in the current scope
   --> compiler/src/gpu/mod.rs:325:19
    |
325 |             Type::I32 => Ok("int".to_string()),
    |                   ^^^ variant or associated item not found in `ast::Type`
    |
   ::: compiler/src/parser/ast.rs:73:1
    |
 73 | pub enum Type {
    | ------------- variant or associated item `I32` not found for this enum

error[E0599]: no variant or associated item named `I64` found for enum `ast::Type` in the current scope
   --> compiler/src/gpu/mod.rs:326:19
    |
326 |             Type::I64 => Ok("int64_t".to_string()),
    |                   ^^^ variant or associated item not found in `ast::Type`
    |
   ::: compiler/src/parser/ast.rs:73:1
    |
 73 | pub enum Type {
    | ------------- variant or associated item `I64` not found for this enum

error[E0599]: no variant or associated item named `F32` found for enum `ast::Type` in the current scope
   --> compiler/src/gpu/mod.rs:327:19
    |
327 |             Type::F32 => Ok("float".to_string()),
    |                   ^^^ variant or associated item not found in `ast::Type`
    |
   ::: compiler/src/parser/ast.rs:73:1
    |
 73 | pub enum Type {
    | ------------- variant or associated item `F32` not found for this enum

error[E0599]: no variant or associated item named `F64` found for enum `ast::Type` in the current scope
   --> compiler/src/gpu/mod.rs:328:19
    |
328 |             Type::F64 => Ok("double".to_string()),
    |                   ^^^ variant or associated item not found in `ast::Type`
    |
   ::: compiler/src/parser/ast.rs:73:1
    |
 73 | pub enum Type {
    | ------------- variant or associated item `F64` not found for this enum

error[E0599]: no variant or associated item named `I32` found for enum `ast::Type` in the current scope
   --> compiler/src/gpu/mod.rs:335:19
    |
335 |             Type::I32 => Ok("int*".to_string()),
    |                   ^^^ variant or associated item not found in `ast::Type`
    |
   ::: compiler/src/parser/ast.rs:73:1
    |
 73 | pub enum Type {
    | ------------- variant or associated item `I32` not found for this enum

error[E0599]: no variant or associated item named `I64` found for enum `ast::Type` in the current scope
   --> compiler/src/gpu/mod.rs:336:19
    |
336 |             Type::I64 => Ok("long*".to_string()),
    |                   ^^^ variant or associated item not found in `ast::Type`
    |
   ::: compiler/src/parser/ast.rs:73:1
    |
 73 | pub enum Type {
    | ------------- variant or associated item `I64` not found for this enum

error[E0599]: no variant or associated item named `F32` found for enum `ast::Type` in the current scope
   --> compiler/src/gpu/mod.rs:337:19
    |
337 |             Type::F32 => Ok("float*".to_string()),
    |                   ^^^ variant or associated item not found in `ast::Type`
    |
   ::: compiler/src/parser/ast.rs:73:1
    |
 73 | pub enum Type {
    | ------------- variant or associated item `F32` not found for this enum

error[E0599]: no variant or associated item named `F64` found for enum `ast::Type` in the current scope
   --> compiler/src/gpu/mod.rs:338:19
    |
338 |             Type::F64 => Ok("double*".to_string()),
    |                   ^^^ variant or associated item not found in `ast::Type`
    |
   ::: compiler/src/parser/ast.rs:73:1
    |
 73 | pub enum Type {
    | ------------- variant or associated item `F64` not found for this enum

error[E0026]: variant `ast::Expr::Literal` does not have a field named `value`
  --> compiler/src/consteval/mod.rs:61:29
   |
61 |             Expr::Literal { value, .. } => self.eval_literal(value),
   |                             ^^^^^
   |                             |
   |                             variant `ast::Expr::Literal` does not have this field
   |                             help: `ast::Expr::Literal` has a field named `0`

error[E0599]: no variant named `Variable` found for enum `ast::Expr`
  --> compiler/src/consteval/mod.rs:63:19
   |
63 |             Expr::Variable { name, .. } => {
   |                   ^^^^^^^^ variant not found in `ast::Expr`
   |
  ::: compiler/src/parser/ast.rs:94:1
   |
94 | pub enum Expr {
   | ------------- variant `Variable` not found here

error[E0026]: variant `ast::Expr::Binary` does not have fields named `op`, `left`, `right`
  --> compiler/src/consteval/mod.rs:72:28
   |
72 |             Expr::Binary { op, left, right, .. } => {
   |                            ^^  ^^^^  ^^^^^ variant `ast::Expr::Binary` does not have these fields

error[E0026]: variant `ast::Expr::Unary` does not have fields named `op`, `operand`
  --> compiler/src/consteval/mod.rs:78:27
   |
78 |             Expr::Unary { op, operand, .. } => {
   |                           ^^  ^^^^^^^ variant `ast::Expr::Unary` does not have these fields

error[E0026]: variant `ast::Expr::Call` does not have fields named `func`, `args`
  --> compiler/src/consteval/mod.rs:83:26
   |
83 |             Expr::Call { func, args, .. } => {
   |                          ^^^^  ^^^^ variant `ast::Expr::Call` does not have these fields

error[E0026]: variant `ast::Expr::If` does not have fields named `condition`, `then_branch`, `else_branch`
  --> compiler/src/consteval/mod.rs:87:24
   |
87 |             Expr::If { condition, then_branch, else_branch, .. } => {
   |                        ^^^^^^^^^  ^^^^^^^^^^^  ^^^^^^^^^^^ variant `ast::Expr::If` does not have these fields

error[E0026]: variant `ast::Expr::Array` does not have a field named `elements`
  --> compiler/src/consteval/mod.rs:98:27
   |
98 |             Expr::Array { elements, .. } => {
   |                           ^^^^^^^^
   |                           |
   |                           variant `ast::Expr::Array` does not have this field
   |                           help: `ast::Expr::Array` has a field named `0`

error[E0308]: mismatched types
  --> compiler/src/consteval/mod.rs:67:25
   |
67 |                         format!("Undefined constant: {}", name),
   |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `String`
   |
   = note: this error originates in the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0308]: mismatched types
   --> compiler/src/consteval/mod.rs:107:17
    |
106 |             _ => Err(Error::new(
    |                      ---------- arguments to this function are incorrect
107 |                 "Expression cannot be evaluated at compile time",
    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `&str`
    |
note: associated function defined here
   --> compiler/src/error.rs:47:12
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |            ^^^ ---------------

error[E0308]: mismatched types
   --> compiler/src/consteval/mod.rs:132:51
    |
132 | ...                   return Err(Error::new("Division by zero", Span::dummy()));
    |                                  ---------- ^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `&str`
    |                                  |
    |                                  arguments to this function are incorrect
    |
note: associated function defined here
   --> compiler/src/error.rs:47:12
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |            ^^^ ---------------

error[E0308]: mismatched types
   --> compiler/src/consteval/mod.rs:148:48
    |
148 |                     _ => return Err(Error::new("Unsupported binary operation", Span::dummy())),
    |                                     ---------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `&str`
    |                                     |
    |                                     arguments to this function are incorrect
    |
note: associated function defined here
   --> compiler/src/error.rs:47:12
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |            ^^^ ---------------

error[E0308]: mismatched types
   --> compiler/src/consteval/mod.rs:165:48
    |
165 |                     _ => return Err(Error::new("Unsupported binary operation", Span::dummy())),
    |                                     ---------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `&str`
    |                                     |
    |                                     arguments to this function are incorrect
    |
note: associated function defined here
   --> compiler/src/error.rs:47:12
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |            ^^^ ---------------

error[E0308]: mismatched types
   --> compiler/src/consteval/mod.rs:176:48
    |
176 |                     _ => return Err(Error::new("Unsupported binary operation", Span::dummy())),
    |                                     ---------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `&str`
    |                                     |
    |                                     arguments to this function are incorrect
    |
note: associated function defined here
   --> compiler/src/error.rs:47:12
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |            ^^^ ---------------

error[E0308]: mismatched types
   --> compiler/src/consteval/mod.rs:181:33
    |
181 |             _ => Err(Error::new("Type mismatch in binary operation", Span::dummy())),
    |                      ---------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `&str`
    |                      |
    |                      arguments to this function are incorrect
    |
note: associated function defined here
   --> compiler/src/error.rs:47:12
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |            ^^^ ---------------

error[E0308]: mismatched types
   --> compiler/src/consteval/mod.rs:192:48
    |
192 |                     _ => return Err(Error::new("Unsupported unary operation", Span::dummy())),
    |                                     ---------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `&str`
    |                                     |
    |                                     arguments to this function are incorrect
    |
note: associated function defined here
   --> compiler/src/error.rs:47:12
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |            ^^^ ---------------

error[E0308]: mismatched types
   --> compiler/src/consteval/mod.rs:200:48
    |
200 |                     _ => return Err(Error::new("Unsupported unary operation", Span::dummy())),
    |                                     ---------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `&str`
    |                                     |
    |                                     arguments to this function are incorrect
    |
note: associated function defined here
   --> compiler/src/error.rs:47:12
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |            ^^^ ---------------

error[E0308]: mismatched types
   --> compiler/src/consteval/mod.rs:208:48
    |
208 |                     _ => return Err(Error::new("Unsupported unary operation", Span::dummy())),
    |                                     ---------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `&str`
    |                                     |
    |                                     arguments to this function are incorrect
    |
note: associated function defined here
   --> compiler/src/error.rs:47:12
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |            ^^^ ---------------

error[E0308]: mismatched types
   --> compiler/src/consteval/mod.rs:213:33
    |
213 |             _ => Err(Error::new("Type mismatch in unary operation", Span::dummy())),
    |                      ---------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `&str`
    |                      |
    |                      arguments to this function are incorrect
    |
note: associated function defined here
   --> compiler/src/error.rs:47:12
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |            ^^^ ---------------

error[E0599]: no variant named `Variable` found for enum `ast::Expr`
   --> compiler/src/consteval/mod.rs:220:19
    |
220 |             Expr::Variable { name, .. } => name,
    |                   ^^^^^^^^ variant not found in `ast::Expr`
    |
   ::: compiler/src/parser/ast.rs:94:1
    |
 94 | pub enum Expr {
    | ------------- variant `Variable` not found here

error[E0308]: mismatched types
   --> compiler/src/consteval/mod.rs:221:40
    |
221 |             _ => return Err(Error::new("Invalid function call", Span::dummy())),
    |                             ---------- ^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `&str`
    |                             |
    |                             arguments to this function are incorrect
    |
note: associated function defined here
   --> compiler/src/error.rs:47:12
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |            ^^^ ---------------

error[E0308]: mismatched types
   --> compiler/src/consteval/mod.rs:238:17
    |
238 |                 format!("Unknown compile-time function: {}", func_name),
    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `String`
    |
    = note: this error originates in the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0308]: mismatched types
   --> compiler/src/consteval/mod.rs:246:35
    |
246 |             return Err(Error::new("abs expects 1 argument", Span::dummy()));
    |                        ---------- ^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `&str`
    |                        |
    |                        arguments to this function are incorrect
    |
note: associated function defined here
   --> compiler/src/error.rs:47:12
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |            ^^^ ---------------

error[E0308]: mismatched types
   --> compiler/src/consteval/mod.rs:252:33
    |
252 |             _ => Err(Error::new("abs expects numeric argument", Span::dummy())),
    |                      ---------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `&str`
    |                      |
    |                      arguments to this function are incorrect
    |
note: associated function defined here
   --> compiler/src/error.rs:47:12
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |            ^^^ ---------------

error[E0308]: mismatched types
   --> compiler/src/consteval/mod.rs:258:35
    |
258 |             return Err(Error::new("min expects 2 arguments", Span::dummy()));
    |                        ---------- ^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `&str`
    |                        |
    |                        arguments to this function are incorrect
    |
note: associated function defined here
   --> compiler/src/error.rs:47:12
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |            ^^^ ---------------

error[E0308]: mismatched types
   --> compiler/src/consteval/mod.rs:264:33
    |
264 |             _ => Err(Error::new("min expects numeric arguments", Span::dummy())),
    |                      ---------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `&str`
    |                      |
    |                      arguments to this function are incorrect
    |
note: associated function defined here
   --> compiler/src/error.rs:47:12
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |            ^^^ ---------------

error[E0308]: mismatched types
   --> compiler/src/consteval/mod.rs:270:35
    |
270 |             return Err(Error::new("max expects 2 arguments", Span::dummy()));
    |                        ---------- ^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `&str`
    |                        |
    |                        arguments to this function are incorrect
    |
note: associated function defined here
   --> compiler/src/error.rs:47:12
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |            ^^^ ---------------

warning: `vez_testing` (lib test) generated 1 warning (1 duplicate)
error[E0308]: mismatched types
   --> compiler/src/consteval/mod.rs:276:33
    |
276 |             _ => Err(Error::new("max expects numeric arguments", Span::dummy())),
    |                      ---------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `&str`
    |                      |
    |                      arguments to this function are incorrect
    |
note: associated function defined here
   --> compiler/src/error.rs:47:12
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |            ^^^ ---------------

error[E0308]: mismatched types
   --> compiler/src/consteval/mod.rs:282:35
    |
282 |             return Err(Error::new("pow expects 2 arguments", Span::dummy()));
    |                        ---------- ^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `&str`
    |                        |
    |                        arguments to this function are incorrect
    |
note: associated function defined here
   --> compiler/src/error.rs:47:12
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |            ^^^ ---------------

error[E0308]: mismatched types
   --> compiler/src/consteval/mod.rs:291:43
    |
291 |                     return Err(Error::new("Negative exponent for integer pow", Span::dummy()));
    |                                ---------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `&str`
    |                                |
    |                                arguments to this function are incorrect
    |
note: associated function defined here
   --> compiler/src/error.rs:47:12
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |            ^^^ ---------------

error[E0308]: mismatched types
   --> compiler/src/consteval/mod.rs:295:33
    |
295 |             _ => Err(Error::new("pow expects numeric arguments", Span::dummy())),
    |                      ---------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `&str`
    |                      |
    |                      arguments to this function are incorrect
    |
note: associated function defined here
   --> compiler/src/error.rs:47:12
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |            ^^^ ---------------

error[E0308]: mismatched types
   --> compiler/src/consteval/mod.rs:301:35
    |
301 |             return Err(Error::new("sqrt expects 1 argument", Span::dummy()));
    |                        ---------- ^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `&str`
    |                        |
    |                        arguments to this function are incorrect
    |
note: associated function defined here
   --> compiler/src/error.rs:47:12
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |            ^^^ ---------------

error[E0308]: mismatched types
   --> compiler/src/consteval/mod.rs:307:43
    |
307 |                     return Err(Error::new("sqrt of negative number", Span::dummy()));
    |                                ---------- ^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `&str`
    |                                |
    |                                arguments to this function are incorrect
    |
note: associated function defined here
   --> compiler/src/error.rs:47:12
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |            ^^^ ---------------

error[E0308]: mismatched types
   --> compiler/src/consteval/mod.rs:311:33
    |
311 |             _ => Err(Error::new("sqrt expects float argument", Span::dummy())),
    |                      ---------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `&str`
    |                      |
    |                      arguments to this function are incorrect
    |
note: associated function defined here
   --> compiler/src/error.rs:47:12
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |            ^^^ ---------------

error[E0599]: no variant or associated item named `I1` found for enum `types::IrType` in the current scope
  --> compiler/src/codegen/llvm_backend.rs:60:21
   |
60 |             IrType::I1 => "i1".to_string(),
   |                     ^^ variant or associated item not found in `types::IrType`
   |
  ::: compiler/src/ir/types.rs:7:1
   |
 7 | pub enum IrType {
   | --------------- variant or associated item `I1` not found for this enum
   |
help: there is a variant with a similar name
   |
60 -             IrType::I1 => "i1".to_string(),
60 +             IrType::I8 => "i1".to_string(),
   |

error[E0599]: no variant or associated item named `Ptr` found for enum `types::IrType` in the current scope
  --> compiler/src/codegen/llvm_backend.rs:73:21
   |
73 |             IrType::Ptr(inner) => format!("{}*", self.type_to_llvm(inner)),
   |                     ^^^ variant or associated item not found in `types::IrType`
   |
  ::: compiler/src/ir/types.rs:7:1
   |
 7 | pub enum IrType {
   | --------------- variant or associated item `Ptr` not found for this enum

error[E0026]: variant `instructions::Instruction::Branch` does not have fields named `true_bb`, `false_bb`
   --> compiler/src/codegen/llvm_backend.rs:290:41
    |
290 |             Instruction::Branch { cond, true_bb, false_bb } => {
    |                                         ^^^^^^^  ^^^^^^^^ variant `instructions::Instruction::Branch` does not have these fields

error[E0599]: no variant or associated item named `I1` found for enum `types::IrType` in the current scope
   --> compiler/src/codegen/llvm_backend.rs:337:59
    |
337 |             Value::Constant(Constant::Bool(_)) => IrType::I1,
    |                                                           ^^ variant or associated item not found in `types::IrType`
    |
   ::: compiler/src/ir/types.rs:7:1
    |
  7 | pub enum IrType {
    | --------------- variant or associated item `I1` not found for this enum
    |
help: there is a variant with a similar name
    |
337 -             Value::Constant(Constant::Bool(_)) => IrType::I1,
337 +             Value::Constant(Constant::Bool(_)) => IrType::I8,
    |

warning: `vez_lsp` (bin "vez-lsp" test) generated 4 warnings (run `cargo fix --bin "vez-lsp" -p vez_lsp --tests` to apply 4 suggestions)
error[E0599]: no variant named `MacroCall` found for enum `ast::Expr`
   --> compiler/src/macro_system/expander.rs:240:26
    |
240 |         let expr = Expr::MacroCall {
    |                          ^^^^^^^^^ variant not found in `ast::Expr`
    |
   ::: compiler/src/parser/ast.rs:94:1
    |
 94 | pub enum Expr {
    | ------------- variant `MacroCall` not found here

error[E0599]: no function or associated item named `dummy` found for struct `span::Span` in the current scope
   --> compiler/src/macro_system/expander.rs:243:25
    |
243 |             span: Span::dummy(),
    |                         ^^^^^ function or associated item not found in `span::Span`
    |
   ::: compiler/src/span.rs:31:1
    |
 31 | pub struct Span {
    | --------------- function or associated item `dummy` not found for this struct
    |
note: if you're trying to build a new `span::Span`, consider using `span::Span::new` which returns `span::Span`
   --> compiler/src/span.rs:37:5
    |
 37 |     pub fn new(start: Position, end: Position) -> Self {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused variable: `func`
   --> compiler/src/verification/mod.rs:194:41
    |
194 |     fn check_overflow_safety(&mut self, func: &Function) -> Result<bool> {
    |                                         ^^^^ help: if this is intentional, prefix it with an underscore: `_func`
    |
    = note: `#[warn(unused_variables)]` (part of `#[warn(unused)]`) on by default

error[E0594]: cannot assign to `proof.status`, as `proof` is not declared as mutable
   --> compiler/src/verification/mod.rs:247:13
    |
247 |             proof.status = ProofStatus::Proven;
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ cannot assign
    |
help: consider changing this to be mutable
    |
237 |         let mut proof = Proof {
    |             +++

error[E0594]: cannot assign to `proof.status`, as `proof` is not declared as mutable
   --> compiler/src/verification/mod.rs:249:13
    |
249 |             proof.status = ProofStatus::Failed;
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ cannot assign
    |
help: consider changing this to be mutable
    |
237 |         let mut proof = Proof {
    |             +++

warning: variable does not need to be mutable
   --> compiler/src/verification/mod.rs:268:13
    |
268 |         let mut proof = Proof {
    |             ----^^^^^
    |             |
    |             help: remove this `mut`
    |
    = note: `#[warn(unused_mut)]` (part of `#[warn(unused)]`) on by default

error[E0559]: variant `ast::Expr::Literal` has no field named `value`
   --> compiler/src/verification/mod.rs:363:13
    |
363 |             value: Literal::Bool(true),
    |             ^^^^^ field does not exist
    |
   ::: compiler/src/parser/ast.rs:95:5
    |
 95 |     Literal(Literal),
    |     ------- `ast::Expr::Literal` defined here
    |
help: `ast::Expr::Literal` is a tuple variant, use the appropriate syntax
    |
362 -         let precond = Expr::Literal {
363 -             value: Literal::Bool(true),
364 -             span: Span::dummy(),
365 -         };
362 +         let precond = Expr::Literal(/* ast::Literal */);
    |

error[E0559]: variant `ast::Expr::Literal` has no field named `span`
   --> compiler/src/verification/mod.rs:364:13
    |
364 |             span: Span::dummy(),
    |             ^^^^ field does not exist
    |
   ::: compiler/src/parser/ast.rs:95:5
    |
 95 |     Literal(Literal),
    |     ------- `ast::Expr::Literal` defined here
    |
help: `ast::Expr::Literal` is a tuple variant, use the appropriate syntax
    |
362 -         let precond = Expr::Literal {
363 -             value: Literal::Bool(true),
364 -             span: Span::dummy(),
365 -         };
362 +         let precond = Expr::Literal(/* ast::Literal */);
    |

Some errors have detailed explanations: E0023, E0026, E0027, E0277, E0282, E0308, E0412, E0432, E0433...
For more information about an error, try `rustc --explain E0023`.
warning: `vez_compiler` (lib) generated 14 warnings
error: could not compile `vez_compiler` (lib) due to 288 previous errors; 14 warnings emitted
warning: build failed, waiting for other jobs to finish...
error[E0559]: variant `ast::Expr::Literal` has no field named `value`
   --> compiler/src/consteval/mod.rs:335:13
    |
335 |             value: Literal::Int(42),
    |             ^^^^^ field does not exist
    |
   ::: compiler/src/parser/ast.rs:95:5
    |
 95 |     Literal(Literal),
    |     ------- `ast::Expr::Literal` defined here
    |
help: `ast::Expr::Literal` is a tuple variant, use the appropriate syntax
    |
334 -         let expr = Expr::Literal {
335 -             value: Literal::Int(42),
336 -             span: Span::dummy(),
337 -         };
334 +         let expr = Expr::Literal(/* ast::Literal */);
    |

error[E0559]: variant `ast::Expr::Literal` has no field named `span`
   --> compiler/src/consteval/mod.rs:336:13
    |
336 |             span: Span::dummy(),
    |             ^^^^ field does not exist
    |
   ::: compiler/src/parser/ast.rs:95:5
    |
 95 |     Literal(Literal),
    |     ------- `ast::Expr::Literal` defined here
    |
help: `ast::Expr::Literal` is a tuple variant, use the appropriate syntax
    |
334 -         let expr = Expr::Literal {
335 -             value: Literal::Int(42),
336 -             span: Span::dummy(),
337 -         };
334 +         let expr = Expr::Literal(/* ast::Literal */);
    |

error[E0559]: variant `ast::Expr::Binary` has no field named `op`
   --> compiler/src/consteval/mod.rs:348:13
    |
348 |             op: BinaryOp::Add,
    |             ^^ field does not exist
    |
   ::: compiler/src/parser/ast.rs:97:5
    |
 97 |     Binary(Box<Expr>, BinOp, Box<Expr>),
    |     ------ `ast::Expr::Binary` defined here
    |
help: `ast::Expr::Binary` is a tuple variant, use the appropriate syntax
    |
347 -         let expr = Expr::Binary {
348 -             op: BinaryOp::Add,
349 -             left: Box::new(Expr::Literal {
350 -                 value: Literal::Int(10),
351 -                 span: Span::dummy(),
352 -             }),
353 -             right: Box::new(Expr::Literal {
354 -                 value: Literal::Int(32),
355 -                 span: Span::dummy(),
356 -             }),
357 -             span: Span::dummy(),
358 -         };
347 +         let expr = Expr::Binary(/* Box<ast::Expr> */, /* ast::BinOp */, /* Box<ast::Expr> */);
    |

error[E0559]: variant `ast::Expr::Binary` has no field named `left`
   --> compiler/src/consteval/mod.rs:349:13
    |
349 |             left: Box::new(Expr::Literal {
    |             ^^^^ field does not exist
    |
   ::: compiler/src/parser/ast.rs:97:5
    |
 97 |     Binary(Box<Expr>, BinOp, Box<Expr>),
    |     ------ `ast::Expr::Binary` defined here
    |
help: `ast::Expr::Binary` is a tuple variant, use the appropriate syntax
    |
347 -         let expr = Expr::Binary {
348 -             op: BinaryOp::Add,
349 -             left: Box::new(Expr::Literal {
350 -                 value: Literal::Int(10),
351 -                 span: Span::dummy(),
352 -             }),
353 -             right: Box::new(Expr::Literal {
354 -                 value: Literal::Int(32),
355 -                 span: Span::dummy(),
356 -             }),
357 -             span: Span::dummy(),
358 -         };
347 +         let expr = Expr::Binary(/* Box<ast::Expr> */, /* ast::BinOp */, /* Box<ast::Expr> */);
    |

error[E0559]: variant `ast::Expr::Literal` has no field named `value`
   --> compiler/src/consteval/mod.rs:350:17
    |
350 |                 value: Literal::Int(10),
    |                 ^^^^^ field does not exist
    |
   ::: compiler/src/parser/ast.rs:95:5
    |
 95 |     Literal(Literal),
    |     ------- `ast::Expr::Literal` defined here
    |
help: `ast::Expr::Literal` is a tuple variant, use the appropriate syntax
    |
349 -             left: Box::new(Expr::Literal {
350 -                 value: Literal::Int(10),
351 -                 span: Span::dummy(),
352 -             }),
349 +             left: Box::new(Expr::Literal(/* ast::Literal */)),
    |

error[E0559]: variant `ast::Expr::Literal` has no field named `span`
   --> compiler/src/consteval/mod.rs:351:17
    |
351 |                 span: Span::dummy(),
    |                 ^^^^ field does not exist
    |
   ::: compiler/src/parser/ast.rs:95:5
    |
 95 |     Literal(Literal),
    |     ------- `ast::Expr::Literal` defined here
    |
help: `ast::Expr::Literal` is a tuple variant, use the appropriate syntax
    |
349 -             left: Box::new(Expr::Literal {
350 -                 value: Literal::Int(10),
351 -                 span: Span::dummy(),
352 -             }),
349 +             left: Box::new(Expr::Literal(/* ast::Literal */)),
    |

error[E0559]: variant `ast::Expr::Binary` has no field named `right`
   --> compiler/src/consteval/mod.rs:353:13
    |
353 |             right: Box::new(Expr::Literal {
    |             ^^^^^ field does not exist
    |
   ::: compiler/src/parser/ast.rs:97:5
    |
 97 |     Binary(Box<Expr>, BinOp, Box<Expr>),
    |     ------ `ast::Expr::Binary` defined here
    |
help: `ast::Expr::Binary` is a tuple variant, use the appropriate syntax
    |
347 -         let expr = Expr::Binary {
348 -             op: BinaryOp::Add,
349 -             left: Box::new(Expr::Literal {
350 -                 value: Literal::Int(10),
351 -                 span: Span::dummy(),
352 -             }),
353 -             right: Box::new(Expr::Literal {
354 -                 value: Literal::Int(32),
355 -                 span: Span::dummy(),
356 -             }),
357 -             span: Span::dummy(),
358 -         };
347 +         let expr = Expr::Binary(/* Box<ast::Expr> */, /* ast::BinOp */, /* Box<ast::Expr> */);
    |

error[E0559]: variant `ast::Expr::Literal` has no field named `value`
   --> compiler/src/consteval/mod.rs:354:17
    |
354 |                 value: Literal::Int(32),
    |                 ^^^^^ field does not exist
    |
   ::: compiler/src/parser/ast.rs:95:5
    |
 95 |     Literal(Literal),
    |     ------- `ast::Expr::Literal` defined here
    |
help: `ast::Expr::Literal` is a tuple variant, use the appropriate syntax
    |
353 -             right: Box::new(Expr::Literal {
354 -                 value: Literal::Int(32),
355 -                 span: Span::dummy(),
356 -             }),
353 +             right: Box::new(Expr::Literal(/* ast::Literal */)),
    |

error[E0559]: variant `ast::Expr::Literal` has no field named `span`
   --> compiler/src/consteval/mod.rs:355:17
    |
355 |                 span: Span::dummy(),
    |                 ^^^^ field does not exist
    |
   ::: compiler/src/parser/ast.rs:95:5
    |
 95 |     Literal(Literal),
    |     ------- `ast::Expr::Literal` defined here
    |
help: `ast::Expr::Literal` is a tuple variant, use the appropriate syntax
    |
353 -             right: Box::new(Expr::Literal {
354 -                 value: Literal::Int(32),
355 -                 span: Span::dummy(),
356 -             }),
353 +             right: Box::new(Expr::Literal(/* ast::Literal */)),
    |

error[E0559]: variant `ast::Expr::Binary` has no field named `span`
   --> compiler/src/consteval/mod.rs:357:13
    |
357 |             span: Span::dummy(),
    |             ^^^^ field does not exist
    |
   ::: compiler/src/parser/ast.rs:97:5
    |
 97 |     Binary(Box<Expr>, BinOp, Box<Expr>),
    |     ------ `ast::Expr::Binary` defined here
    |
help: `ast::Expr::Binary` is a tuple variant, use the appropriate syntax
    |
347 -         let expr = Expr::Binary {
348 -             op: BinaryOp::Add,
349 -             left: Box::new(Expr::Literal {
350 -                 value: Literal::Int(10),
351 -                 span: Span::dummy(),
352 -             }),
353 -             right: Box::new(Expr::Literal {
354 -                 value: Literal::Int(32),
355 -                 span: Span::dummy(),
356 -             }),
357 -             span: Span::dummy(),
358 -         };
347 +         let expr = Expr::Binary(/* Box<ast::Expr> */, /* ast::BinOp */, /* Box<ast::Expr> */);
    |

warning: variable does not need to be mutable
   --> compiler/src/consteval/mod.rs:366:13
    |
366 |         let mut eval = ConstEvaluator::new();
    |             ----^^^^
    |             |
    |             help: remove this `mut`

Some errors have detailed explanations: E0023, E0026, E0027, E0277, E0282, E0308, E0412, E0428, E0432...
warning: `vez_compiler` (lib test) generated 16 warnings (13 duplicates)
error: could not compile `vez_compiler` (lib test) due to 309 previous errors; 16 warnings emitted
[0;32mâœ“[0m All workspace tests passed: 

==========================================
6. Module Tests
==========================================
[1;33mâ†’[0m Testing lexer module...
[1;33mâš [0m lexer module tests incomplete or failed
[1;33mâ†’[0m Testing parser module...
[1;33mâš [0m parser module tests incomplete or failed
[1;33mâ†’[0m Testing semantic module...
[1;33mâš [0m semantic module tests incomplete or failed
[1;33mâ†’[0m Testing borrow module...
[1;33mâš [0m borrow module tests incomplete or failed
[1;33mâ†’[0m Testing ir module...
[1;33mâš [0m ir module tests incomplete or failed
[1;33mâ†’[0m Testing optimizer module...
[1;33mâš [0m optimizer module tests incomplete or failed
[1;33mâ†’[0m Testing codegen module...
[1;33mâš [0m codegen module tests incomplete or failed
[1;33mâ†’[0m Testing macro_system module...
[1;33mâš [0m macro_system module tests incomplete or failed
[1;33mâ†’[0m Testing async_runtime module...
[1;33mâš [0m async_runtime module tests incomplete or failed
[1;33mâ†’[0m Testing verification module...
[1;33mâš [0m verification module tests incomplete or failed
[1;33mâ†’[0m Testing gpu module...
[1;33mâš [0m gpu module tests incomplete or failed
[1;33mâ†’[0m Testing consteval module...
[1;33mâš [0m consteval module tests incomplete or failed
[1;33mâ†’[0m Testing plugin module...
[1;33mâš [0m plugin module tests incomplete or failed

==========================================
7. Code Quality Checks
==========================================
[1;33mâ†’[0m Running cargo check...
warning: profiles for the non root package will be ignored, specify profiles at the workspace root:
package:   /run/media/zarigata/42A0B8BDA0B8B8AD/ARTIFICIAL-INTELIGENCE/ArtificialProgramingLanguage/compiler/Cargo.toml
workspace: /run/media/zarigata/42A0B8BDA0B8B8AD/ARTIFICIAL-INTELIGENCE/ArtificialProgramingLanguage/Cargo.toml
    Checking memchr v2.7.6
    Checking utf8parse v0.2.2
    Checking anstyle-query v1.1.5
    Checking is_terminal_polyfill v1.70.2
    Checking anstyle v1.0.13
    Checking colorchoice v1.0.4
    Checking regex-syntax v0.8.8
    Checking strsim v0.11.1
    Checking clap_lex v0.7.6
    Checking equivalent v1.0.2
    Checking serde_core v1.0.228
    Checking hashbrown v0.16.1
    Checking log v0.4.29
    Checking zmij v1.0.12
    Checking anyhow v1.0.100
    Checking winnow v0.7.14
    Checking itoa v1.0.17
    Checking toml_write v0.1.2
    Checking jiff v0.2.18
    Checking anstyle-parse v0.2.7
    Checking anstream v0.6.21
    Checking clap_builder v4.5.54
    Checking aho-corasick v1.1.4
    Checking indexmap v2.13.0
    Checking regex-automata v0.4.13
    Checking clap v4.5.54
    Checking serde v1.0.228
    Checking serde_json v1.0.149
    Checking serde_spanned v0.6.9
    Checking toml_datetime v0.6.11
    Checking vez_testing v1.0.0 (/run/media/zarigata/42A0B8BDA0B8B8AD/ARTIFICIAL-INTELIGENCE/ArtificialProgramingLanguage/tools/testing)
warning: unused import: `std::collections::HashMap`
 --> tools/testing/src/framework.rs:4:5
  |
4 | use std::collections::HashMap;
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` (part of `#[warn(unused)]`) on by default

warning: `vez_testing` (lib) generated 1 warning (run `cargo fix --lib -p vez_testing` to apply 1 suggestion)
    Checking toml_edit v0.22.27
    Checking vez_lsp v1.0.0 (/run/media/zarigata/42A0B8BDA0B8B8AD/ARTIFICIAL-INTELIGENCE/ArtificialProgramingLanguage/tools/lsp)
warning: unused variable: `uri`
   --> tools/lsp/src/main.rs:242:30
    |
242 |     pub fn completion(&self, uri: &str, position: Position) -> Vec<CompletionItem> {
    |                              ^^^ help: if this is intentional, prefix it with an underscore: `_uri`
    |
    = note: `#[warn(unused_variables)]` (part of `#[warn(unused)]`) on by default

warning: unused variable: `position`
   --> tools/lsp/src/main.rs:242:41
    |
242 |     pub fn completion(&self, uri: &str, position: Position) -> Vec<CompletionItem> {
    |                                         ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_position`

warning: unused variable: `new_name`
   --> tools/lsp/src/main.rs:304:57
    |
304 |     pub fn rename(&self, uri: &str, position: Position, new_name: String) -> Vec<Location> {
    |                                                         ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_new_name`

warning: unused variable: `server`
   --> tools/lsp/src/main.rs:378:9
    |
378 |     let server = LanguageServer::new();
    |         ^^^^^^ help: if this is intentional, prefix it with an underscore: `_server`

warning: `vez_lsp` (bin "vez-lsp") generated 4 warnings (run `cargo fix --bin "vez-lsp" -p vez_lsp` to apply 4 suggestions)
    Checking regex v1.12.2
    Checking env_filter v0.1.4
    Checking env_logger v0.11.8
    Checking vez_compiler v0.1.0 (/run/media/zarigata/42A0B8BDA0B8B8AD/ARTIFICIAL-INTELIGENCE/ArtificialProgramingLanguage/compiler)
error[E0583]: file not found for module `hygiene`
 --> compiler/src/macro_system/mod.rs:5:1
  |
5 | pub mod hygiene;
  | ^^^^^^^^^^^^^^^^
  |
  = help: to create the module `hygiene`, create file "compiler/src/macro_system/hygiene.rs" or "compiler/src/macro_system/hygiene/mod.rs"
  = note: if there is a `mod hygiene` elsewhere in the crate already, import it with `use crate::...` instead

error[E0583]: file not found for module `parser`
 --> compiler/src/macro_system/mod.rs:6:1
  |
6 | pub mod parser;
  | ^^^^^^^^^^^^^^^
  |
  = help: to create the module `parser`, create file "compiler/src/macro_system/parser.rs" or "compiler/src/macro_system/parser/mod.rs"
  = note: if there is a `mod parser` elsewhere in the crate already, import it with `use crate::...` instead

error[E0583]: file not found for module `builtin`
 --> compiler/src/macro_system/mod.rs:7:1
  |
7 | pub mod builtin;
  | ^^^^^^^^^^^^^^^^
  |
  = help: to create the module `builtin`, create file "compiler/src/macro_system/builtin.rs" or "compiler/src/macro_system/builtin/mod.rs"
  = note: if there is a `mod builtin` elsewhere in the crate already, import it with `use crate::...` instead

error[E0583]: file not found for module `future`
 --> compiler/src/async_runtime/mod.rs:4:1
  |
4 | pub mod future;
  | ^^^^^^^^^^^^^^^
  |
  = help: to create the module `future`, create file "compiler/src/async_runtime/future.rs" or "compiler/src/async_runtime/future/mod.rs"
  = note: if there is a `mod future` elsewhere in the crate already, import it with `use crate::...` instead

error[E0583]: file not found for module `task`
 --> compiler/src/async_runtime/mod.rs:6:1
  |
6 | pub mod task;
  | ^^^^^^^^^^^^^
  |
  = help: to create the module `task`, create file "compiler/src/async_runtime/task.rs" or "compiler/src/async_runtime/task/mod.rs"
  = note: if there is a `mod task` elsewhere in the crate already, import it with `use crate::...` instead

error[E0583]: file not found for module `waker`
 --> compiler/src/async_runtime/mod.rs:7:1
  |
7 | pub mod waker;
  | ^^^^^^^^^^^^^^
  |
  = help: to create the module `waker`, create file "compiler/src/async_runtime/waker.rs" or "compiler/src/async_runtime/waker/mod.rs"
  = note: if there is a `mod waker` elsewhere in the crate already, import it with `use crate::...` instead

error[E0583]: file not found for module `proof_engine`
 --> compiler/src/verification/mod.rs:5:1
  |
5 | pub mod proof_engine;
  | ^^^^^^^^^^^^^^^^^^^^^
  |
  = help: to create the module `proof_engine`, create file "compiler/src/verification/proof_engine.rs" or "compiler/src/verification/proof_engine/mod.rs"
  = note: if there is a `mod proof_engine` elsewhere in the crate already, import it with `use crate::...` instead

error[E0583]: file not found for module `safety_checker`
 --> compiler/src/verification/mod.rs:6:1
  |
6 | pub mod safety_checker;
  | ^^^^^^^^^^^^^^^^^^^^^^^
  |
  = help: to create the module `safety_checker`, create file "compiler/src/verification/safety_checker.rs" or "compiler/src/verification/safety_checker/mod.rs"
  = note: if there is a `mod safety_checker` elsewhere in the crate already, import it with `use crate::...` instead

error[E0583]: file not found for module `contracts`
 --> compiler/src/verification/mod.rs:7:1
  |
7 | pub mod contracts;
  | ^^^^^^^^^^^^^^^^^^
  |
  = help: to create the module `contracts`, create file "compiler/src/verification/contracts.rs" or "compiler/src/verification/contracts/mod.rs"
  = note: if there is a `mod contracts` elsewhere in the crate already, import it with `use crate::...` instead

error[E0583]: file not found for module `cuda`
 --> compiler/src/gpu/mod.rs:4:1
  |
4 | pub mod cuda;
  | ^^^^^^^^^^^^^
  |
  = help: to create the module `cuda`, create file "compiler/src/gpu/cuda.rs" or "compiler/src/gpu/cuda/mod.rs"
  = note: if there is a `mod cuda` elsewhere in the crate already, import it with `use crate::...` instead

error[E0583]: file not found for module `metal`
 --> compiler/src/gpu/mod.rs:5:1
  |
5 | pub mod metal;
  | ^^^^^^^^^^^^^^
  |
  = help: to create the module `metal`, create file "compiler/src/gpu/metal.rs" or "compiler/src/gpu/metal/mod.rs"
  = note: if there is a `mod metal` elsewhere in the crate already, import it with `use crate::...` instead

error[E0583]: file not found for module `vulkan`
 --> compiler/src/gpu/mod.rs:6:1
  |
6 | pub mod vulkan;
  | ^^^^^^^^^^^^^^^
  |
  = help: to create the module `vulkan`, create file "compiler/src/gpu/vulkan.rs" or "compiler/src/gpu/vulkan/mod.rs"
  = note: if there is a `mod vulkan` elsewhere in the crate already, import it with `use crate::...` instead

error[E0583]: file not found for module `kernel`
 --> compiler/src/gpu/mod.rs:7:1
  |
7 | pub mod kernel;
  | ^^^^^^^^^^^^^^^
  |
  = help: to create the module `kernel`, create file "compiler/src/gpu/kernel.rs" or "compiler/src/gpu/kernel/mod.rs"
  = note: if there is a `mod kernel` elsewhere in the crate already, import it with `use crate::...` instead

error[E0432]: unresolved import `crate::semantic::types`
  --> compiler/src/verification/mod.rs:10:22
   |
10 | use crate::semantic::types::Type;
   |                      ^^^^^ could not find `types` in `semantic`

error[E0432]: unresolved import `crate::semantic::types`
 --> compiler/src/consteval/mod.rs:5:22
  |
5 | use crate::semantic::types::Type;
  |                      ^^^^^ could not find `types` in `semantic`

error[E0432]: unresolved import `crate::error::CompilerError`
 --> compiler/src/codegen/llvm_backend.rs:6:28
  |
6 | use crate::error::{Result, CompilerError};
  |                            ^^^^^^^^^^^^^ no `CompilerError` in `error`

error[E0432]: unresolved import `crate::error::CompilerError`
 --> compiler/src/codegen/target.rs:3:28
  |
3 | use crate::error::{Result, CompilerError};
  |                            ^^^^^^^^^^^^^ no `CompilerError` in `error`

error[E0432]: unresolved import `crate::error::CompilerError`
 --> compiler/src/codegen/linker.rs:3:28
  |
3 | use crate::error::{Result, CompilerError};
  |                            ^^^^^^^^^^^^^ no `CompilerError` in `error`

error[E0532]: expected tuple struct or tuple variant, found unit variant `Constant::Null`
   --> compiler/src/codegen/llvm_backend.rs:129:13
    |
129 |             Constant::Null(ty) => format!("{} null", self.type_to_llvm(ty)),
    |             ^^^^^^^^^^^^^^^^^^ help: use this syntax instead: `Constant::Null`
    |
   ::: compiler/src/ir/ssa.rs:30:5
    |
 30 |     Null,
    |     ---- `Constant::Null` defined here

error[E0532]: expected tuple struct or tuple variant, found unit variant `Constant::Undef`
   --> compiler/src/codegen/llvm_backend.rs:130:13
    |
130 |             Constant::Undef(ty) => format!("{} undef", self.type_to_llvm(ty)),
    |             ^^^^^^^^^^^^^^^^^^^ help: use this syntax instead: `Constant::Undef`
    |
   ::: compiler/src/ir/ssa.rs:31:5
    |
 31 |     Undef,
    |     ----- `Constant::Undef` defined here

error[E0433]: failed to resolve: use of undeclared type `Pin`
  --> compiler/src/async_runtime/executor.rs:64:19
   |
64 |             match Pin::new(&mut future).poll(&waker) {
   |                   ^^^ use of undeclared type `Pin`
   |
help: consider importing this struct
   |
 4 + use std::pin::Pin;
   |

error[E0412]: cannot find type `Thread` in this scope
   --> compiler/src/async_runtime/executor.rs:112:18
    |
112 |     threads: Vec<Thread>,
    |                  ^^^^^^ not found in this scope
    |
help: consider importing this struct
    |
  4 + use std::thread::Thread;
    |

error[E0412]: cannot find type `Arc` in this scope
   --> compiler/src/async_runtime/executor.rs:113:17
    |
113 |     task_queue: Arc<Mutex<VecDeque<Box<dyn Task>>>>,
    |                 ^^^ not found in this scope
    |
help: consider importing this struct
    |
  4 + use std::sync::Arc;
    |

error[E0412]: cannot find type `Mutex` in this scope
   --> compiler/src/async_runtime/executor.rs:113:21
    |
113 |     task_queue: Arc<Mutex<VecDeque<Box<dyn Task>>>>,
    |                     ^^^^^ not found in this scope
    |
help: consider importing one of these structs
    |
  4 + use std::sync::Mutex;
    |
  4 + use std::sync::nonpoison::Mutex;
    |

error[E0433]: failed to resolve: use of undeclared type `Arc`
   --> compiler/src/async_runtime/executor.rs:118:26
    |
118 |         let task_queue = Arc::new(Mutex::new(VecDeque::new()));
    |                          ^^^ use of undeclared type `Arc`
    |
help: consider importing this struct
    |
  4 + use std::sync::Arc;
    |

error[E0433]: failed to resolve: use of undeclared type `Mutex`
   --> compiler/src/async_runtime/executor.rs:118:35
    |
118 |         let task_queue = Arc::new(Mutex::new(VecDeque::new()));
    |                                   ^^^^^ use of undeclared type `Mutex`
    |
help: consider importing one of these structs
    |
  4 + use std::sync::Mutex;
    |
  4 + use std::sync::nonpoison::Mutex;
    |

error[E0433]: failed to resolve: use of undeclared type `Thread`
   --> compiler/src/async_runtime/executor.rs:123:26
    |
123 |             let thread = Thread::spawn(move || {
    |                          ^^^^^^ use of undeclared type `Thread`
    |
help: consider importing this struct
    |
  4 + use std::thread::Thread;
    |

error[E0433]: failed to resolve: use of undeclared type `Thread`
   --> compiler/src/async_runtime/executor.rs:135:25
    |
135 |                         Thread::sleep(Duration::from_millis(10));
    |                         ^^^^^^ use of undeclared type `Thread`
    |
help: consider importing this struct
    |
  4 + use std::thread::Thread;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/verification/smt_solver.rs:113:77
    |
113 |                     _ => Err(Error::new("Unsupported literal type for SMT", Span::dummy())),
    |                                                                             ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/verification/smt_solver.rs:122:21
    |
122 |                     BinaryOp::Add => "+",
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/verification/smt_solver.rs:123:21
    |
123 |                     BinaryOp::Sub => "-",
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/verification/smt_solver.rs:124:21
    |
124 |                     BinaryOp::Mul => "*",
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/verification/smt_solver.rs:125:21
    |
125 |                     BinaryOp::Div => "div",
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/verification/smt_solver.rs:126:21
    |
126 |                     BinaryOp::Eq => "=",
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/verification/smt_solver.rs:127:21
    |
127 |                     BinaryOp::Ne => "distinct",
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/verification/smt_solver.rs:128:21
    |
128 |                     BinaryOp::Lt => "<",
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/verification/smt_solver.rs:129:21
    |
129 |                     BinaryOp::Le => "<=",
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/verification/smt_solver.rs:130:21
    |
130 |                     BinaryOp::Gt => ">",
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/verification/smt_solver.rs:131:21
    |
131 |                     BinaryOp::Ge => ">=",
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/verification/smt_solver.rs:132:21
    |
132 |                     BinaryOp::And => "and",
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/verification/smt_solver.rs:133:21
    |
133 |                     BinaryOp::Or => "or",
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/verification/smt_solver.rs:134:87
    |
134 |                     _ => return Err(Error::new("Unsupported binary operator for SMT", Span::dummy())),
    |                                                                                       ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0433]: failed to resolve: use of undeclared type `UnaryOp`
   --> compiler/src/verification/smt_solver.rs:143:21
    |
143 |                     UnaryOp::Not => "not",
    |                     ^^^^^^^ use of undeclared type `UnaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::UnaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `UnaryOp`
   --> compiler/src/verification/smt_solver.rs:144:21
    |
144 |                     UnaryOp::Neg => "-",
    |                     ^^^^^^^ use of undeclared type `UnaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::UnaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/verification/smt_solver.rs:145:86
    |
145 |                     _ => return Err(Error::new("Unsupported unary operator for SMT", Span::dummy())),
    |                                                                                      ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/verification/smt_solver.rs:150:72
    |
150 |             _ => Err(Error::new("Unsupported expression type for SMT", Span::dummy())),
    |                                                                        ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/verification/smt_solver.rs:195:83
    |
195 |             .map_err(|e| Error::new(format!("Failed to spawn SMT solver: {}", e), Span::dummy()))?;
    |                                                                                   ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/verification/smt_solver.rs:199:90
    |
199 |                 .map_err(|e| Error::new(format!("Failed to write to SMT solver: {}", e), Span::dummy()))?;
    |                                                                                          ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/verification/smt_solver.rs:203:89
    |
203 |             .map_err(|e| Error::new(format!("Failed to read SMT solver output: {}", e), Span::dummy()))?;
    |                                                                                         ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0412]: cannot find type `BinaryOp` in this scope
   --> compiler/src/gpu/mod.rs:285:34
    |
285 |     fn binary_op_str(&self, op: &BinaryOp) -> &str {
    |                                  ^^^^^^^^ not found in this scope
    |
help: consider importing this enum
    |
  9 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/gpu/mod.rs:287:13
    |
287 |             BinaryOp::Add => "+",
    |             ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  9 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/gpu/mod.rs:288:13
    |
288 |             BinaryOp::Sub => "-",
    |             ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  9 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/gpu/mod.rs:289:13
    |
289 |             BinaryOp::Mul => "*",
    |             ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  9 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/gpu/mod.rs:290:13
    |
290 |             BinaryOp::Div => "/",
    |             ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  9 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/gpu/mod.rs:291:13
    |
291 |             BinaryOp::Mod => "%",
    |             ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  9 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/gpu/mod.rs:292:13
    |
292 |             BinaryOp::Eq => "==",
    |             ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  9 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/gpu/mod.rs:293:13
    |
293 |             BinaryOp::Ne => "!=",
    |             ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  9 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/gpu/mod.rs:294:13
    |
294 |             BinaryOp::Lt => "<",
    |             ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  9 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/gpu/mod.rs:295:13
    |
295 |             BinaryOp::Le => "<=",
    |             ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  9 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/gpu/mod.rs:296:13
    |
296 |             BinaryOp::Gt => ">",
    |             ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  9 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/gpu/mod.rs:297:13
    |
297 |             BinaryOp::Ge => ">=",
    |             ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  9 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
  --> compiler/src/consteval/mod.rs:68:25
   |
68 |                         Span::dummy()
   |                         ^^^^ use of undeclared type `Span`
   |
help: consider importing this struct through its public re-export
   |
 4 + use crate::prelude::Span;
   |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/consteval/mod.rs:108:17
    |
108 |                 Span::dummy()
    |                 ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0412]: cannot find type `BinaryOp` in this scope
   --> compiler/src/consteval/mod.rs:123:34
    |
123 |     fn eval_binary_op(&self, op: BinaryOp, left: &ConstValue, right: &ConstValue) -> Result<ConstValue> {
    |                                  ^^^^^^^^ not found in this scope
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:127:21
    |
127 |                     BinaryOp::Add => ConstValue::Int(l + r),
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:128:21
    |
128 |                     BinaryOp::Sub => ConstValue::Int(l - r),
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:129:21
    |
129 |                     BinaryOp::Mul => ConstValue::Int(l * r),
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:130:21
    |
130 |                     BinaryOp::Div => {
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/consteval/mod.rs:132:71
    |
132 | ...                   return Err(Error::new("Division by zero", Span::dummy()));
    |                                                                 ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:136:21
    |
136 |                     BinaryOp::Mod => ConstValue::Int(l % r),
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:137:21
    |
137 |                     BinaryOp::Eq => ConstValue::Bool(l == r),
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:138:21
    |
138 |                     BinaryOp::Ne => ConstValue::Bool(l != r),
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:139:21
    |
139 |                     BinaryOp::Lt => ConstValue::Bool(l < r),
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:140:21
    |
140 |                     BinaryOp::Le => ConstValue::Bool(l <= r),
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:141:21
    |
141 |                     BinaryOp::Gt => ConstValue::Bool(l > r),
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:142:21
    |
142 |                     BinaryOp::Ge => ConstValue::Bool(l >= r),
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:143:21
    |
143 |                     BinaryOp::BitAnd => ConstValue::Int(l & r),
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:144:21
    |
144 |                     BinaryOp::BitOr => ConstValue::Int(l | r),
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:145:21
    |
145 |                     BinaryOp::BitXor => ConstValue::Int(l ^ r),
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:146:21
    |
146 |                     BinaryOp::Shl => ConstValue::Int(l << r),
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:147:21
    |
147 |                     BinaryOp::Shr => ConstValue::Int(l >> r),
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/consteval/mod.rs:148:80
    |
148 |                     _ => return Err(Error::new("Unsupported binary operation", Span::dummy())),
    |                                                                                ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:155:21
    |
155 |                     BinaryOp::Add => ConstValue::Float(l + r),
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:156:21
    |
156 |                     BinaryOp::Sub => ConstValue::Float(l - r),
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:157:21
    |
157 |                     BinaryOp::Mul => ConstValue::Float(l * r),
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:158:21
    |
158 |                     BinaryOp::Div => ConstValue::Float(l / r),
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:159:21
    |
159 |                     BinaryOp::Eq => ConstValue::Bool(l == r),
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:160:21
    |
160 |                     BinaryOp::Ne => ConstValue::Bool(l != r),
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:161:21
    |
161 |                     BinaryOp::Lt => ConstValue::Bool(l < r),
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:162:21
    |
162 |                     BinaryOp::Le => ConstValue::Bool(l <= r),
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:163:21
    |
163 |                     BinaryOp::Gt => ConstValue::Bool(l > r),
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:164:21
    |
164 |                     BinaryOp::Ge => ConstValue::Bool(l >= r),
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/consteval/mod.rs:165:80
    |
165 |                     _ => return Err(Error::new("Unsupported binary operation", Span::dummy())),
    |                                                                                ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:172:21
    |
172 |                     BinaryOp::And => ConstValue::Bool(*l && *r),
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:173:21
    |
173 |                     BinaryOp::Or => ConstValue::Bool(*l || *r),
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:174:21
    |
174 |                     BinaryOp::Eq => ConstValue::Bool(l == r),
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:175:21
    |
175 |                     BinaryOp::Ne => ConstValue::Bool(l != r),
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/consteval/mod.rs:176:80
    |
176 |                     _ => return Err(Error::new("Unsupported binary operation", Span::dummy())),
    |                                                                                ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/consteval/mod.rs:181:70
    |
181 |             _ => Err(Error::new("Type mismatch in binary operation", Span::dummy())),
    |                                                                      ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0412]: cannot find type `UnaryOp` in this scope
   --> compiler/src/consteval/mod.rs:185:33
    |
185 |     fn eval_unary_op(&self, op: UnaryOp, val: &ConstValue) -> Result<ConstValue> {
    |                                 ^^^^^^^ not found in this scope
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::UnaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `UnaryOp`
   --> compiler/src/consteval/mod.rs:189:21
    |
189 |                     UnaryOp::Neg => ConstValue::Int(-n),
    |                     ^^^^^^^ use of undeclared type `UnaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::UnaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `UnaryOp`
   --> compiler/src/consteval/mod.rs:190:21
    |
190 |                     UnaryOp::Not => ConstValue::Bool(*n == 0),
    |                     ^^^^^^^ use of undeclared type `UnaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::UnaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `UnaryOp`
   --> compiler/src/consteval/mod.rs:191:21
    |
191 |                     UnaryOp::BitNot => ConstValue::Int(!n),
    |                     ^^^^^^^ use of undeclared type `UnaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::UnaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/consteval/mod.rs:192:79
    |
192 |                     _ => return Err(Error::new("Unsupported unary operation", Span::dummy())),
    |                                                                               ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0433]: failed to resolve: use of undeclared type `UnaryOp`
   --> compiler/src/consteval/mod.rs:199:21
    |
199 |                     UnaryOp::Neg => ConstValue::Float(-f),
    |                     ^^^^^^^ use of undeclared type `UnaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::UnaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/consteval/mod.rs:200:79
    |
200 |                     _ => return Err(Error::new("Unsupported unary operation", Span::dummy())),
    |                                                                               ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0433]: failed to resolve: use of undeclared type `UnaryOp`
   --> compiler/src/consteval/mod.rs:207:21
    |
207 |                     UnaryOp::Not => ConstValue::Bool(!b),
    |                     ^^^^^^^ use of undeclared type `UnaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::UnaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/consteval/mod.rs:208:79
    |
208 |                     _ => return Err(Error::new("Unsupported unary operation", Span::dummy())),
    |                                                                               ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/consteval/mod.rs:213:69
    |
213 |             _ => Err(Error::new("Type mismatch in unary operation", Span::dummy())),
    |                                                                     ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/consteval/mod.rs:221:65
    |
221 |             _ => return Err(Error::new("Invalid function call", Span::dummy())),
    |                                                                 ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/consteval/mod.rs:239:17
    |
239 |                 Span::dummy()
    |                 ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/consteval/mod.rs:246:61
    |
246 |             return Err(Error::new("abs expects 1 argument", Span::dummy()));
    |                                                             ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/consteval/mod.rs:252:65
    |
252 |             _ => Err(Error::new("abs expects numeric argument", Span::dummy())),
    |                                                                 ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/consteval/mod.rs:258:62
    |
258 |             return Err(Error::new("min expects 2 arguments", Span::dummy()));
    |                                                              ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/consteval/mod.rs:264:66
    |
264 |             _ => Err(Error::new("min expects numeric arguments", Span::dummy())),
    |                                                                  ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/consteval/mod.rs:270:62
    |
270 |             return Err(Error::new("max expects 2 arguments", Span::dummy()));
    |                                                              ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/consteval/mod.rs:276:66
    |
276 |             _ => Err(Error::new("max expects numeric arguments", Span::dummy())),
    |                                                                  ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/consteval/mod.rs:282:62
    |
282 |             return Err(Error::new("pow expects 2 arguments", Span::dummy()));
    |                                                              ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/consteval/mod.rs:291:80
    |
291 |                     return Err(Error::new("Negative exponent for integer pow", Span::dummy()));
    |                                                                                ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/consteval/mod.rs:295:66
    |
295 |             _ => Err(Error::new("pow expects numeric arguments", Span::dummy())),
    |                                                                  ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/consteval/mod.rs:301:62
    |
301 |             return Err(Error::new("sqrt expects 1 argument", Span::dummy()));
    |                                                              ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/consteval/mod.rs:307:70
    |
307 |                     return Err(Error::new("sqrt of negative number", Span::dummy()));
    |                                                                      ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/consteval/mod.rs:311:64
    |
311 |             _ => Err(Error::new("sqrt expects float argument", Span::dummy())),
    |                                                                ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0412]: cannot find type `BinaryOp` in this scope
  --> compiler/src/plugin/api.rs:60:40
   |
60 |     pub fn create_binary_op(&self, op: BinaryOp, left: Expr, right: Expr) -> Expr {
   |                                        ^^^^^^^^ not found in this scope
   |
help: consider importing this enum
   |
 4 + use crate::ir::instructions::BinaryOp;
   |

error[E0412]: cannot find type `Span` in this scope
   --> compiler/src/plugin/mod.rs:151:19
    |
151 |     pub location: Span,
    |                   ^^^^ not found in this scope
    |
help: consider importing this struct through its public re-export
    |
  9 + use crate::prelude::Span;
    |

error[E0659]: `Function` is ambiguous
  --> compiler/src/gpu/mod.rs:78:42
   |
78 |     pub fn generate_kernel(&self, func: &Function) -> Result<String> {
   |                                          ^^^^^^^^ ambiguous name
   |
   = note: ambiguous because of multiple glob imports of a name in the same module
note: `Function` could refer to the struct imported here
  --> compiler/src/gpu/mod.rs:9:5
   |
 9 | use crate::parser::ast::*;
   |     ^^^^^^^^^^^^^^^^^^^^^
   = help: consider adding an explicit import of `Function` to disambiguate
note: `Function` could also refer to the struct imported here
  --> compiler/src/gpu/mod.rs:10:5
   |
10 | use crate::ir::ssa::*;
   |     ^^^^^^^^^^^^^^^^^
   = help: consider adding an explicit import of `Function` to disambiguate

error[E0659]: `Function` is ambiguous
  --> compiler/src/gpu/mod.rs:87:43
   |
87 |     fn generate_cuda_kernel(&self, func: &Function) -> Result<String> {
   |                                           ^^^^^^^^ ambiguous name
   |
   = note: ambiguous because of multiple glob imports of a name in the same module
note: `Function` could refer to the struct imported here
  --> compiler/src/gpu/mod.rs:9:5
   |
 9 | use crate::parser::ast::*;
   |     ^^^^^^^^^^^^^^^^^^^^^
   = help: consider adding an explicit import of `Function` to disambiguate
note: `Function` could also refer to the struct imported here
  --> compiler/src/gpu/mod.rs:10:5
   |
10 | use crate::ir::ssa::*;
   |     ^^^^^^^^^^^^^^^^^
   = help: consider adding an explicit import of `Function` to disambiguate

error[E0659]: `Function` is ambiguous
   --> compiler/src/gpu/mod.rs:120:44
    |
120 |     fn generate_metal_kernel(&self, func: &Function) -> Result<String> {
    |                                            ^^^^^^^^ ambiguous name
    |
    = note: ambiguous because of multiple glob imports of a name in the same module
note: `Function` could refer to the struct imported here
   --> compiler/src/gpu/mod.rs:9:5
    |
  9 | use crate::parser::ast::*;
    |     ^^^^^^^^^^^^^^^^^^^^^
    = help: consider adding an explicit import of `Function` to disambiguate
note: `Function` could also refer to the struct imported here
   --> compiler/src/gpu/mod.rs:10:5
    |
 10 | use crate::ir::ssa::*;
    |     ^^^^^^^^^^^^^^^^^
    = help: consider adding an explicit import of `Function` to disambiguate

error[E0659]: `Function` is ambiguous
   --> compiler/src/gpu/mod.rs:157:45
    |
157 |     fn generate_vulkan_kernel(&self, func: &Function) -> Result<String> {
    |                                             ^^^^^^^^ ambiguous name
    |
    = note: ambiguous because of multiple glob imports of a name in the same module
note: `Function` could refer to the struct imported here
   --> compiler/src/gpu/mod.rs:9:5
    |
  9 | use crate::parser::ast::*;
    |     ^^^^^^^^^^^^^^^^^^^^^
    = help: consider adding an explicit import of `Function` to disambiguate
note: `Function` could also refer to the struct imported here
   --> compiler/src/gpu/mod.rs:10:5
    |
 10 | use crate::ir::ssa::*;
    |     ^^^^^^^^^^^^^^^^^
    = help: consider adding an explicit import of `Function` to disambiguate

error[E0659]: `Function` is ambiguous
   --> compiler/src/gpu/mod.rs:193:45
    |
193 |     fn generate_opencl_kernel(&self, func: &Function) -> Result<String> {
    |                                             ^^^^^^^^ ambiguous name
    |
    = note: ambiguous because of multiple glob imports of a name in the same module
note: `Function` could refer to the struct imported here
   --> compiler/src/gpu/mod.rs:9:5
    |
  9 | use crate::parser::ast::*;
    |     ^^^^^^^^^^^^^^^^^^^^^
    = help: consider adding an explicit import of `Function` to disambiguate
note: `Function` could also refer to the struct imported here
   --> compiler/src/gpu/mod.rs:10:5
    |
 10 | use crate::ir::ssa::*;
    |     ^^^^^^^^^^^^^^^^^
    = help: consider adding an explicit import of `Function` to disambiguate

error[E0659]: `Function` is ambiguous
   --> compiler/src/gpu/mod.rs:227:43
    |
227 |     fn generate_kernel_body(&self, func: &Function) -> Result<String> {
    |                                           ^^^^^^^^ ambiguous name
    |
    = note: ambiguous because of multiple glob imports of a name in the same module
note: `Function` could refer to the struct imported here
   --> compiler/src/gpu/mod.rs:9:5
    |
  9 | use crate::parser::ast::*;
    |     ^^^^^^^^^^^^^^^^^^^^^
    = help: consider adding an explicit import of `Function` to disambiguate
note: `Function` could also refer to the struct imported here
   --> compiler/src/gpu/mod.rs:10:5
    |
 10 | use crate::ir::ssa::*;
    |     ^^^^^^^^^^^^^^^^^
    = help: consider adding an explicit import of `Function` to disambiguate

warning: unused import: `TypeVar`
 --> compiler/src/semantic/type_checker.rs:6:69
  |
6 | use super::type_env::{TypeEnv, InferredType, Substitution, Unifier, TypeVar};
  |                                                                     ^^^^^^^
  |
  = note: `#[warn(unused_imports)]` (part of `#[warn(unused)]`) on by default

warning: unused import: `BasicBlock`
 --> compiler/src/ir/builder.rs:5:42
  |
5 | use super::ssa::{Function as IrFunction, BasicBlock, Value, ValueId, Constant, Module};
  |                                          ^^^^^^^^^^

warning: unused import: `crate::ir::types::IrType`
 --> compiler/src/optimizer/constant_folding.rs:5:5
  |
5 | use crate::ir::types::IrType;
  |     ^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `ValueId`
 --> compiler/src/optimizer/inline.rs:3:54
  |
3 | use crate::ir::ssa::{Module, Function as IrFunction, ValueId};
  |                                                      ^^^^^^^

warning: unused import: `Path`
 --> compiler/src/codegen/linker.rs:5:17
  |
5 | use std::path::{Path, PathBuf};
  |                 ^^^^

warning: unused import: `crate::parser::ast::*`
 --> compiler/src/macro_system/mod.rs:9:5
  |
9 | use crate::parser::ast::*;
  |     ^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `std::prelude::*`
 --> compiler/src/async_runtime/mod.rs:9:5
  |
9 | use std::prelude::*;
  |     ^^^^^^^^^^^^^^^

warning: unused import: `Error`
  --> compiler/src/verification/mod.rs:11:20
   |
11 | use crate::error::{Error, Result};
   |                    ^^^^^

warning: unused import: `std::collections::HashMap`
  --> compiler/src/verification/mod.rs:12:5
   |
12 | use std::collections::HashMap;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `crate::ir::ssa::*`
  --> compiler/src/gpu/mod.rs:10:5
   |
10 | use crate::ir::ssa::*;
   |     ^^^^^^^^^^^^^^^^^

warning: unused import: `Error`
  --> compiler/src/gpu/mod.rs:11:20
   |
11 | use crate::error::{Error, Result};
   |                    ^^^^^

error[E0277]: `F1` is not a future
   --> compiler/src/async_runtime/mod.rs:113:17
    |
113 |     let r1 = f1.await;
    |                 ^^^^^ `F1` is not a future
    |
    = note: F1 must be a future or must implement `IntoFuture` to be awaited
    = note: required for `F1` to implement `IntoFuture`
help: remove the `.await`
    |
113 -     let r1 = f1.await;
113 +     let r1 = f1;
    |
help: consider further restricting type parameter `F1` with trait `Future`
    |
110 |     F1: Future + std::future::Future,
    |                +++++++++++++++++++++

error[E0277]: `F2` is not a future
   --> compiler/src/async_runtime/mod.rs:114:17
    |
114 |     let r2 = f2.await;
    |                 ^^^^^ `F2` is not a future
    |
    = note: F2 must be a future or must implement `IntoFuture` to be awaited
    = note: required for `F2` to implement `IntoFuture`
help: remove the `.await`
    |
114 -     let r2 = f2.await;
114 +     let r2 = f2;
    |
help: consider further restricting type parameter `F2` with trait `Future`
    |
111 |     F2: Future + std::future::Future,
    |                +++++++++++++++++++++

    Checking toml v0.8.23
error[E0023]: this pattern has 1 field, but the corresponding tuple variant has 2 fields
  --> compiler/src/lexer/token.rs:66:35
   |
26 |     IntLiteral(String, Option<String>),   // value, optional suffix (i32, u64, etc.)
   |                ------  -------------- tuple variant has 2 fields
...
66 |             TokenKind::IntLiteral(_) | TokenKind::FloatLiteral(_) |
   |                                   ^ expected 2 fields, found 1
   |
help: use `_` to explicitly ignore each field
   |
66 |             TokenKind::IntLiteral(_, _) | TokenKind::FloatLiteral(_) |
   |                                    +++
help: use `..` to ignore all fields
   |
66 -             TokenKind::IntLiteral(_) | TokenKind::FloatLiteral(_) |
66 +             TokenKind::IntLiteral(..) | TokenKind::FloatLiteral(_) |
   |

error[E0023]: this pattern has 1 field, but the corresponding tuple variant has 2 fields
  --> compiler/src/lexer/token.rs:66:64
   |
27 |     FloatLiteral(String, Option<String>), // value, optional suffix (f32, f64)
   |                  ------  -------------- tuple variant has 2 fields
...
66 |             TokenKind::IntLiteral(_) | TokenKind::FloatLiteral(_) |
   |                                                                ^ expected 2 fields, found 1
   |
help: use `_` to explicitly ignore each field
   |
66 |             TokenKind::IntLiteral(_) | TokenKind::FloatLiteral(_, _) |
   |                                                                 +++
help: use `..` to ignore all fields
   |
66 -             TokenKind::IntLiteral(_) | TokenKind::FloatLiteral(_) |
66 +             TokenKind::IntLiteral(_) | TokenKind::FloatLiteral(..) |
   |

error[E0308]: mismatched types
   --> compiler/src/lexer/mod.rs:689:13
    |
682 |     fn lex_slash(&mut self) -> Result<TokenKind> {
    |                                ----------------- expected `std::result::Result<TokenKind, error::Error>` because of return type
...
689 |             self.next_token() // Skip comment and get next token
    |             ^^^^^^^^^^^^^^^^^ expected `Result<TokenKind, Error>`, found `Result<Token, Error>`
    |
    = note: expected enum `std::result::Result<TokenKind, _>`
               found enum `std::result::Result<Token, _>`

error[E0308]: mismatched types
   --> compiler/src/lexer/mod.rs:698:32
    |
682 |     fn lex_slash(&mut self) -> Result<TokenKind> {
    |                                ----------------- expected `std::result::Result<TokenKind, error::Error>` because of return type
...
698 |                         return self.next_token(); // Skip comment
    |                                ^^^^^^^^^^^^^^^^^ expected `Result<TokenKind, Error>`, found `Result<Token, Error>`
    |
    = note: expected enum `std::result::Result<TokenKind, _>`
               found enum `std::result::Result<Token, _>`

error[E0599]: no function or associated item named `default` found for struct `span::Span` in the current scope
  --> compiler/src/semantic/resolver.rs:66:19
   |
66 |             Span::default(),
   |                   ^^^^^^^ function or associated item not found in `span::Span`
   |
  ::: compiler/src/span.rs:31:1
   |
31 | pub struct Span {
   | --------------- function or associated item `default` not found for this struct
   |
note: if you're trying to build a new `span::Span`, consider using `span::Span::new` which returns `span::Span`
  --> compiler/src/span.rs:37:5
   |
37 |     pub fn new(start: Position, end: Position) -> Self {
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   = help: items from traits can only be used if the trait is implemented and in scope
   = note: the following trait defines an item `default`, perhaps you need to implement it:
           candidate #1: `Default`

error[E0599]: no variant or associated item named `DuplicateSymbol` found for enum `error::ErrorKind` in the current scope
  --> compiler/src/semantic/resolver.rs:71:50
   |
71 |             self.add_error(Error::new(ErrorKind::DuplicateSymbol, e));
   |                                                  ^^^^^^^^^^^^^^^ variant or associated item not found in `error::ErrorKind`
   |
  ::: compiler/src/error.rs:18:1
   |
18 | pub enum ErrorKind {
   | ------------------ variant or associated item `DuplicateSymbol` not found for this enum

error[E0599]: no function or associated item named `default` found for struct `span::Span` in the current scope
  --> compiler/src/semantic/resolver.rs:84:23
   |
84 |                 Span::default(),
   |                       ^^^^^^^ function or associated item not found in `span::Span`
   |
  ::: compiler/src/span.rs:31:1
   |
31 | pub struct Span {
   | --------------- function or associated item `default` not found for this struct
   |
note: if you're trying to build a new `span::Span`, consider using `span::Span::new` which returns `span::Span`
  --> compiler/src/span.rs:37:5
   |
37 |     pub fn new(start: Position, end: Position) -> Self {
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   = help: items from traits can only be used if the trait is implemented and in scope
   = note: the following trait defines an item `default`, perhaps you need to implement it:
           candidate #1: `Default`

error[E0599]: no variant or associated item named `DuplicateSymbol` found for enum `error::ErrorKind` in the current scope
  --> compiler/src/semantic/resolver.rs:89:54
   |
89 |                 self.add_error(Error::new(ErrorKind::DuplicateSymbol, e));
   |                                                      ^^^^^^^^^^^^^^^ variant or associated item not found in `error::ErrorKind`
   |
  ::: compiler/src/error.rs:18:1
   |
18 | pub enum ErrorKind {
   | ------------------ variant or associated item `DuplicateSymbol` not found for this enum

error[E0599]: no function or associated item named `default` found for struct `span::Span` in the current scope
  --> compiler/src/semantic/resolver.rs:99:23
   |
99 |                 Span::default(),
   |                       ^^^^^^^ function or associated item not found in `span::Span`
   |
  ::: compiler/src/span.rs:31:1
   |
31 | pub struct Span {
   | --------------- function or associated item `default` not found for this struct
   |
note: if you're trying to build a new `span::Span`, consider using `span::Span::new` which returns `span::Span`
  --> compiler/src/span.rs:37:5
   |
37 |     pub fn new(start: Position, end: Position) -> Self {
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   = help: items from traits can only be used if the trait is implemented and in scope
   = note: the following trait defines an item `default`, perhaps you need to implement it:
           candidate #1: `Default`

error[E0599]: no variant or associated item named `DuplicateSymbol` found for enum `error::ErrorKind` in the current scope
   --> compiler/src/semantic/resolver.rs:104:54
    |
104 |                 self.add_error(Error::new(ErrorKind::DuplicateSymbol, e));
    |                                                      ^^^^^^^^^^^^^^^ variant or associated item not found in `error::ErrorKind`
    |
   ::: compiler/src/error.rs:18:1
    |
 18 | pub enum ErrorKind {
    | ------------------ variant or associated item `DuplicateSymbol` not found for this enum

error[E0599]: no function or associated item named `default` found for struct `span::Span` in the current scope
   --> compiler/src/semantic/resolver.rs:122:19
    |
122 |             Span::default(),
    |                   ^^^^^^^ function or associated item not found in `span::Span`
    |
   ::: compiler/src/span.rs:31:1
    |
 31 | pub struct Span {
    | --------------- function or associated item `default` not found for this struct
    |
note: if you're trying to build a new `span::Span`, consider using `span::Span::new` which returns `span::Span`
   --> compiler/src/span.rs:37:5
    |
 37 |     pub fn new(start: Position, end: Position) -> Self {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    = help: items from traits can only be used if the trait is implemented and in scope
    = note: the following trait defines an item `default`, perhaps you need to implement it:
            candidate #1: `Default`

error[E0599]: no variant or associated item named `DuplicateSymbol` found for enum `error::ErrorKind` in the current scope
   --> compiler/src/semantic/resolver.rs:127:50
    |
127 |             self.add_error(Error::new(ErrorKind::DuplicateSymbol, e));
    |                                                  ^^^^^^^^^^^^^^^ variant or associated item not found in `error::ErrorKind`
    |
   ::: compiler/src/error.rs:18:1
    |
 18 | pub enum ErrorKind {
    | ------------------ variant or associated item `DuplicateSymbol` not found for this enum

error[E0599]: no function or associated item named `default` found for struct `span::Span` in the current scope
   --> compiler/src/semantic/resolver.rs:136:19
    |
136 |             Span::default(),
    |                   ^^^^^^^ function or associated item not found in `span::Span`
    |
   ::: compiler/src/span.rs:31:1
    |
 31 | pub struct Span {
    | --------------- function or associated item `default` not found for this struct
    |
note: if you're trying to build a new `span::Span`, consider using `span::Span::new` which returns `span::Span`
   --> compiler/src/span.rs:37:5
    |
 37 |     pub fn new(start: Position, end: Position) -> Self {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    = help: items from traits can only be used if the trait is implemented and in scope
    = note: the following trait defines an item `default`, perhaps you need to implement it:
            candidate #1: `Default`

error[E0599]: no variant or associated item named `DuplicateSymbol` found for enum `error::ErrorKind` in the current scope
   --> compiler/src/semantic/resolver.rs:141:50
    |
141 |             self.add_error(Error::new(ErrorKind::DuplicateSymbol, e));
    |                                                  ^^^^^^^^^^^^^^^ variant or associated item not found in `error::ErrorKind`
    |
   ::: compiler/src/error.rs:18:1
    |
 18 | pub enum ErrorKind {
    | ------------------ variant or associated item `DuplicateSymbol` not found for this enum

error[E0599]: no function or associated item named `default` found for struct `span::Span` in the current scope
   --> compiler/src/semantic/resolver.rs:151:23
    |
151 |                 Span::default(),
    |                       ^^^^^^^ function or associated item not found in `span::Span`
    |
   ::: compiler/src/span.rs:31:1
    |
 31 | pub struct Span {
    | --------------- function or associated item `default` not found for this struct
    |
note: if you're trying to build a new `span::Span`, consider using `span::Span::new` which returns `span::Span`
   --> compiler/src/span.rs:37:5
    |
 37 |     pub fn new(start: Position, end: Position) -> Self {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    = help: items from traits can only be used if the trait is implemented and in scope
    = note: the following trait defines an item `default`, perhaps you need to implement it:
            candidate #1: `Default`

error[E0599]: no variant or associated item named `DuplicateSymbol` found for enum `error::ErrorKind` in the current scope
   --> compiler/src/semantic/resolver.rs:156:54
    |
156 |                 self.add_error(Error::new(ErrorKind::DuplicateSymbol, e));
    |                                                      ^^^^^^^^^^^^^^^ variant or associated item not found in `error::ErrorKind`
    |
   ::: compiler/src/error.rs:18:1
    |
 18 | pub enum ErrorKind {
    | ------------------ variant or associated item `DuplicateSymbol` not found for this enum

error[E0599]: no function or associated item named `default` found for struct `span::Span` in the current scope
   --> compiler/src/semantic/resolver.rs:166:19
    |
166 |             Span::default(),
    |                   ^^^^^^^ function or associated item not found in `span::Span`
    |
   ::: compiler/src/span.rs:31:1
    |
 31 | pub struct Span {
    | --------------- function or associated item `default` not found for this struct
    |
note: if you're trying to build a new `span::Span`, consider using `span::Span::new` which returns `span::Span`
   --> compiler/src/span.rs:37:5
    |
 37 |     pub fn new(start: Position, end: Position) -> Self {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    = help: items from traits can only be used if the trait is implemented and in scope
    = note: the following trait defines an item `default`, perhaps you need to implement it:
            candidate #1: `Default`

error[E0599]: no variant or associated item named `DuplicateSymbol` found for enum `error::ErrorKind` in the current scope
   --> compiler/src/semantic/resolver.rs:171:50
    |
171 |             self.add_error(Error::new(ErrorKind::DuplicateSymbol, e));
    |                                                  ^^^^^^^^^^^^^^^ variant or associated item not found in `error::ErrorKind`
    |
   ::: compiler/src/error.rs:18:1
    |
 18 | pub enum ErrorKind {
    | ------------------ variant or associated item `DuplicateSymbol` not found for this enum

error[E0599]: no function or associated item named `default` found for struct `span::Span` in the current scope
   --> compiler/src/semantic/resolver.rs:185:23
    |
185 |                 Span::default(),
    |                       ^^^^^^^ function or associated item not found in `span::Span`
    |
   ::: compiler/src/span.rs:31:1
    |
 31 | pub struct Span {
    | --------------- function or associated item `default` not found for this struct
    |
note: if you're trying to build a new `span::Span`, consider using `span::Span::new` which returns `span::Span`
   --> compiler/src/span.rs:37:5
    |
 37 |     pub fn new(start: Position, end: Position) -> Self {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    = help: items from traits can only be used if the trait is implemented and in scope
    = note: the following trait defines an item `default`, perhaps you need to implement it:
            candidate #1: `Default`

error[E0599]: no variant or associated item named `DuplicateSymbol` found for enum `error::ErrorKind` in the current scope
   --> compiler/src/semantic/resolver.rs:190:54
    |
190 |                 self.add_error(Error::new(ErrorKind::DuplicateSymbol, e));
    |                                                      ^^^^^^^^^^^^^^^ variant or associated item not found in `error::ErrorKind`
    |
   ::: compiler/src/error.rs:18:1
    |
 18 | pub enum ErrorKind {
    | ------------------ variant or associated item `DuplicateSymbol` not found for this enum

error[E0599]: no function or associated item named `default` found for struct `span::Span` in the current scope
   --> compiler/src/semantic/resolver.rs:217:19
    |
217 |             Span::default(),
    |                   ^^^^^^^ function or associated item not found in `span::Span`
    |
   ::: compiler/src/span.rs:31:1
    |
 31 | pub struct Span {
    | --------------- function or associated item `default` not found for this struct
    |
note: if you're trying to build a new `span::Span`, consider using `span::Span::new` which returns `span::Span`
   --> compiler/src/span.rs:37:5
    |
 37 |     pub fn new(start: Position, end: Position) -> Self {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    = help: items from traits can only be used if the trait is implemented and in scope
    = note: the following trait defines an item `default`, perhaps you need to implement it:
            candidate #1: `Default`

error[E0599]: no variant or associated item named `DuplicateSymbol` found for enum `error::ErrorKind` in the current scope
   --> compiler/src/semantic/resolver.rs:222:50
    |
222 |             self.add_error(Error::new(ErrorKind::DuplicateSymbol, e));
    |                                                  ^^^^^^^^^^^^^^^ variant or associated item not found in `error::ErrorKind`
    |
   ::: compiler/src/error.rs:18:1
    |
 18 | pub enum ErrorKind {
    | ------------------ variant or associated item `DuplicateSymbol` not found for this enum

error[E0599]: no function or associated item named `default` found for struct `span::Span` in the current scope
   --> compiler/src/semantic/resolver.rs:250:27
    |
250 |                     Span::default(),
    |                           ^^^^^^^ function or associated item not found in `span::Span`
    |
   ::: compiler/src/span.rs:31:1
    |
 31 | pub struct Span {
    | --------------- function or associated item `default` not found for this struct
    |
note: if you're trying to build a new `span::Span`, consider using `span::Span::new` which returns `span::Span`
   --> compiler/src/span.rs:37:5
    |
 37 |     pub fn new(start: Position, end: Position) -> Self {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    = help: items from traits can only be used if the trait is implemented and in scope
    = note: the following trait defines an item `default`, perhaps you need to implement it:
            candidate #1: `Default`

error[E0599]: no variant or associated item named `DuplicateSymbol` found for enum `error::ErrorKind` in the current scope
   --> compiler/src/semantic/resolver.rs:259:58
    |
259 |                     self.add_error(Error::new(ErrorKind::DuplicateSymbol, e));
    |                                                          ^^^^^^^^^^^^^^^ variant or associated item not found in `error::ErrorKind`
    |
   ::: compiler/src/error.rs:18:1
    |
 18 | pub enum ErrorKind {
    | ------------------ variant or associated item `DuplicateSymbol` not found for this enum

error[E0599]: no function or associated item named `default` found for struct `span::Span` in the current scope
   --> compiler/src/semantic/resolver.rs:357:27
    |
357 |                     Span::default(),
    |                           ^^^^^^^ function or associated item not found in `span::Span`
    |
   ::: compiler/src/span.rs:31:1
    |
 31 | pub struct Span {
    | --------------- function or associated item `default` not found for this struct
    |
note: if you're trying to build a new `span::Span`, consider using `span::Span::new` which returns `span::Span`
   --> compiler/src/span.rs:37:5
    |
 37 |     pub fn new(start: Position, end: Position) -> Self {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    = help: items from traits can only be used if the trait is implemented and in scope
    = note: the following trait defines an item `default`, perhaps you need to implement it:
            candidate #1: `Default`

error[E0599]: no variant or associated item named `DuplicateSymbol` found for enum `error::ErrorKind` in the current scope
   --> compiler/src/semantic/resolver.rs:362:58
    |
362 |                     self.add_error(Error::new(ErrorKind::DuplicateSymbol, e));
    |                                                          ^^^^^^^^^^^^^^^ variant or associated item not found in `error::ErrorKind`
    |
   ::: compiler/src/error.rs:18:1
    |
 18 | pub enum ErrorKind {
    | ------------------ variant or associated item `DuplicateSymbol` not found for this enum

error[E0599]: no function or associated item named `default` found for struct `span::Span` in the current scope
   --> compiler/src/semantic/resolver.rs:407:27
    |
407 |                     Span::default(),
    |                           ^^^^^^^ function or associated item not found in `span::Span`
    |
   ::: compiler/src/span.rs:31:1
    |
 31 | pub struct Span {
    | --------------- function or associated item `default` not found for this struct
    |
note: if you're trying to build a new `span::Span`, consider using `span::Span::new` which returns `span::Span`
   --> compiler/src/span.rs:37:5
    |
 37 |     pub fn new(start: Position, end: Position) -> Self {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    = help: items from traits can only be used if the trait is implemented and in scope
    = note: the following trait defines an item `default`, perhaps you need to implement it:
            candidate #1: `Default`

error[E0599]: no variant or associated item named `DuplicateSymbol` found for enum `error::ErrorKind` in the current scope
   --> compiler/src/semantic/resolver.rs:412:58
    |
412 |                     self.add_error(Error::new(ErrorKind::DuplicateSymbol, e));
    |                                                          ^^^^^^^^^^^^^^^ variant or associated item not found in `error::ErrorKind`
    |
   ::: compiler/src/error.rs:18:1
    |
 18 | pub enum ErrorKind {
    | ------------------ variant or associated item `DuplicateSymbol` not found for this enum

error[E0599]: no variant or associated item named `TypeError` found for enum `error::ErrorKind` in the current scope
   --> compiler/src/semantic/type_env.rs:239:36
    |
239 |                         ErrorKind::TypeError,
    |                                    ^^^^^^^^^ variant or associated item not found in `error::ErrorKind`
    |
   ::: compiler/src/error.rs:18:1
    |
 18 | pub enum ErrorKind {
    | ------------------ variant or associated item `TypeError` not found for this enum
    |
help: there is a variant with a similar name
    |
239 -                         ErrorKind::TypeError,
240 -                         "Occurs check failed: infinite type"
241 -                     ))
239 +                         ErrorKind::MoveError)
    |

error[E0599]: no variant or associated item named `TypeError` found for enum `error::ErrorKind` in the current scope
   --> compiler/src/semantic/type_env.rs:253:36
    |
253 |                         ErrorKind::TypeError,
    |                                    ^^^^^^^^^ variant or associated item not found in `error::ErrorKind`
    |
   ::: compiler/src/error.rs:18:1
    |
 18 | pub enum ErrorKind {
    | ------------------ variant or associated item `TypeError` not found for this enum
    |
help: there is a variant with a similar name
    |
253 -                         ErrorKind::TypeError,
254 -                         format!("Function arity mismatch: {} vs {}", params1.len(), params2.len())
255 -                     ));
253 +                         ErrorKind::MoveError);
    |

error[E0599]: no variant or associated item named `TypeError` found for enum `error::ErrorKind` in the current scope
   --> compiler/src/semantic/type_env.rs:275:36
    |
275 |                         ErrorKind::TypeError,
    |                                    ^^^^^^^^^ variant or associated item not found in `error::ErrorKind`
    |
   ::: compiler/src/error.rs:18:1
    |
 18 | pub enum ErrorKind {
    | ------------------ variant or associated item `TypeError` not found for this enum
    |
help: there is a variant with a similar name
    |
275 -                         ErrorKind::TypeError,
276 -                         format!("Type mismatch: {} vs {}", name1, name2)
277 -                     ));
275 +                         ErrorKind::MoveError);
    |

error[E0599]: no variant or associated item named `TypeError` found for enum `error::ErrorKind` in the current scope
   --> compiler/src/semantic/type_env.rs:282:36
    |
282 |                         ErrorKind::TypeError,
    |                                    ^^^^^^^^^ variant or associated item not found in `error::ErrorKind`
    |
   ::: compiler/src/error.rs:18:1
    |
 18 | pub enum ErrorKind {
    | ------------------ variant or associated item `TypeError` not found for this enum
    |
help: there is a variant with a similar name
    |
282 -                         ErrorKind::TypeError,
283 -                         "Generic argument count mismatch"
284 -                     ));
282 +                         ErrorKind::MoveError);
    |

error[E0599]: no variant or associated item named `TypeError` found for enum `error::ErrorKind` in the current scope
   --> compiler/src/semantic/type_env.rs:300:36
    |
300 |                         ErrorKind::TypeError,
    |                                    ^^^^^^^^^ variant or associated item not found in `error::ErrorKind`
    |
   ::: compiler/src/error.rs:18:1
    |
 18 | pub enum ErrorKind {
    | ------------------ variant or associated item `TypeError` not found for this enum
    |
help: there is a variant with a similar name
    |
300 -                         ErrorKind::TypeError,
301 -                         "Tuple size mismatch"
302 -                     ));
300 +                         ErrorKind::MoveError);
    |

error[E0599]: no variant or associated item named `TypeError` found for enum `error::ErrorKind` in the current scope
   --> compiler/src/semantic/type_env.rs:318:36
    |
318 |                         ErrorKind::TypeError,
    |                                    ^^^^^^^^^ variant or associated item not found in `error::ErrorKind`
    |
   ::: compiler/src/error.rs:18:1
    |
 18 | pub enum ErrorKind {
    | ------------------ variant or associated item `TypeError` not found for this enum
    |
help: there is a variant with a similar name
    |
318 -                         ErrorKind::TypeError,
319 -                         "Array size mismatch"
320 -                     ));
318 +                         ErrorKind::MoveError);
    |

error[E0599]: no variant or associated item named `TypeError` found for enum `error::ErrorKind` in the current scope
   --> compiler/src/semantic/type_env.rs:341:36
    |
341 |                         ErrorKind::TypeError,
    |                                    ^^^^^^^^^ variant or associated item not found in `error::ErrorKind`
    |
   ::: compiler/src/error.rs:18:1
    |
 18 | pub enum ErrorKind {
    | ------------------ variant or associated item `TypeError` not found for this enum
    |
help: there is a variant with a similar name
    |
341 -                         ErrorKind::TypeError,
342 -                         format!("Type mismatch: {} vs {}", n1, n2)
343 -                     ))
341 +                         ErrorKind::MoveError)
    |

error[E0599]: no variant or associated item named `TypeError` found for enum `error::ErrorKind` in the current scope
   --> compiler/src/semantic/type_env.rs:349:28
    |
349 |                 ErrorKind::TypeError,
    |                            ^^^^^^^^^ variant or associated item not found in `error::ErrorKind`
    |
   ::: compiler/src/error.rs:18:1
    |
 18 | pub enum ErrorKind {
    | ------------------ variant or associated item `TypeError` not found for this enum
    |
help: there is a variant with a similar name
    |
349 -                 ErrorKind::TypeError,
350 -                 format!("Cannot unify types: {:?} and {:?}", t1, t2)
351 -             ))
349 +                 ErrorKind::MoveError)
    |

error[E0599]: no variant or associated item named `TypeError` found for enum `error::ErrorKind` in the current scope
   --> compiler/src/semantic/type_checker.rs:144:36
    |
144 |                         ErrorKind::TypeError,
    |                                    ^^^^^^^^^ variant or associated item not found in `error::ErrorKind`
    |
   ::: compiler/src/error.rs:18:1
    |
 18 | pub enum ErrorKind {
    | ------------------ variant or associated item `TypeError` not found for this enum
    |
help: there is a variant with a similar name
    |
144 -                         ErrorKind::TypeError,
145 -                         "Let binding must have type annotation or initializer"
146 -                     ));
144 +                         ErrorKind::MoveError);
    |

warning: unreachable expression
  --> compiler/src/codegen/llvm_backend.rs:46:9
   |
33 |         return "x86_64-unknown-linux-gnu".to_string();
   |         --------------------------------------------- any code following this expression is unreachable
...
46 |         "unknown-unknown-unknown".to_string()
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ unreachable expression
   |
   = note: `#[warn(unreachable_code)]` (part of `#[warn(unused)]`) on by default

error[E0599]: no variant or associated item named `I1` found for enum `IrType` in the current scope
  --> compiler/src/codegen/llvm_backend.rs:60:21
   |
60 |             IrType::I1 => "i1".to_string(),
   |                     ^^ variant or associated item not found in `IrType`
   |
  ::: compiler/src/ir/types.rs:7:1
   |
 7 | pub enum IrType {
   | --------------- variant or associated item `I1` not found for this enum
   |
help: there is a variant with a similar name
   |
60 -             IrType::I1 => "i1".to_string(),
60 +             IrType::I8 => "i1".to_string(),
   |

error[E0599]: no variant or associated item named `Ptr` found for enum `IrType` in the current scope
  --> compiler/src/codegen/llvm_backend.rs:73:21
   |
73 |             IrType::Ptr(inner) => format!("{}*", self.type_to_llvm(inner)),
   |                     ^^^ variant or associated item not found in `IrType`
   |
  ::: compiler/src/ir/types.rs:7:1
   |
 7 | pub enum IrType {
   | --------------- variant or associated item `Ptr` not found for this enum

error[E0026]: variant `Instruction::Branch` does not have fields named `true_bb`, `false_bb`
   --> compiler/src/codegen/llvm_backend.rs:290:41
    |
290 |             Instruction::Branch { cond, true_bb, false_bb } => {
    |                                         ^^^^^^^  ^^^^^^^^ variant `Instruction::Branch` does not have these fields

error[E0027]: pattern does not mention fields `then_block`, `else_block`
   --> compiler/src/codegen/llvm_backend.rs:290:13
    |
290 |             Instruction::Branch { cond, true_bb, false_bb } => {
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ missing fields `then_block`, `else_block`
    |
help: include the missing fields in the pattern
    |
290 |             Instruction::Branch { cond, true_bb, false_bb, then_block, else_block } => {
    |                                                          ++++++++++++++++++++++++
help: if you don't care about these missing fields, you can explicitly ignore them
    |
290 |             Instruction::Branch { cond, true_bb, false_bb, then_block: _, else_block: _ } => {
    |                                                          ++++++++++++++++++++++++++++++
help: or always ignore missing fields here
    |
290 |             Instruction::Branch { cond, true_bb, false_bb, .. } => {
    |                                                          ++++

error[E0609]: no field `0` on type `&usize`
   --> compiler/src/codegen/llvm_backend.rs:295:53
    |
295 |                 Ok(format!("br label %bb{}", target.0))
    |                                                     ^ unknown field

error[E0609]: no field `0` on type `&usize`
   --> compiler/src/codegen/llvm_backend.rs:305:63
    |
305 |                         format!("[ {}, %bb{} ]", val_name, bb.0)
    |                                                               ^ unknown field

error[E0599]: no variant or associated item named `I1` found for enum `IrType` in the current scope
   --> compiler/src/codegen/llvm_backend.rs:337:59
    |
337 |             Value::Constant(Constant::Bool(_)) => IrType::I1,
    |                                                           ^^ variant or associated item not found in `IrType`
    |
   ::: compiler/src/ir/types.rs:7:1
    |
  7 | pub enum IrType {
    | --------------- variant or associated item `I1` not found for this enum
    |
help: there is a variant with a similar name
    |
337 -             Value::Constant(Constant::Bool(_)) => IrType::I1,
337 +             Value::Constant(Constant::Bool(_)) => IrType::I8,
    |

error[E0599]: no variant named `MacroCall` found for enum `ast::Expr`
  --> compiler/src/macro_system/expander.rs:25:19
   |
25 |             Expr::MacroCall { name, args, span } => {
   |                   ^^^^^^^^^ variant not found in `ast::Expr`
   |
  ::: compiler/src/parser/ast.rs:94:1
   |
94 | pub enum Expr {
   | ------------- variant `MacroCall` not found here

error[E0769]: tuple variant `Expr::Binary` written as struct variant
  --> compiler/src/macro_system/expander.rs:28:13
   |
28 |             Expr::Binary { op, left, right, span } => {
   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
help: use the tuple variant pattern syntax instead
   |
28 -             Expr::Binary { op, left, right, span } => {
28 +             Expr::Binary(_, _, _) => {
   |

error[E0769]: tuple variant `Expr::Call` written as struct variant
  --> compiler/src/macro_system/expander.rs:38:13
   |
38 |             Expr::Call { func, args, span } => {
   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
help: use the tuple variant pattern syntax instead
   |
38 -             Expr::Call { func, args, span } => {
38 +             Expr::Call(_, _) => {
   |

error[E0769]: tuple variant `Expr::Block` written as struct variant
  --> compiler/src/macro_system/expander.rs:49:13
   |
49 |             Expr::Block { stmts, span } => {
   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
help: use the tuple variant pattern syntax instead
   |
49 -             Expr::Block { stmts, span } => {
49 +             Expr::Block(_) => {
   |

error[E0559]: variant `ast::Expr::Binary` has no field named `op`
  --> compiler/src/macro_system/expander.rs:32:21
   |
32 |                     op: *op,
   |                     ^^ field does not exist
   |
  ::: compiler/src/parser/ast.rs:97:5
   |
97 |     Binary(Box<Expr>, BinOp, Box<Expr>),
   |     ------ `ast::Expr::Binary` defined here
   |
help: `ast::Expr::Binary` is a tuple variant, use the appropriate syntax
   |
31 -                 Ok(Expr::Binary {
32 -                     op: *op,
33 -                     left,
34 -                     right,
35 -                     span: *span,
36 -                 })
31 +                 Ok(Expr::Binary(/* Box<ast::Expr> */, /* ast::BinOp */, /* Box<ast::Expr> */))
   |

error[E0559]: variant `ast::Expr::Binary` has no field named `left`
  --> compiler/src/macro_system/expander.rs:33:21
   |
33 |                     left,
   |                     ^^^^ field does not exist
   |
  ::: compiler/src/parser/ast.rs:97:5
   |
97 |     Binary(Box<Expr>, BinOp, Box<Expr>),
   |     ------ `ast::Expr::Binary` defined here
   |
help: `ast::Expr::Binary` is a tuple variant, use the appropriate syntax
   |
31 -                 Ok(Expr::Binary {
32 -                     op: *op,
33 -                     left,
34 -                     right,
35 -                     span: *span,
36 -                 })
31 +                 Ok(Expr::Binary(/* Box<ast::Expr> */, /* ast::BinOp */, /* Box<ast::Expr> */))
   |

error[E0559]: variant `ast::Expr::Binary` has no field named `right`
  --> compiler/src/macro_system/expander.rs:34:21
   |
34 |                     right,
   |                     ^^^^^ field does not exist
   |
  ::: compiler/src/parser/ast.rs:97:5
   |
97 |     Binary(Box<Expr>, BinOp, Box<Expr>),
   |     ------ `ast::Expr::Binary` defined here
   |
help: `ast::Expr::Binary` is a tuple variant, use the appropriate syntax
   |
31 -                 Ok(Expr::Binary {
32 -                     op: *op,
33 -                     left,
34 -                     right,
35 -                     span: *span,
36 -                 })
31 +                 Ok(Expr::Binary(/* Box<ast::Expr> */, /* ast::BinOp */, /* Box<ast::Expr> */))
   |

error[E0559]: variant `ast::Expr::Binary` has no field named `span`
  --> compiler/src/macro_system/expander.rs:35:21
   |
35 |                     span: *span,
   |                     ^^^^ field does not exist
   |
  ::: compiler/src/parser/ast.rs:97:5
   |
97 |     Binary(Box<Expr>, BinOp, Box<Expr>),
   |     ------ `ast::Expr::Binary` defined here
   |
help: `ast::Expr::Binary` is a tuple variant, use the appropriate syntax
   |
31 -                 Ok(Expr::Binary {
32 -                     op: *op,
33 -                     left,
34 -                     right,
35 -                     span: *span,
36 -                 })
31 +                 Ok(Expr::Binary(/* Box<ast::Expr> */, /* ast::BinOp */, /* Box<ast::Expr> */))
   |

error[E0559]: variant `ast::Expr::Call` has no field named `func`
  --> compiler/src/macro_system/expander.rs:44:21
   |
44 |                     func,
   |                     ^^^^ field does not exist
   |
  ::: compiler/src/parser/ast.rs:99:5
   |
99 |     Call(Box<Expr>, Vec<Expr>),
   |     ---- `ast::Expr::Call` defined here
   |
help: `ast::Expr::Call` is a tuple variant, use the appropriate syntax
   |
43 -                 Ok(Expr::Call {
44 -                     func,
45 -                     args,
46 -                     span: *span,
47 -                 })
43 +                 Ok(Expr::Call(/* Box<ast::Expr> */, /* Vec<ast::Expr> */))
   |

error[E0559]: variant `ast::Expr::Call` has no field named `args`
  --> compiler/src/macro_system/expander.rs:45:21
   |
45 |                     args,
   |                     ^^^^ field does not exist
   |
  ::: compiler/src/parser/ast.rs:99:5
   |
99 |     Call(Box<Expr>, Vec<Expr>),
   |     ---- `ast::Expr::Call` defined here
   |
help: `ast::Expr::Call` is a tuple variant, use the appropriate syntax
   |
43 -                 Ok(Expr::Call {
44 -                     func,
45 -                     args,
46 -                     span: *span,
47 -                 })
43 +                 Ok(Expr::Call(/* Box<ast::Expr> */, /* Vec<ast::Expr> */))
   |

error[E0559]: variant `ast::Expr::Call` has no field named `span`
  --> compiler/src/macro_system/expander.rs:46:21
   |
46 |                     span: *span,
   |                     ^^^^ field does not exist
   |
  ::: compiler/src/parser/ast.rs:99:5
   |
99 |     Call(Box<Expr>, Vec<Expr>),
   |     ---- `ast::Expr::Call` defined here
   |
help: `ast::Expr::Call` is a tuple variant, use the appropriate syntax
   |
43 -                 Ok(Expr::Call {
44 -                     func,
45 -                     args,
46 -                     span: *span,
47 -                 })
43 +                 Ok(Expr::Call(/* Box<ast::Expr> */, /* Vec<ast::Expr> */))
   |

error[E0559]: variant `ast::Expr::Block` has no field named `stmts`
   --> compiler/src/macro_system/expander.rs:54:21
    |
 54 |                     stmts,
    |                     ^^^^^ field does not exist
    |
   ::: compiler/src/parser/ast.rs:103:5
    |
103 |     Block(Vec<Stmt>),
    |     ----- `ast::Expr::Block` defined here
    |
help: `ast::Expr::Block` is a tuple variant, use the appropriate syntax
    |
 53 -                 Ok(Expr::Block {
 54 -                     stmts,
 55 -                     span: *span,
 56 -                 })
 53 +                 Ok(Expr::Block(/* Vec<ast::Stmt> */))
    |

error[E0559]: variant `ast::Expr::Block` has no field named `span`
   --> compiler/src/macro_system/expander.rs:55:21
    |
 55 |                     span: *span,
    |                     ^^^^ field does not exist
    |
   ::: compiler/src/parser/ast.rs:103:5
    |
103 |     Block(Vec<Stmt>),
    |     ----- `ast::Expr::Block` defined here
    |
help: `ast::Expr::Block` is a tuple variant, use the appropriate syntax
    |
 53 -                 Ok(Expr::Block {
 54 -                     stmts,
 55 -                     span: *span,
 56 -                 })
 53 +                 Ok(Expr::Block(/* Vec<ast::Stmt> */))
    |

error[E0769]: tuple variant `Stmt::Let` written as struct variant
  --> compiler/src/macro_system/expander.rs:67:13
   |
67 |             Stmt::Let { pattern, ty, init, span } => {
   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
help: use the tuple variant pattern syntax instead
   |
67 -             Stmt::Let { pattern, ty, init, span } => {
67 +             Stmt::Let(_, _, _) => {
   |

error[E0559]: variant `ast::Stmt::Let` has no field named `pattern`
  --> compiler/src/macro_system/expander.rs:73:21
   |
73 |                     pattern: pattern.clone(),
   |                     ^^^^^^^ field does not exist
   |
  ::: compiler/src/parser/ast.rs:87:5
   |
87 |     Let(String, Option<Type>, Option<Expr>),
   |     --- `ast::Stmt::Let` defined here
   |
help: `ast::Stmt::Let` is a tuple variant, use the appropriate syntax
   |
72 -                 Ok(Stmt::Let {
73 -                     pattern: pattern.clone(),
74 -                     ty: ty.clone(),
75 -                     init,
76 -                     span: *span,
77 -                 })
72 +                 Ok(Stmt::Let(/* String */, /* Option<ast::Type> */, /* Option<ast::Expr> */))
   |

error[E0559]: variant `ast::Stmt::Let` has no field named `ty`
  --> compiler/src/macro_system/expander.rs:74:21
   |
74 |                     ty: ty.clone(),
   |                     ^^ field does not exist
   |
  ::: compiler/src/parser/ast.rs:87:5
   |
87 |     Let(String, Option<Type>, Option<Expr>),
   |     --- `ast::Stmt::Let` defined here
   |
help: `ast::Stmt::Let` is a tuple variant, use the appropriate syntax
   |
72 -                 Ok(Stmt::Let {
73 -                     pattern: pattern.clone(),
74 -                     ty: ty.clone(),
75 -                     init,
76 -                     span: *span,
77 -                 })
72 +                 Ok(Stmt::Let(/* String */, /* Option<ast::Type> */, /* Option<ast::Expr> */))
   |

error[E0559]: variant `ast::Stmt::Let` has no field named `init`
  --> compiler/src/macro_system/expander.rs:75:21
   |
75 |                     init,
   |                     ^^^^ field does not exist
   |
  ::: compiler/src/parser/ast.rs:87:5
   |
87 |     Let(String, Option<Type>, Option<Expr>),
   |     --- `ast::Stmt::Let` defined here
   |
help: `ast::Stmt::Let` is a tuple variant, use the appropriate syntax
   |
72 -                 Ok(Stmt::Let {
73 -                     pattern: pattern.clone(),
74 -                     ty: ty.clone(),
75 -                     init,
76 -                     span: *span,
77 -                 })
72 +                 Ok(Stmt::Let(/* String */, /* Option<ast::Type> */, /* Option<ast::Expr> */))
   |

error[E0559]: variant `ast::Stmt::Let` has no field named `span`
  --> compiler/src/macro_system/expander.rs:76:21
   |
76 |                     span: *span,
   |                     ^^^^ field does not exist
   |
  ::: compiler/src/parser/ast.rs:87:5
   |
87 |     Let(String, Option<Type>, Option<Expr>),
   |     --- `ast::Stmt::Let` defined here
   |
help: `ast::Stmt::Let` is a tuple variant, use the appropriate syntax
   |
72 -                 Ok(Stmt::Let {
73 -                     pattern: pattern.clone(),
74 -                     ty: ty.clone(),
75 -                     init,
76 -                     span: *span,
77 -                 })
72 +                 Ok(Stmt::Let(/* String */, /* Option<ast::Type> */, /* Option<ast::Expr> */))
   |

error[E0308]: mismatched types
  --> compiler/src/macro_system/expander.rs:86:17
   |
86 |                 format!("macro expansion depth exceeded (max: {})", self.max_depth),
   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `String`
   |
   = note: this error originates in the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0277]: the trait bound `String: From<span::Span>` is not satisfied
  --> compiler/src/macro_system/expander.rs:87:17
   |
85 |             return Err(Error::new(
   |                        ---------- required by a bound introduced by this call
86 |                 format!("macro expansion depth exceeded (max: {})", self.max_depth),
87 |                 span,
   |                 ^^^^ the trait `From<span::Span>` is not implemented for `String`
   |
   = help: the following other types implement trait `From<T>`:
             `String` implements `From<&String>`
             `String` implements `From<&mut str>`
             `String` implements `From<&str>`
             `String` implements `From<Box<str>>`
             `String` implements `From<Cow<'_, str>>`
             `String` implements `From<char>`
             `String` implements `From<clap::Id>`
             `String` implements `From<clap::builder::Str>`
   = note: required for `span::Span` to implement `Into<String>`
note: required by a bound in `error::Error::new`
  --> compiler/src/error.rs:47:47
   |
47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
   |                                               ^^^^^^^^^^^^ required by this bound in `Error::new`

error[E0308]: mismatched types
  --> compiler/src/macro_system/expander.rs:92:39
   |
92 |             .ok_or_else(|| Error::new(format!("undefined macro: {}", name), span))?;
   |                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `String`
   |
   = note: this error originates in the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0277]: the trait bound `String: From<span::Span>` is not satisfied
  --> compiler/src/macro_system/expander.rs:92:77
   |
92 |             .ok_or_else(|| Error::new(format!("undefined macro: {}", name), span))?;
   |                            ----------                                       ^^^^ the trait `From<span::Span>` is not implemented for `String`
   |                            |
   |                            required by a bound introduced by this call
   |
   = help: the following other types implement trait `From<T>`:
             `String` implements `From<&String>`
             `String` implements `From<&mut str>`
             `String` implements `From<&str>`
             `String` implements `From<Box<str>>`
             `String` implements `From<Cow<'_, str>>`
             `String` implements `From<char>`
             `String` implements `From<clap::Id>`
             `String` implements `From<clap::builder::Str>`
   = note: required for `span::Span` to implement `Into<String>`
note: required by a bound in `error::Error::new`
  --> compiler/src/error.rs:47:47
   |
47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
   |                                               ^^^^^^^^^^^^ required by this bound in `Error::new`

error[E0308]: mismatched types
   --> compiler/src/macro_system/expander.rs:110:21
    |
110 |                     format!("no matching macro rule for {}", def.name),
    |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `String`
    |
    = note: this error originates in the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0277]: the trait bound `String: From<span::Span>` is not satisfied
   --> compiler/src/macro_system/expander.rs:111:21
    |
109 |                 Err(Error::new(
    |                     ---------- required by a bound introduced by this call
110 |                     format!("no matching macro rule for {}", def.name),
111 |                     span,
    |                     ^^^^ the trait `From<span::Span>` is not implemented for `String`
    |
    = help: the following other types implement trait `From<T>`:
              `String` implements `From<&String>`
              `String` implements `From<&mut str>`
              `String` implements `From<&str>`
              `String` implements `From<Box<str>>`
              `String` implements `From<Cow<'_, str>>`
              `String` implements `From<char>`
              `String` implements `From<clap::Id>`
              `String` implements `From<clap::builder::Str>`
    = note: required for `span::Span` to implement `Into<String>`
note: required by a bound in `error::Error::new`
   --> compiler/src/error.rs:47:47
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |                                               ^^^^^^^^^^^^ required by this bound in `Error::new`

error[E0277]: the trait bound `String: From<span::Span>` is not satisfied
   --> compiler/src/macro_system/expander.rs:116:73
    |
116 |                 Err(Error::new("procedural macros not yet implemented", span))
    |                     ----------                                          ^^^^ the trait `From<span::Span>` is not implemented for `String`
    |                     |
    |                     required by a bound introduced by this call
    |
    = help: the following other types implement trait `From<T>`:
              `String` implements `From<&String>`
              `String` implements `From<&mut str>`
              `String` implements `From<&str>`
              `String` implements `From<Box<str>>`
              `String` implements `From<Cow<'_, str>>`
              `String` implements `From<char>`
              `String` implements `From<clap::Id>`
              `String` implements `From<clap::builder::Str>`
    = note: required for `span::Span` to implement `Into<String>`
note: required by a bound in `error::Error::new`
   --> compiler/src/error.rs:47:47
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |                                               ^^^^^^^^^^^^ required by this bound in `Error::new`

error[E0308]: mismatched types
   --> compiler/src/macro_system/expander.rs:116:32
    |
116 |                 Err(Error::new("procedural macros not yet implemented", span))
    |                     ---------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `&str`
    |                     |
    |                     arguments to this function are incorrect
    |
note: associated function defined here
   --> compiler/src/error.rs:47:12
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |            ^^^ ---------------

error[E0559]: variant `ast::Expr::Block` has no field named `stmts`
   --> compiler/src/macro_system/expander.rs:224:13
    |
224 |             stmts: vec![],
    |             ^^^^^ field does not exist
    |
   ::: compiler/src/parser/ast.rs:103:5
    |
103 |     Block(Vec<Stmt>),
    |     ----- `ast::Expr::Block` defined here
    |
help: `ast::Expr::Block` is a tuple variant, use the appropriate syntax
    |
223 -         Ok(Expr::Block {
224 -             stmts: vec![],
225 -             span,
226 -         })
223 +         Ok(Expr::Block(/* Vec<ast::Stmt> */))
    |

error[E0559]: variant `ast::Expr::Block` has no field named `span`
   --> compiler/src/macro_system/expander.rs:225:13
    |
225 |             span,
    |             ^^^^ field does not exist
    |
   ::: compiler/src/parser/ast.rs:103:5
    |
103 |     Block(Vec<Stmt>),
    |     ----- `ast::Expr::Block` defined here
    |
help: `ast::Expr::Block` is a tuple variant, use the appropriate syntax
    |
223 -         Ok(Expr::Block {
224 -             stmts: vec![],
225 -             span,
226 -         })
223 +         Ok(Expr::Block(/* Vec<ast::Stmt> */))
    |

error[E0599]: no function or associated item named `dummy` found for struct `span::Span` in the current scope
   --> compiler/src/macro_system/mod.rs:132:29
    |
132 |                 span: Span::dummy(),
    |                             ^^^^^ function or associated item not found in `span::Span`
    |
   ::: compiler/src/span.rs:31:1
    |
 31 | pub struct Span {
    | --------------- function or associated item `dummy` not found for this struct
    |
note: if you're trying to build a new `span::Span`, consider using `span::Span::new` which returns `span::Span`
   --> compiler/src/span.rs:37:5
    |
 37 |     pub fn new(start: Position, end: Position) -> Self {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0599]: no function or associated item named `dummy` found for struct `span::Span` in the current scope
   --> compiler/src/macro_system/mod.rs:187:29
    |
187 |                 span: Span::dummy(),
    |                             ^^^^^ function or associated item not found in `span::Span`
    |
   ::: compiler/src/span.rs:31:1
    |
 31 | pub struct Span {
    | --------------- function or associated item `dummy` not found for this struct
    |
note: if you're trying to build a new `span::Span`, consider using `span::Span::new` which returns `span::Span`
   --> compiler/src/span.rs:37:5
    |
 37 |     pub fn new(start: Position, end: Position) -> Self {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0599]: no function or associated item named `dummy` found for struct `span::Span` in the current scope
   --> compiler/src/macro_system/mod.rs:209:29
    |
209 |                 span: Span::dummy(),
    |                             ^^^^^ function or associated item not found in `span::Span`
    |
   ::: compiler/src/span.rs:31:1
    |
 31 | pub struct Span {
    | --------------- function or associated item `dummy` not found for this struct
    |
note: if you're trying to build a new `span::Span`, consider using `span::Span::new` which returns `span::Span`
   --> compiler/src/span.rs:37:5
    |
 37 |     pub fn new(start: Position, end: Position) -> Self {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0282]: type annotations needed
   --> compiler/src/async_runtime/executor.rs:132:25
    |
132 |                         task.poll(&waker);
    |                         ^^^^ cannot infer type

    Checking vpm v1.0.0 (/run/media/zarigata/42A0B8BDA0B8B8AD/ARTIFICIAL-INTELIGENCE/ArtificialProgramingLanguage/tools/vpm)
error[E0599]: no function or associated item named `from_millis` found for struct `async_runtime::Duration` in the current scope
   --> compiler/src/async_runtime/executor.rs:135:49
    |
135 |                         Thread::sleep(Duration::from_millis(10));
    |                                                 ^^^^^^^^^^^ function or associated item not found in `async_runtime::Duration`
    |
   ::: compiler/src/async_runtime/mod.rs:142:1
    |
142 | pub struct Duration {
    | ------------------- function or associated item `from_millis` not found for this struct

error[E0026]: variant `ast::Expr::Literal` does not have a field named `value`
   --> compiler/src/verification/smt_solver.rs:109:29
    |
109 |             Expr::Literal { value, .. } => {
    |                             ^^^^^
    |                             |
    |                             variant `ast::Expr::Literal` does not have this field
    |                             help: `ast::Expr::Literal` has a field named `0`

error[E0599]: no variant named `Variable` found for enum `ast::Expr`
   --> compiler/src/verification/smt_solver.rs:116:19
    |
116 |             Expr::Variable { name, .. } => Ok(name.clone()),
    |                   ^^^^^^^^ variant not found in `ast::Expr`
    |
   ::: compiler/src/parser/ast.rs:94:1
    |
 94 | pub enum Expr {
    | ------------- variant `Variable` not found here

error[E0026]: variant `ast::Expr::Binary` does not have fields named `op`, `left`, `right`
   --> compiler/src/verification/smt_solver.rs:117:28
    |
117 |             Expr::Binary { op, left, right, .. } => {
    |                            ^^  ^^^^  ^^^^^ variant `ast::Expr::Binary` does not have these fields

error[E0026]: variant `ast::Expr::Unary` does not have fields named `op`, `operand`
   --> compiler/src/verification/smt_solver.rs:139:27
    |
139 |             Expr::Unary { op, operand, .. } => {
    |                           ^^  ^^^^^^^ variant `ast::Expr::Unary` does not have these fields

error[E0308]: mismatched types
   --> compiler/src/verification/smt_solver.rs:113:41
    |
113 |                     _ => Err(Error::new("Unsupported literal type for SMT", Span::dummy())),
    |                              ---------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `&str`
    |                              |
    |                              arguments to this function are incorrect
    |
note: associated function defined here
   --> compiler/src/error.rs:47:12
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |            ^^^ ---------------

error[E0308]: mismatched types
   --> compiler/src/verification/smt_solver.rs:134:48
    |
134 |                     _ => return Err(Error::new("Unsupported binary operator for SMT", Span::dummy())),
    |                                     ---------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `&str`
    |                                     |
    |                                     arguments to this function are incorrect
    |
note: associated function defined here
   --> compiler/src/error.rs:47:12
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |            ^^^ ---------------

error[E0308]: mismatched types
   --> compiler/src/verification/smt_solver.rs:145:48
    |
145 |                     _ => return Err(Error::new("Unsupported unary operator for SMT", Span::dummy())),
    |                                     ---------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `&str`
    |                                     |
    |                                     arguments to this function are incorrect
    |
note: associated function defined here
   --> compiler/src/error.rs:47:12
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |            ^^^ ---------------

error[E0308]: mismatched types
   --> compiler/src/verification/smt_solver.rs:150:33
    |
150 |             _ => Err(Error::new("Unsupported expression type for SMT", Span::dummy())),
    |                      ---------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `&str`
    |                      |
    |                      arguments to this function are incorrect
    |
note: associated function defined here
   --> compiler/src/error.rs:47:12
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |            ^^^ ---------------

error[E0599]: no variant named `Variable` found for enum `ast::Expr`
   --> compiler/src/verification/smt_solver.rs:164:19
    |
164 |             Expr::Variable { name, .. } => {
    |                   ^^^^^^^^ variant not found in `ast::Expr`
    |
   ::: compiler/src/parser/ast.rs:94:1
    |
 94 | pub enum Expr {
    | ------------- variant `Variable` not found here

error[E0026]: variant `ast::Expr::Binary` does not have fields named `left`, `right`
   --> compiler/src/verification/smt_solver.rs:167:28
    |
167 |             Expr::Binary { left, right, .. } => {
    |                            ^^^^  ^^^^^ variant `ast::Expr::Binary` does not have these fields

error[E0026]: variant `ast::Expr::Unary` does not have a field named `operand`
   --> compiler/src/verification/smt_solver.rs:171:27
    |
171 |             Expr::Unary { operand, .. } => {
    |                           ^^^^^^^ variant `ast::Expr::Unary` does not have this field

error[E0308]: mismatched types
   --> compiler/src/verification/smt_solver.rs:195:37
    |
195 |             .map_err(|e| Error::new(format!("Failed to spawn SMT solver: {}", e), Span::dummy()))?;
    |                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `String`
    |
    = note: this error originates in the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0308]: mismatched types
   --> compiler/src/verification/smt_solver.rs:199:41
    |
199 |                 .map_err(|e| Error::new(format!("Failed to write to SMT solver: {}", e), Span::dummy()))?;
    |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `String`
    |
    = note: this error originates in the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0308]: mismatched types
   --> compiler/src/verification/smt_solver.rs:203:37
    |
203 |             .map_err(|e| Error::new(format!("Failed to read SMT solver output: {}", e), Span::dummy()))?;
    |                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `String`
    |
    = note: this error originates in the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0599]: no method named `prove_postcondition` found for mutable reference `&mut FormalVerifier` in the current scope
   --> compiler/src/verification/mod.rs:115:30
    |
115 |             let proof = self.prove_postcondition(func, post)?;
    |                              ^^^^^^^^^^^^^^^^^^^
    |
help: there is a method `verify_postcondition` with a similar name
    |
115 -             let proof = self.prove_postcondition(func, post)?;
115 +             let proof = self.verify_postcondition(func, post)?;
    |

error[E0599]: no method named `check_memory_safety` found for mutable reference `&mut FormalVerifier` in the current scope
   --> compiler/src/verification/mod.rs:120:34
    |
120 |         let memory_safety = self.check_memory_safety(func)?;
    |                                  ^^^^^^^^^^^^^^^^^^^
    |
help: there is a method `check_null_safety` with a similar name
    |
120 -         let memory_safety = self.check_memory_safety(func)?;
120 +         let memory_safety = self.check_null_safety(func)?;
    |

error[E0255]: the name `Command` is defined multiple times
   --> tools/vpm/src/main.rs:225:1
    |
  7 | use std::process::Command;
    |     --------------------- previous import of the type `Command` here
...
225 | pub enum Command {
    | ^^^^^^^^^^^^^^^^ `Command` redefined here
    |
    = note: `Command` must be defined only once in the type namespace of this module
help: you can use `as` to change the binding name of the import
    |
  7 | use std::process::Command as OtherCommand;
    |                           +++++++++++++++

error[E0599]: no method named `prove_invariant_init` found for mutable reference `&mut FormalVerifier` in the current scope
   --> compiler/src/verification/mod.rs:136:31
    |
136 |         let init_proof = self.prove_invariant_init(&invariant)?;
    |                               ^^^^^^^^^^^^^^^^^^^^
    |
help: there is a method `verify_invariant_init` with a similar name
    |
136 -         let init_proof = self.prove_invariant_init(&invariant)?;
136 +         let init_proof = self.verify_invariant_init(&invariant)?;
    |

warning: unused import: `std::process::Command`
 --> tools/vpm/src/main.rs:7:5
  |
7 | use std::process::Command;
  |     ^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` (part of `#[warn(unused)]`) on by default

error[E0599]: no method named `prove_invariant_maintained` found for mutable reference `&mut FormalVerifier` in the current scope
   --> compiler/src/verification/mod.rs:142:35
    |
142 |         let maintain_proof = self.prove_invariant_maintained(&invariant, loop_stmt)?;
    |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^ method not found in `&mut FormalVerifier`

error[E0609]: no field `attributes` on type `&ast::Function`
   --> compiler/src/verification/mod.rs:204:27
    |
204 |         for attr in &func.attributes {
    |                           ^^^^^^^^^^ unknown field
    |
    = note: available fields are: `name`, `generics`, `params`, `return_type`, `where_clause`, `body`

error[E0282]: type annotations needed
   --> compiler/src/verification/mod.rs:207:40
    |
207 |                     preconditions.push(expr.clone());
    |                                        ^^^^ cannot infer type

error[E0609]: no field `attributes` on type `&ast::Function`
   --> compiler/src/verification/mod.rs:219:27
    |
219 |         for attr in &func.attributes {
    |                           ^^^^^^^^^^ unknown field
    |
    = note: available fields are: `name`, `generics`, `params`, `return_type`, `where_clause`, `body`

error[E0282]: type annotations needed
   --> compiler/src/verification/mod.rs:222:41
    |
222 |                     postconditions.push(expr.clone());
    |                                         ^^^^ cannot infer type

error[E0026]: variant `ast::Stmt::Let` does not have fields named `pattern`, `init`
   --> compiler/src/gpu/mod.rs:243:25
    |
243 |             Stmt::Let { pattern, init, .. } => {
    |                         ^^^^^^^  ^^^^ variant `ast::Stmt::Let` does not have these fields

error[E0026]: variant `ast::Expr::Literal` does not have a field named `value`
   --> compiler/src/gpu/mod.rs:259:29
    |
259 |             Expr::Literal { value, .. } => {
    |                             ^^^^^
    |                             |
    |                             variant `ast::Expr::Literal` does not have this field
    |                             help: `ast::Expr::Literal` has a field named `0`

error[E0599]: no variant named `Variable` found for enum `ast::Expr`
   --> compiler/src/gpu/mod.rs:267:19
    |
267 |             Expr::Variable { name, .. } => Ok(name.clone()),
    |                   ^^^^^^^^ variant not found in `ast::Expr`
    |
   ::: compiler/src/parser/ast.rs:94:1
    |
 94 | pub enum Expr {
    | ------------- variant `Variable` not found here

error[E0026]: variant `ast::Expr::Binary` does not have fields named `op`, `left`, `right`
   --> compiler/src/gpu/mod.rs:268:28
    |
268 |             Expr::Binary { op, left, right, .. } => {
    |                            ^^  ^^^^  ^^^^^ variant `ast::Expr::Binary` does not have these fields

error[E0599]: no variant or associated item named `I32` found for enum `ast::Type` in the current scope
   --> compiler/src/gpu/mod.rs:304:19
    |
304 |             Type::I32 => Ok("int".to_string()),
    |                   ^^^ variant or associated item not found in `ast::Type`
    |
   ::: compiler/src/parser/ast.rs:73:1
    |
 73 | pub enum Type {
    | ------------- variant or associated item `I32` not found for this enum

error[E0599]: no variant or associated item named `I64` found for enum `ast::Type` in the current scope
   --> compiler/src/gpu/mod.rs:305:19
    |
305 |             Type::I64 => Ok("long".to_string()),
    |                   ^^^ variant or associated item not found in `ast::Type`
    |
   ::: compiler/src/parser/ast.rs:73:1
    |
 73 | pub enum Type {
    | ------------- variant or associated item `I64` not found for this enum

error[E0599]: no variant or associated item named `F32` found for enum `ast::Type` in the current scope
   --> compiler/src/gpu/mod.rs:306:19
    |
306 |             Type::F32 => Ok("float".to_string()),
    |                   ^^^ variant or associated item not found in `ast::Type`
    |
   ::: compiler/src/parser/ast.rs:73:1
    |
 73 | pub enum Type {
    | ------------- variant or associated item `F32` not found for this enum

error[E0599]: no variant or associated item named `F64` found for enum `ast::Type` in the current scope
   --> compiler/src/gpu/mod.rs:307:19
    |
307 |             Type::F64 => Ok("double".to_string()),
    |                   ^^^ variant or associated item not found in `ast::Type`
    |
   ::: compiler/src/parser/ast.rs:73:1
    |
 73 | pub enum Type {
    | ------------- variant or associated item `F64` not found for this enum

error[E0599]: no variant or associated item named `Pointer` found for enum `ast::Type` in the current scope
   --> compiler/src/gpu/mod.rs:308:19
    |
308 |             Type::Pointer(inner) => Ok(format!("{}*", self.cuda_type(inner)?)),
    |                   ^^^^^^^ variant or associated item not found in `ast::Type`
    |
   ::: compiler/src/parser/ast.rs:73:1
    |
 73 | pub enum Type {
    | ------------- variant or associated item `Pointer` not found for this enum

error[E0599]: no variant or associated item named `I32` found for enum `ast::Type` in the current scope
   --> compiler/src/gpu/mod.rs:315:19
    |
315 |             Type::I32 => Ok("device int*".to_string()),
    |                   ^^^ variant or associated item not found in `ast::Type`
    |
   ::: compiler/src/parser/ast.rs:73:1
    |
 73 | pub enum Type {
    | ------------- variant or associated item `I32` not found for this enum

error[E0599]: no variant or associated item named `I64` found for enum `ast::Type` in the current scope
   --> compiler/src/gpu/mod.rs:316:19
    |
316 |             Type::I64 => Ok("device long*".to_string()),
    |                   ^^^ variant or associated item not found in `ast::Type`
    |
   ::: compiler/src/parser/ast.rs:73:1
    |
 73 | pub enum Type {
    | ------------- variant or associated item `I64` not found for this enum

error[E0599]: no variant or associated item named `F32` found for enum `ast::Type` in the current scope
   --> compiler/src/gpu/mod.rs:317:19
    |
317 |             Type::F32 => Ok("device float*".to_string()),
    |                   ^^^ variant or associated item not found in `ast::Type`
    |
   ::: compiler/src/parser/ast.rs:73:1
    |
 73 | pub enum Type {
    | ------------- variant or associated item `F32` not found for this enum

error[E0599]: no variant or associated item named `F64` found for enum `ast::Type` in the current scope
   --> compiler/src/gpu/mod.rs:318:19
    |
318 |             Type::F64 => Ok("device double*".to_string()),
    |                   ^^^ variant or associated item not found in `ast::Type`
    |
   ::: compiler/src/parser/ast.rs:73:1
    |
 73 | pub enum Type {
    | ------------- variant or associated item `F64` not found for this enum

error[E0599]: no variant or associated item named `I32` found for enum `ast::Type` in the current scope
   --> compiler/src/gpu/mod.rs:325:19
    |
325 |             Type::I32 => Ok("int".to_string()),
    |                   ^^^ variant or associated item not found in `ast::Type`
    |
   ::: compiler/src/parser/ast.rs:73:1
    |
 73 | pub enum Type {
    | ------------- variant or associated item `I32` not found for this enum

error[E0599]: no variant or associated item named `I64` found for enum `ast::Type` in the current scope
   --> compiler/src/gpu/mod.rs:326:19
    |
326 |             Type::I64 => Ok("int64_t".to_string()),
    |                   ^^^ variant or associated item not found in `ast::Type`
    |
   ::: compiler/src/parser/ast.rs:73:1
    |
 73 | pub enum Type {
    | ------------- variant or associated item `I64` not found for this enum

error[E0599]: no variant or associated item named `F32` found for enum `ast::Type` in the current scope
   --> compiler/src/gpu/mod.rs:327:19
    |
327 |             Type::F32 => Ok("float".to_string()),
    |                   ^^^ variant or associated item not found in `ast::Type`
    |
   ::: compiler/src/parser/ast.rs:73:1
    |
 73 | pub enum Type {
    | ------------- variant or associated item `F32` not found for this enum

error[E0599]: no variant or associated item named `F64` found for enum `ast::Type` in the current scope
   --> compiler/src/gpu/mod.rs:328:19
    |
328 |             Type::F64 => Ok("double".to_string()),
    |                   ^^^ variant or associated item not found in `ast::Type`
    |
   ::: compiler/src/parser/ast.rs:73:1
    |
 73 | pub enum Type {
    | ------------- variant or associated item `F64` not found for this enum

error[E0599]: no variant or associated item named `I32` found for enum `ast::Type` in the current scope
   --> compiler/src/gpu/mod.rs:335:19
    |
335 |             Type::I32 => Ok("int*".to_string()),
    |                   ^^^ variant or associated item not found in `ast::Type`
    |
   ::: compiler/src/parser/ast.rs:73:1
    |
 73 | pub enum Type {
    | ------------- variant or associated item `I32` not found for this enum

error[E0599]: no variant or associated item named `I64` found for enum `ast::Type` in the current scope
   --> compiler/src/gpu/mod.rs:336:19
    |
336 |             Type::I64 => Ok("long*".to_string()),
    |                   ^^^ variant or associated item not found in `ast::Type`
    |
   ::: compiler/src/parser/ast.rs:73:1
    |
 73 | pub enum Type {
    | ------------- variant or associated item `I64` not found for this enum

error[E0599]: no variant or associated item named `F32` found for enum `ast::Type` in the current scope
   --> compiler/src/gpu/mod.rs:337:19
    |
337 |             Type::F32 => Ok("float*".to_string()),
    |                   ^^^ variant or associated item not found in `ast::Type`
    |
   ::: compiler/src/parser/ast.rs:73:1
    |
 73 | pub enum Type {
    | ------------- variant or associated item `F32` not found for this enum

error[E0599]: no variant or associated item named `F64` found for enum `ast::Type` in the current scope
   --> compiler/src/gpu/mod.rs:338:19
    |
338 |             Type::F64 => Ok("double*".to_string()),
    |                   ^^^ variant or associated item not found in `ast::Type`
    |
   ::: compiler/src/parser/ast.rs:73:1
    |
 73 | pub enum Type {
    | ------------- variant or associated item `F64` not found for this enum

error[E0026]: variant `ast::Expr::Literal` does not have a field named `value`
  --> compiler/src/consteval/mod.rs:61:29
   |
61 |             Expr::Literal { value, .. } => self.eval_literal(value),
   |                             ^^^^^
   |                             |
   |                             variant `ast::Expr::Literal` does not have this field
   |                             help: `ast::Expr::Literal` has a field named `0`

error[E0599]: no variant named `Variable` found for enum `ast::Expr`
  --> compiler/src/consteval/mod.rs:63:19
   |
63 |             Expr::Variable { name, .. } => {
   |                   ^^^^^^^^ variant not found in `ast::Expr`
   |
  ::: compiler/src/parser/ast.rs:94:1
   |
94 | pub enum Expr {
   | ------------- variant `Variable` not found here

error[E0026]: variant `ast::Expr::Binary` does not have fields named `op`, `left`, `right`
  --> compiler/src/consteval/mod.rs:72:28
   |
72 |             Expr::Binary { op, left, right, .. } => {
   |                            ^^  ^^^^  ^^^^^ variant `ast::Expr::Binary` does not have these fields

error[E0026]: variant `ast::Expr::Unary` does not have fields named `op`, `operand`
  --> compiler/src/consteval/mod.rs:78:27
   |
78 |             Expr::Unary { op, operand, .. } => {
   |                           ^^  ^^^^^^^ variant `ast::Expr::Unary` does not have these fields

error[E0026]: variant `ast::Expr::Call` does not have fields named `func`, `args`
  --> compiler/src/consteval/mod.rs:83:26
   |
83 |             Expr::Call { func, args, .. } => {
   |                          ^^^^  ^^^^ variant `ast::Expr::Call` does not have these fields

error[E0026]: variant `ast::Expr::If` does not have fields named `condition`, `then_branch`, `else_branch`
  --> compiler/src/consteval/mod.rs:87:24
   |
87 |             Expr::If { condition, then_branch, else_branch, .. } => {
   |                        ^^^^^^^^^  ^^^^^^^^^^^  ^^^^^^^^^^^ variant `ast::Expr::If` does not have these fields

error[E0026]: variant `ast::Expr::Array` does not have a field named `elements`
  --> compiler/src/consteval/mod.rs:98:27
   |
98 |             Expr::Array { elements, .. } => {
   |                           ^^^^^^^^
   |                           |
   |                           variant `ast::Expr::Array` does not have this field
   |                           help: `ast::Expr::Array` has a field named `0`

error[E0308]: mismatched types
  --> compiler/src/consteval/mod.rs:67:25
   |
67 |                         format!("Undefined constant: {}", name),
   |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `String`
   |
   = note: this error originates in the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0308]: mismatched types
   --> compiler/src/consteval/mod.rs:107:17
    |
106 |             _ => Err(Error::new(
    |                      ---------- arguments to this function are incorrect
107 |                 "Expression cannot be evaluated at compile time",
    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `&str`
    |
note: associated function defined here
   --> compiler/src/error.rs:47:12
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |            ^^^ ---------------

error[E0308]: mismatched types
   --> compiler/src/consteval/mod.rs:132:51
    |
132 | ...                   return Err(Error::new("Division by zero", Span::dummy()));
    |                                  ---------- ^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `&str`
    |                                  |
    |                                  arguments to this function are incorrect
    |
note: associated function defined here
   --> compiler/src/error.rs:47:12
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |            ^^^ ---------------

error[E0599]: no variant or associated item named `new` found for enum `Command` in the current scope
   --> tools/vpm/src/main.rs:170:32
    |
170 |         let mut cmd = Command::new("vezc");
    |                                ^^^ variant or associated item not found in `Command`
...
225 | pub enum Command {
    | ---------------- variant or associated item `new` not found for this enum
    |
help: there is a variant with a similar name
    |
170 -         let mut cmd = Command::new("vezc");
170 +         let mut cmd = Command::New { name: /* value */ };
    |

error[E0282]: type annotations needed
   --> tools/vpm/src/main.rs:178:44
    |
178 |         let status = cmd.status().map_err(|e| e.to_string())?;
    |                                            ^  - type must be known at this point
    |
help: consider giving this closure parameter an explicit type
    |
178 |         let status = cmd.status().map_err(|e: /* Type */| e.to_string())?;
    |                                             ++++++++++++

error[E0308]: mismatched types
   --> compiler/src/consteval/mod.rs:148:48
    |
148 |                     _ => return Err(Error::new("Unsupported binary operation", Span::dummy())),
    |                                     ---------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `&str`
    |                                     |
    |                                     arguments to this function are incorrect
    |
note: associated function defined here
   --> compiler/src/error.rs:47:12
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |            ^^^ ---------------

error[E0308]: mismatched types
   --> compiler/src/consteval/mod.rs:165:48
    |
165 |                     _ => return Err(Error::new("Unsupported binary operation", Span::dummy())),
    |                                     ---------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `&str`
    |                                     |
    |                                     arguments to this function are incorrect
    |
note: associated function defined here
   --> compiler/src/error.rs:47:12
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |            ^^^ ---------------

error[E0308]: mismatched types
   --> compiler/src/consteval/mod.rs:176:48
    |
176 |                     _ => return Err(Error::new("Unsupported binary operation", Span::dummy())),
    |                                     ---------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `&str`
    |                                     |
    |                                     arguments to this function are incorrect
    |
note: associated function defined here
   --> compiler/src/error.rs:47:12
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |            ^^^ ---------------

error[E0308]: mismatched types
   --> compiler/src/consteval/mod.rs:181:33
    |
181 |             _ => Err(Error::new("Type mismatch in binary operation", Span::dummy())),
    |                      ---------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `&str`
    |                      |
    |                      arguments to this function are incorrect
    |
note: associated function defined here
   --> compiler/src/error.rs:47:12
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |            ^^^ ---------------

error[E0308]: mismatched types
   --> compiler/src/consteval/mod.rs:192:48
    |
192 |                     _ => return Err(Error::new("Unsupported unary operation", Span::dummy())),
    |                                     ---------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `&str`
    |                                     |
    |                                     arguments to this function are incorrect
    |
note: associated function defined here
   --> compiler/src/error.rs:47:12
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |            ^^^ ---------------

error[E0308]: mismatched types
   --> compiler/src/consteval/mod.rs:200:48
    |
200 |                     _ => return Err(Error::new("Unsupported unary operation", Span::dummy())),
    |                                     ---------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `&str`
    |                                     |
    |                                     arguments to this function are incorrect
    |
note: associated function defined here
   --> compiler/src/error.rs:47:12
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |            ^^^ ---------------

error[E0308]: mismatched types
   --> compiler/src/consteval/mod.rs:208:48
    |
208 |                     _ => return Err(Error::new("Unsupported unary operation", Span::dummy())),
    |                                     ---------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `&str`
    |                                     |
    |                                     arguments to this function are incorrect
    |
note: associated function defined here
   --> compiler/src/error.rs:47:12
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |            ^^^ ---------------

error[E0599]: no variant or associated item named `new` found for enum `Command` in the current scope
   --> tools/vpm/src/main.rs:253:36
    |
225 | pub enum Command {
    | ---------------- variant or associated item `new` not found for this enum
...
253 |             let mut cmd = Command::new(&binary);
    |                                    ^^^ variant or associated item not found in `Command`
    |
help: there is a variant with a similar name
    |
253 -             let mut cmd = Command::new(&binary);
253 +             let mut cmd = Command::New { name: /* value */ };
    |

error[E0308]: mismatched types
   --> compiler/src/consteval/mod.rs:213:33
    |
213 |             _ => Err(Error::new("Type mismatch in unary operation", Span::dummy())),
    |                      ---------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `&str`
    |                      |
    |                      arguments to this function are incorrect
    |
note: associated function defined here
   --> compiler/src/error.rs:47:12
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |            ^^^ ---------------

error[E0282]: type annotations needed
   --> tools/vpm/src/main.rs:255:35
    |
255 |             cmd.status().map_err(|e| e.to_string())?;
    |                                   ^  - type must be known at this point
    |
help: consider giving this closure parameter an explicit type
    |
255 |             cmd.status().map_err(|e: /* Type */| e.to_string())?;
    |                                    ++++++++++++

error[E0599]: no variant named `Variable` found for enum `ast::Expr`
   --> compiler/src/consteval/mod.rs:220:19
    |
220 |             Expr::Variable { name, .. } => name,
    |                   ^^^^^^^^ variant not found in `ast::Expr`
    |
   ::: compiler/src/parser/ast.rs:94:1
    |
 94 | pub enum Expr {
    | ------------- variant `Variable` not found here

error[E0308]: mismatched types
   --> compiler/src/consteval/mod.rs:221:40
    |
221 |             _ => return Err(Error::new("Invalid function call", Span::dummy())),
    |                             ---------- ^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `&str`
    |                             |
    |                             arguments to this function are incorrect
    |
note: associated function defined here
   --> compiler/src/error.rs:47:12
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |            ^^^ ---------------

error[E0308]: mismatched types
   --> compiler/src/consteval/mod.rs:238:17
    |
238 |                 format!("Unknown compile-time function: {}", func_name),
    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `String`
    |
    = note: this error originates in the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0308]: mismatched types
   --> compiler/src/consteval/mod.rs:246:35
    |
246 |             return Err(Error::new("abs expects 1 argument", Span::dummy()));
    |                        ---------- ^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `&str`
    |                        |
    |                        arguments to this function are incorrect
    |
note: associated function defined here
   --> compiler/src/error.rs:47:12
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |            ^^^ ---------------

error[E0308]: mismatched types
   --> compiler/src/consteval/mod.rs:252:33
    |
252 |             _ => Err(Error::new("abs expects numeric argument", Span::dummy())),
    |                      ---------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `&str`
    |                      |
    |                      arguments to this function are incorrect
    |
note: associated function defined here
   --> compiler/src/error.rs:47:12
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |            ^^^ ---------------

error[E0308]: mismatched types
   --> compiler/src/consteval/mod.rs:258:35
    |
258 |             return Err(Error::new("min expects 2 arguments", Span::dummy()));
    |                        ---------- ^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `&str`
    |                        |
    |                        arguments to this function are incorrect
    |
note: associated function defined here
   --> compiler/src/error.rs:47:12
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |            ^^^ ---------------

error[E0308]: mismatched types
   --> compiler/src/consteval/mod.rs:264:33
    |
264 |             _ => Err(Error::new("min expects numeric arguments", Span::dummy())),
    |                      ---------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `&str`
    |                      |
    |                      arguments to this function are incorrect
    |
note: associated function defined here
   --> compiler/src/error.rs:47:12
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |            ^^^ ---------------

error[E0308]: mismatched types
   --> compiler/src/consteval/mod.rs:270:35
    |
270 |             return Err(Error::new("max expects 2 arguments", Span::dummy()));
    |                        ---------- ^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `&str`
    |                        |
    |                        arguments to this function are incorrect
    |
note: associated function defined here
   --> compiler/src/error.rs:47:12
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |            ^^^ ---------------

error[E0308]: mismatched types
   --> compiler/src/consteval/mod.rs:276:33
    |
276 |             _ => Err(Error::new("max expects numeric arguments", Span::dummy())),
    |                      ---------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `&str`
    |                      |
    |                      arguments to this function are incorrect
    |
note: associated function defined here
   --> compiler/src/error.rs:47:12
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |            ^^^ ---------------

error[E0308]: mismatched types
   --> compiler/src/consteval/mod.rs:282:35
    |
282 |             return Err(Error::new("pow expects 2 arguments", Span::dummy()));
    |                        ---------- ^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `&str`
    |                        |
    |                        arguments to this function are incorrect
    |
note: associated function defined here
   --> compiler/src/error.rs:47:12
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |            ^^^ ---------------

error[E0308]: mismatched types
   --> compiler/src/consteval/mod.rs:291:43
    |
291 |                     return Err(Error::new("Negative exponent for integer pow", Span::dummy()));
    |                                ---------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `&str`
    |                                |
    |                                arguments to this function are incorrect
    |
note: associated function defined here
   --> compiler/src/error.rs:47:12
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |            ^^^ ---------------

error[E0308]: mismatched types
   --> compiler/src/consteval/mod.rs:295:33
    |
295 |             _ => Err(Error::new("pow expects numeric arguments", Span::dummy())),
    |                      ---------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `&str`
    |                      |
    |                      arguments to this function are incorrect
    |
note: associated function defined here
   --> compiler/src/error.rs:47:12
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |            ^^^ ---------------

error[E0308]: mismatched types
   --> compiler/src/consteval/mod.rs:301:35
    |
301 |             return Err(Error::new("sqrt expects 1 argument", Span::dummy()));
    |                        ---------- ^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `&str`
    |                        |
    |                        arguments to this function are incorrect
    |
note: associated function defined here
   --> compiler/src/error.rs:47:12
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |            ^^^ ---------------

error[E0308]: mismatched types
   --> compiler/src/consteval/mod.rs:307:43
    |
307 |                     return Err(Error::new("sqrt of negative number", Span::dummy()));
    |                                ---------- ^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `&str`
    |                                |
    |                                arguments to this function are incorrect
    |
note: associated function defined here
   --> compiler/src/error.rs:47:12
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |            ^^^ ---------------

error[E0308]: mismatched types
   --> compiler/src/consteval/mod.rs:311:33
    |
311 |             _ => Err(Error::new("sqrt expects float argument", Span::dummy())),
    |                      ---------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `&str`
    |                      |
    |                      arguments to this function are incorrect
    |
note: associated function defined here
   --> compiler/src/error.rs:47:12
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |            ^^^ ---------------

warning: unused variable: `archive`
  --> tools/vpm/src/main.rs:99:31
   |
99 |     fn extract_package(&self, archive: &Path, dest: &Path) -> Result<(), String> {
   |                               ^^^^^^^ help: if this is intentional, prefix it with an underscore: `_archive`
   |
   = note: `#[warn(unused_variables)]` (part of `#[warn(unused)]`) on by default

warning: unused variable: `path`
   --> tools/vpm/src/main.rs:108:33
    |
108 |     fn load_package_info(&self, path: &Path) -> Result<PackageInfo, String> {
    |                                 ^^^^ help: if this is intentional, prefix it with an underscore: `_path`

warning: unused variable: `dep`
   --> tools/vpm/src/main.rs:162:20
    |
162 |         for (name, dep) in &self.manifest.dependencies {
    |                    ^^^ help: if this is intentional, prefix it with an underscore: `_dep`

warning: unused variable: `content`
   --> tools/vpm/src/main.rs:320:19
    |
320 | fn parse_manifest(content: &str) -> Result<Manifest, String> {
    |                   ^^^^^^^ help: if this is intentional, prefix it with an underscore: `_content`

Some errors have detailed explanations: E0255, E0282, E0599.
For more information about an error, try `rustc --explain E0255`.
warning: `vpm` (bin "vpm") generated 5 warnings
error: could not compile `vpm` (bin "vpm") due to 5 previous errors; 5 warnings emitted
warning: build failed, waiting for other jobs to finish...
warning: unused variable: `func`
   --> compiler/src/verification/mod.rs:194:41
    |
194 |     fn check_overflow_safety(&mut self, func: &Function) -> Result<bool> {
    |                                         ^^^^ help: if this is intentional, prefix it with an underscore: `_func`
    |
    = note: `#[warn(unused_variables)]` (part of `#[warn(unused)]`) on by default

error[E0594]: cannot assign to `proof.status`, as `proof` is not declared as mutable
   --> compiler/src/verification/mod.rs:247:13
    |
247 |             proof.status = ProofStatus::Proven;
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ cannot assign
    |
help: consider changing this to be mutable
    |
237 |         let mut proof = Proof {
    |             +++

error[E0594]: cannot assign to `proof.status`, as `proof` is not declared as mutable
   --> compiler/src/verification/mod.rs:249:13
    |
249 |             proof.status = ProofStatus::Failed;
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ cannot assign
    |
help: consider changing this to be mutable
    |
237 |         let mut proof = Proof {
    |             +++

warning: variable does not need to be mutable
   --> compiler/src/verification/mod.rs:268:13
    |
268 |         let mut proof = Proof {
    |             ----^^^^^
    |             |
    |             help: remove this `mut`
    |
    = note: `#[warn(unused_mut)]` (part of `#[warn(unused)]`) on by default

Some errors have detailed explanations: E0023, E0026, E0027, E0277, E0282, E0308, E0412, E0432, E0433...
For more information about an error, try `rustc --explain E0023`.
warning: `vez_compiler` (lib) generated 14 warnings
error: could not compile `vez_compiler` (lib) due to 288 previous errors; 14 warnings emitted
[0;32mâœ“[0m Cargo check passed
[1;33mâ†’[0m Checking for compilation warnings...
[1;33mâš [0m 30 compilation warnings found
[1;33mâ†’[0m Running cargo clippy (if available)...
[1;33mâš [0m Clippy not installed, skipping

==========================================
8. Documentation Tests
==========================================
[1;33mâ†’[0m Testing documentation build...
warning: profiles for the non root package will be ignored, specify profiles at the workspace root:
package:   /run/media/zarigata/42A0B8BDA0B8B8AD/ARTIFICIAL-INTELIGENCE/ArtificialProgramingLanguage/compiler/Cargo.toml
workspace: /run/media/zarigata/42A0B8BDA0B8B8AD/ARTIFICIAL-INTELIGENCE/ArtificialProgramingLanguage/Cargo.toml
 Documenting vez_compiler v0.1.0 (/run/media/zarigata/42A0B8BDA0B8B8AD/ARTIFICIAL-INTELIGENCE/ArtificialProgramingLanguage/compiler)
    Checking vez_compiler v0.1.0 (/run/media/zarigata/42A0B8BDA0B8B8AD/ARTIFICIAL-INTELIGENCE/ArtificialProgramingLanguage/compiler)
error[E0583]: file not found for module `hygiene`
 --> compiler/src/macro_system/mod.rs:5:1
  |
5 | pub mod hygiene;
  | ^^^^^^^^^^^^^^^^
  |
  = help: to create the module `hygiene`, create file "compiler/src/macro_system/hygiene.rs" or "compiler/src/macro_system/hygiene/mod.rs"
  = note: if there is a `mod hygiene` elsewhere in the crate already, import it with `use crate::...` instead

error[E0583]: file not found for module `parser`
 --> compiler/src/macro_system/mod.rs:6:1
  |
6 | pub mod parser;
  | ^^^^^^^^^^^^^^^
  |
  = help: to create the module `parser`, create file "compiler/src/macro_system/parser.rs" or "compiler/src/macro_system/parser/mod.rs"
  = note: if there is a `mod parser` elsewhere in the crate already, import it with `use crate::...` instead

error[E0583]: file not found for module `builtin`
 --> compiler/src/macro_system/mod.rs:7:1
  |
7 | pub mod builtin;
  | ^^^^^^^^^^^^^^^^
  |
  = help: to create the module `builtin`, create file "compiler/src/macro_system/builtin.rs" or "compiler/src/macro_system/builtin/mod.rs"
  = note: if there is a `mod builtin` elsewhere in the crate already, import it with `use crate::...` instead

error[E0583]: file not found for module `future`
 --> compiler/src/async_runtime/mod.rs:4:1
  |
4 | pub mod future;
  | ^^^^^^^^^^^^^^^
  |
  = help: to create the module `future`, create file "compiler/src/async_runtime/future.rs" or "compiler/src/async_runtime/future/mod.rs"
  = note: if there is a `mod future` elsewhere in the crate already, import it with `use crate::...` instead

error[E0583]: file not found for module `task`
 --> compiler/src/async_runtime/mod.rs:6:1
  |
6 | pub mod task;
  | ^^^^^^^^^^^^^
  |
  = help: to create the module `task`, create file "compiler/src/async_runtime/task.rs" or "compiler/src/async_runtime/task/mod.rs"
  = note: if there is a `mod task` elsewhere in the crate already, import it with `use crate::...` instead

error[E0583]: file not found for module `waker`
 --> compiler/src/async_runtime/mod.rs:7:1
  |
7 | pub mod waker;
  | ^^^^^^^^^^^^^^
  |
  = help: to create the module `waker`, create file "compiler/src/async_runtime/waker.rs" or "compiler/src/async_runtime/waker/mod.rs"
  = note: if there is a `mod waker` elsewhere in the crate already, import it with `use crate::...` instead

error[E0583]: file not found for module `proof_engine`
 --> compiler/src/verification/mod.rs:5:1
  |
5 | pub mod proof_engine;
  | ^^^^^^^^^^^^^^^^^^^^^
  |
  = help: to create the module `proof_engine`, create file "compiler/src/verification/proof_engine.rs" or "compiler/src/verification/proof_engine/mod.rs"
  = note: if there is a `mod proof_engine` elsewhere in the crate already, import it with `use crate::...` instead

error[E0583]: file not found for module `safety_checker`
 --> compiler/src/verification/mod.rs:6:1
  |
6 | pub mod safety_checker;
  | ^^^^^^^^^^^^^^^^^^^^^^^
  |
  = help: to create the module `safety_checker`, create file "compiler/src/verification/safety_checker.rs" or "compiler/src/verification/safety_checker/mod.rs"
  = note: if there is a `mod safety_checker` elsewhere in the crate already, import it with `use crate::...` instead

error[E0583]: file not found for module `contracts`
 --> compiler/src/verification/mod.rs:7:1
  |
7 | pub mod contracts;
  | ^^^^^^^^^^^^^^^^^^
  |
  = help: to create the module `contracts`, create file "compiler/src/verification/contracts.rs" or "compiler/src/verification/contracts/mod.rs"
  = note: if there is a `mod contracts` elsewhere in the crate already, import it with `use crate::...` instead

error[E0583]: file not found for module `cuda`
 --> compiler/src/gpu/mod.rs:4:1
  |
4 | pub mod cuda;
  | ^^^^^^^^^^^^^
  |
  = help: to create the module `cuda`, create file "compiler/src/gpu/cuda.rs" or "compiler/src/gpu/cuda/mod.rs"
  = note: if there is a `mod cuda` elsewhere in the crate already, import it with `use crate::...` instead

error[E0583]: file not found for module `metal`
 --> compiler/src/gpu/mod.rs:5:1
  |
5 | pub mod metal;
  | ^^^^^^^^^^^^^^
  |
  = help: to create the module `metal`, create file "compiler/src/gpu/metal.rs" or "compiler/src/gpu/metal/mod.rs"
  = note: if there is a `mod metal` elsewhere in the crate already, import it with `use crate::...` instead

error[E0583]: file not found for module `vulkan`
 --> compiler/src/gpu/mod.rs:6:1
  |
6 | pub mod vulkan;
  | ^^^^^^^^^^^^^^^
  |
  = help: to create the module `vulkan`, create file "compiler/src/gpu/vulkan.rs" or "compiler/src/gpu/vulkan/mod.rs"
  = note: if there is a `mod vulkan` elsewhere in the crate already, import it with `use crate::...` instead

error[E0583]: file not found for module `kernel`
 --> compiler/src/gpu/mod.rs:7:1
  |
7 | pub mod kernel;
  | ^^^^^^^^^^^^^^^
  |
  = help: to create the module `kernel`, create file "compiler/src/gpu/kernel.rs" or "compiler/src/gpu/kernel/mod.rs"
  = note: if there is a `mod kernel` elsewhere in the crate already, import it with `use crate::...` instead

error[E0432]: unresolved import `crate::semantic::types`
  --> compiler/src/verification/mod.rs:10:22
   |
10 | use crate::semantic::types::Type;
   |                      ^^^^^ could not find `types` in `semantic`

error[E0432]: unresolved import `crate::semantic::types`
 --> compiler/src/consteval/mod.rs:5:22
  |
5 | use crate::semantic::types::Type;
  |                      ^^^^^ could not find `types` in `semantic`

error[E0432]: unresolved import `crate::error::CompilerError`
 --> compiler/src/codegen/llvm_backend.rs:6:28
  |
6 | use crate::error::{Result, CompilerError};
  |                            ^^^^^^^^^^^^^ no `CompilerError` in `error`

error[E0432]: unresolved import `crate::error::CompilerError`
 --> compiler/src/codegen/target.rs:3:28
  |
3 | use crate::error::{Result, CompilerError};
  |                            ^^^^^^^^^^^^^ no `CompilerError` in `error`

error[E0432]: unresolved import `crate::error::CompilerError`
 --> compiler/src/codegen/linker.rs:3:28
  |
3 | use crate::error::{Result, CompilerError};
  |                            ^^^^^^^^^^^^^ no `CompilerError` in `error`

error[E0532]: expected tuple struct or tuple variant, found unit variant `Constant::Null`
   --> compiler/src/codegen/llvm_backend.rs:129:13
    |
129 |             Constant::Null(ty) => format!("{} null", self.type_to_llvm(ty)),
    |             ^^^^^^^^^^^^^^^^^^ help: use this syntax instead: `Constant::Null`
    |
   ::: compiler/src/ir/ssa.rs:30:5
    |
 30 |     Null,
    |     ---- `Constant::Null` defined here

error[E0532]: expected tuple struct or tuple variant, found unit variant `Constant::Undef`
   --> compiler/src/codegen/llvm_backend.rs:130:13
    |
130 |             Constant::Undef(ty) => format!("{} undef", self.type_to_llvm(ty)),
    |             ^^^^^^^^^^^^^^^^^^^ help: use this syntax instead: `Constant::Undef`
    |
   ::: compiler/src/ir/ssa.rs:31:5
    |
 31 |     Undef,
    |     ----- `Constant::Undef` defined here

error[E0433]: failed to resolve: use of undeclared type `Pin`
  --> compiler/src/async_runtime/executor.rs:64:19
   |
64 |             match Pin::new(&mut future).poll(&waker) {
   |                   ^^^ use of undeclared type `Pin`
   |
help: consider importing this struct
   |
 4 + use std::pin::Pin;
   |

error[E0412]: cannot find type `Thread` in this scope
   --> compiler/src/async_runtime/executor.rs:112:18
    |
112 |     threads: Vec<Thread>,
    |                  ^^^^^^ not found in this scope
    |
help: consider importing this struct
    |
  4 + use std::thread::Thread;
    |

error[E0412]: cannot find type `Arc` in this scope
   --> compiler/src/async_runtime/executor.rs:113:17
    |
113 |     task_queue: Arc<Mutex<VecDeque<Box<dyn Task>>>>,
    |                 ^^^ not found in this scope
    |
help: consider importing this struct
    |
  4 + use std::sync::Arc;
    |

error[E0412]: cannot find type `Mutex` in this scope
   --> compiler/src/async_runtime/executor.rs:113:21
    |
113 |     task_queue: Arc<Mutex<VecDeque<Box<dyn Task>>>>,
    |                     ^^^^^ not found in this scope
    |
help: consider importing one of these structs
    |
  4 + use std::sync::Mutex;
    |
  4 + use std::sync::nonpoison::Mutex;
    |

error[E0433]: failed to resolve: use of undeclared type `Arc`
   --> compiler/src/async_runtime/executor.rs:118:26
    |
118 |         let task_queue = Arc::new(Mutex::new(VecDeque::new()));
    |                          ^^^ use of undeclared type `Arc`
    |
help: consider importing this struct
    |
  4 + use std::sync::Arc;
    |

error[E0433]: failed to resolve: use of undeclared type `Mutex`
   --> compiler/src/async_runtime/executor.rs:118:35
    |
118 |         let task_queue = Arc::new(Mutex::new(VecDeque::new()));
    |                                   ^^^^^ use of undeclared type `Mutex`
    |
help: consider importing one of these structs
    |
  4 + use std::sync::Mutex;
    |
  4 + use std::sync::nonpoison::Mutex;
    |

error[E0433]: failed to resolve: use of undeclared type `Thread`
   --> compiler/src/async_runtime/executor.rs:123:26
    |
123 |             let thread = Thread::spawn(move || {
    |                          ^^^^^^ use of undeclared type `Thread`
    |
help: consider importing this struct
    |
  4 + use std::thread::Thread;
    |

error[E0433]: failed to resolve: use of undeclared type `Thread`
   --> compiler/src/async_runtime/executor.rs:135:25
    |
135 |                         Thread::sleep(Duration::from_millis(10));
    |                         ^^^^^^ use of undeclared type `Thread`
    |
help: consider importing this struct
    |
  4 + use std::thread::Thread;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/verification/smt_solver.rs:113:77
    |
113 |                     _ => Err(Error::new("Unsupported literal type for SMT", Span::dummy())),
    |                                                                             ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/verification/smt_solver.rs:122:21
    |
122 |                     BinaryOp::Add => "+",
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/verification/smt_solver.rs:123:21
    |
123 |                     BinaryOp::Sub => "-",
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/verification/smt_solver.rs:124:21
    |
124 |                     BinaryOp::Mul => "*",
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/verification/smt_solver.rs:125:21
    |
125 |                     BinaryOp::Div => "div",
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/verification/smt_solver.rs:126:21
    |
126 |                     BinaryOp::Eq => "=",
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/verification/smt_solver.rs:127:21
    |
127 |                     BinaryOp::Ne => "distinct",
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/verification/smt_solver.rs:128:21
    |
128 |                     BinaryOp::Lt => "<",
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/verification/smt_solver.rs:129:21
    |
129 |                     BinaryOp::Le => "<=",
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/verification/smt_solver.rs:130:21
    |
130 |                     BinaryOp::Gt => ">",
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/verification/smt_solver.rs:131:21
    |
131 |                     BinaryOp::Ge => ">=",
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/verification/smt_solver.rs:132:21
    |
132 |                     BinaryOp::And => "and",
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/verification/smt_solver.rs:133:21
    |
133 |                     BinaryOp::Or => "or",
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/verification/smt_solver.rs:134:87
    |
134 |                     _ => return Err(Error::new("Unsupported binary operator for SMT", Span::dummy())),
    |                                                                                       ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0433]: failed to resolve: use of undeclared type `UnaryOp`
   --> compiler/src/verification/smt_solver.rs:143:21
    |
143 |                     UnaryOp::Not => "not",
    |                     ^^^^^^^ use of undeclared type `UnaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::UnaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `UnaryOp`
   --> compiler/src/verification/smt_solver.rs:144:21
    |
144 |                     UnaryOp::Neg => "-",
    |                     ^^^^^^^ use of undeclared type `UnaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::UnaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/verification/smt_solver.rs:145:86
    |
145 |                     _ => return Err(Error::new("Unsupported unary operator for SMT", Span::dummy())),
    |                                                                                      ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/verification/smt_solver.rs:150:72
    |
150 |             _ => Err(Error::new("Unsupported expression type for SMT", Span::dummy())),
    |                                                                        ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/verification/smt_solver.rs:195:83
    |
195 |             .map_err(|e| Error::new(format!("Failed to spawn SMT solver: {}", e), Span::dummy()))?;
    |                                                                                   ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/verification/smt_solver.rs:199:90
    |
199 |                 .map_err(|e| Error::new(format!("Failed to write to SMT solver: {}", e), Span::dummy()))?;
    |                                                                                          ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/verification/smt_solver.rs:203:89
    |
203 |             .map_err(|e| Error::new(format!("Failed to read SMT solver output: {}", e), Span::dummy()))?;
    |                                                                                         ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0412]: cannot find type `BinaryOp` in this scope
   --> compiler/src/gpu/mod.rs:285:34
    |
285 |     fn binary_op_str(&self, op: &BinaryOp) -> &str {
    |                                  ^^^^^^^^ not found in this scope
    |
help: consider importing this enum
    |
  9 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/gpu/mod.rs:287:13
    |
287 |             BinaryOp::Add => "+",
    |             ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  9 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/gpu/mod.rs:288:13
    |
288 |             BinaryOp::Sub => "-",
    |             ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  9 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/gpu/mod.rs:289:13
    |
289 |             BinaryOp::Mul => "*",
    |             ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  9 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/gpu/mod.rs:290:13
    |
290 |             BinaryOp::Div => "/",
    |             ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  9 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/gpu/mod.rs:291:13
    |
291 |             BinaryOp::Mod => "%",
    |             ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  9 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/gpu/mod.rs:292:13
    |
292 |             BinaryOp::Eq => "==",
    |             ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  9 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/gpu/mod.rs:293:13
    |
293 |             BinaryOp::Ne => "!=",
    |             ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  9 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/gpu/mod.rs:294:13
    |
294 |             BinaryOp::Lt => "<",
    |             ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  9 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/gpu/mod.rs:295:13
    |
295 |             BinaryOp::Le => "<=",
    |             ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  9 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/gpu/mod.rs:296:13
    |
296 |             BinaryOp::Gt => ">",
    |             ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  9 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/gpu/mod.rs:297:13
    |
297 |             BinaryOp::Ge => ">=",
    |             ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  9 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
  --> compiler/src/consteval/mod.rs:68:25
   |
68 |                         Span::dummy()
   |                         ^^^^ use of undeclared type `Span`
   |
help: consider importing this struct through its public re-export
   |
 4 + use crate::prelude::Span;
   |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/consteval/mod.rs:108:17
    |
108 |                 Span::dummy()
    |                 ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0412]: cannot find type `BinaryOp` in this scope
   --> compiler/src/consteval/mod.rs:123:34
    |
123 |     fn eval_binary_op(&self, op: BinaryOp, left: &ConstValue, right: &ConstValue) -> Result<ConstValue> {
    |                                  ^^^^^^^^ not found in this scope
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:127:21
    |
127 |                     BinaryOp::Add => ConstValue::Int(l + r),
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:128:21
    |
128 |                     BinaryOp::Sub => ConstValue::Int(l - r),
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:129:21
    |
129 |                     BinaryOp::Mul => ConstValue::Int(l * r),
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:130:21
    |
130 |                     BinaryOp::Div => {
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/consteval/mod.rs:132:71
    |
132 | ...                   return Err(Error::new("Division by zero", Span::dummy()));
    |                                                                 ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:136:21
    |
136 |                     BinaryOp::Mod => ConstValue::Int(l % r),
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:137:21
    |
137 |                     BinaryOp::Eq => ConstValue::Bool(l == r),
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:138:21
    |
138 |                     BinaryOp::Ne => ConstValue::Bool(l != r),
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:139:21
    |
139 |                     BinaryOp::Lt => ConstValue::Bool(l < r),
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:140:21
    |
140 |                     BinaryOp::Le => ConstValue::Bool(l <= r),
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:141:21
    |
141 |                     BinaryOp::Gt => ConstValue::Bool(l > r),
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:142:21
    |
142 |                     BinaryOp::Ge => ConstValue::Bool(l >= r),
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:143:21
    |
143 |                     BinaryOp::BitAnd => ConstValue::Int(l & r),
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:144:21
    |
144 |                     BinaryOp::BitOr => ConstValue::Int(l | r),
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:145:21
    |
145 |                     BinaryOp::BitXor => ConstValue::Int(l ^ r),
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:146:21
    |
146 |                     BinaryOp::Shl => ConstValue::Int(l << r),
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:147:21
    |
147 |                     BinaryOp::Shr => ConstValue::Int(l >> r),
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/consteval/mod.rs:148:80
    |
148 |                     _ => return Err(Error::new("Unsupported binary operation", Span::dummy())),
    |                                                                                ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:155:21
    |
155 |                     BinaryOp::Add => ConstValue::Float(l + r),
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:156:21
    |
156 |                     BinaryOp::Sub => ConstValue::Float(l - r),
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:157:21
    |
157 |                     BinaryOp::Mul => ConstValue::Float(l * r),
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:158:21
    |
158 |                     BinaryOp::Div => ConstValue::Float(l / r),
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:159:21
    |
159 |                     BinaryOp::Eq => ConstValue::Bool(l == r),
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:160:21
    |
160 |                     BinaryOp::Ne => ConstValue::Bool(l != r),
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:161:21
    |
161 |                     BinaryOp::Lt => ConstValue::Bool(l < r),
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:162:21
    |
162 |                     BinaryOp::Le => ConstValue::Bool(l <= r),
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0412]: cannot find type `UnaryOp` in this scope
   --> compiler/src/consteval/mod.rs:185:33
    |
185 |     fn eval_unary_op(&self, op: UnaryOp, val: &ConstValue) -> Result<ConstValue> {
    |                                 ^^^^^^^ not found in this scope
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::UnaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:163:21
    |
163 |                     BinaryOp::Gt => ConstValue::Bool(l > r),
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:164:21
    |
164 |                     BinaryOp::Ge => ConstValue::Bool(l >= r),
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/consteval/mod.rs:165:80
    |
165 |                     _ => return Err(Error::new("Unsupported binary operation", Span::dummy())),
    |                                                                                ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0412]: cannot find type `BinaryOp` in this scope
  --> compiler/src/plugin/api.rs:60:40
   |
60 |     pub fn create_binary_op(&self, op: BinaryOp, left: Expr, right: Expr) -> Expr {
   |                                        ^^^^^^^^ not found in this scope
   |
help: consider importing this enum
   |
 4 + use crate::ir::instructions::BinaryOp;
   |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:172:21
    |
172 |                     BinaryOp::And => ConstValue::Bool(*l && *r),
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0412]: cannot find type `Span` in this scope
   --> compiler/src/plugin/mod.rs:151:19
    |
151 |     pub location: Span,
    |                   ^^^^ not found in this scope
    |
help: consider importing this struct through its public re-export
    |
  9 + use crate::prelude::Span;
    |

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:173:21
    |
173 |                     BinaryOp::Or => ConstValue::Bool(*l || *r),
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0659]: `Function` is ambiguous
  --> compiler/src/gpu/mod.rs:78:42
   |
78 |     pub fn generate_kernel(&self, func: &Function) -> Result<String> {
   |                                          ^^^^^^^^ ambiguous name
   |
   = note: ambiguous because of multiple glob imports of a name in the same module
note: `Function` could refer to the struct imported here
  --> compiler/src/gpu/mod.rs:9:5
   |
 9 | use crate::parser::ast::*;
   |     ^^^^^^^^^^^^^^^^^^^^^
   = help: consider adding an explicit import of `Function` to disambiguate
note: `Function` could also refer to the struct imported here
  --> compiler/src/gpu/mod.rs:10:5
   |
10 | use crate::ir::ssa::*;
   |     ^^^^^^^^^^^^^^^^^
   = help: consider adding an explicit import of `Function` to disambiguate

error[E0659]: `Function` is ambiguous
  --> compiler/src/gpu/mod.rs:87:43
   |
87 |     fn generate_cuda_kernel(&self, func: &Function) -> Result<String> {
   |                                           ^^^^^^^^ ambiguous name
   |
   = note: ambiguous because of multiple glob imports of a name in the same module
note: `Function` could refer to the struct imported here
  --> compiler/src/gpu/mod.rs:9:5
   |
 9 | use crate::parser::ast::*;
   |     ^^^^^^^^^^^^^^^^^^^^^
   = help: consider adding an explicit import of `Function` to disambiguate
note: `Function` could also refer to the struct imported here
  --> compiler/src/gpu/mod.rs:10:5
   |
10 | use crate::ir::ssa::*;
   |     ^^^^^^^^^^^^^^^^^
   = help: consider adding an explicit import of `Function` to disambiguate

error[E0659]: `Function` is ambiguous
   --> compiler/src/gpu/mod.rs:120:44
    |
120 |     fn generate_metal_kernel(&self, func: &Function) -> Result<String> {
    |                                            ^^^^^^^^ ambiguous name
    |
    = note: ambiguous because of multiple glob imports of a name in the same module
note: `Function` could refer to the struct imported here
   --> compiler/src/gpu/mod.rs:9:5
    |
  9 | use crate::parser::ast::*;
    |     ^^^^^^^^^^^^^^^^^^^^^
    = help: consider adding an explicit import of `Function` to disambiguate
note: `Function` could also refer to the struct imported here
   --> compiler/src/gpu/mod.rs:10:5
    |
 10 | use crate::ir::ssa::*;
    |     ^^^^^^^^^^^^^^^^^
    = help: consider adding an explicit import of `Function` to disambiguate

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:174:21
    |
174 |                     BinaryOp::Eq => ConstValue::Bool(l == r),
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0659]: `Function` is ambiguous
   --> compiler/src/gpu/mod.rs:157:45
    |
157 |     fn generate_vulkan_kernel(&self, func: &Function) -> Result<String> {
    |                                             ^^^^^^^^ ambiguous name
    |
    = note: ambiguous because of multiple glob imports of a name in the same module
note: `Function` could refer to the struct imported here
   --> compiler/src/gpu/mod.rs:9:5
    |
  9 | use crate::parser::ast::*;
    |     ^^^^^^^^^^^^^^^^^^^^^
    = help: consider adding an explicit import of `Function` to disambiguate
note: `Function` could also refer to the struct imported here
   --> compiler/src/gpu/mod.rs:10:5
    |
 10 | use crate::ir::ssa::*;
    |     ^^^^^^^^^^^^^^^^^
    = help: consider adding an explicit import of `Function` to disambiguate

error[E0659]: `Function` is ambiguous
   --> compiler/src/gpu/mod.rs:193:45
    |
193 |     fn generate_opencl_kernel(&self, func: &Function) -> Result<String> {
    |                                             ^^^^^^^^ ambiguous name
    |
    = note: ambiguous because of multiple glob imports of a name in the same module
note: `Function` could refer to the struct imported here
   --> compiler/src/gpu/mod.rs:9:5
    |
  9 | use crate::parser::ast::*;
    |     ^^^^^^^^^^^^^^^^^^^^^
    = help: consider adding an explicit import of `Function` to disambiguate
note: `Function` could also refer to the struct imported here
   --> compiler/src/gpu/mod.rs:10:5
    |
 10 | use crate::ir::ssa::*;
    |     ^^^^^^^^^^^^^^^^^
    = help: consider adding an explicit import of `Function` to disambiguate

error[E0659]: `Function` is ambiguous
   --> compiler/src/gpu/mod.rs:227:43
    |
227 |     fn generate_kernel_body(&self, func: &Function) -> Result<String> {
    |                                           ^^^^^^^^ ambiguous name
    |
    = note: ambiguous because of multiple glob imports of a name in the same module
note: `Function` could refer to the struct imported here
   --> compiler/src/gpu/mod.rs:9:5
    |
  9 | use crate::parser::ast::*;
    |     ^^^^^^^^^^^^^^^^^^^^^
    = help: consider adding an explicit import of `Function` to disambiguate
note: `Function` could also refer to the struct imported here
   --> compiler/src/gpu/mod.rs:10:5
    |
 10 | use crate::ir::ssa::*;
    |     ^^^^^^^^^^^^^^^^^
    = help: consider adding an explicit import of `Function` to disambiguate

error[E0433]: failed to resolve: use of undeclared type `BinaryOp`
   --> compiler/src/consteval/mod.rs:175:21
    |
175 |                     BinaryOp::Ne => ConstValue::Bool(l != r),
    |                     ^^^^^^^^ use of undeclared type `BinaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::BinaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/consteval/mod.rs:176:80
    |
176 |                     _ => return Err(Error::new("Unsupported binary operation", Span::dummy())),
    |                                                                                ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/consteval/mod.rs:181:70
    |
181 |             _ => Err(Error::new("Type mismatch in binary operation", Span::dummy())),
    |                                                                      ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0433]: failed to resolve: use of undeclared type `UnaryOp`
   --> compiler/src/consteval/mod.rs:189:21
    |
189 |                     UnaryOp::Neg => ConstValue::Int(-n),
    |                     ^^^^^^^ use of undeclared type `UnaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::UnaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `UnaryOp`
   --> compiler/src/consteval/mod.rs:190:21
    |
190 |                     UnaryOp::Not => ConstValue::Bool(*n == 0),
    |                     ^^^^^^^ use of undeclared type `UnaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::UnaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `UnaryOp`
   --> compiler/src/consteval/mod.rs:191:21
    |
191 |                     UnaryOp::BitNot => ConstValue::Int(!n),
    |                     ^^^^^^^ use of undeclared type `UnaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::UnaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/consteval/mod.rs:192:79
    |
192 |                     _ => return Err(Error::new("Unsupported unary operation", Span::dummy())),
    |                                                                               ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0433]: failed to resolve: use of undeclared type `UnaryOp`
   --> compiler/src/consteval/mod.rs:199:21
    |
199 |                     UnaryOp::Neg => ConstValue::Float(-f),
    |                     ^^^^^^^ use of undeclared type `UnaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::UnaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/consteval/mod.rs:200:79
    |
200 |                     _ => return Err(Error::new("Unsupported unary operation", Span::dummy())),
    |                                                                               ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0433]: failed to resolve: use of undeclared type `UnaryOp`
   --> compiler/src/consteval/mod.rs:207:21
    |
207 |                     UnaryOp::Not => ConstValue::Bool(!b),
    |                     ^^^^^^^ use of undeclared type `UnaryOp`
    |
help: consider importing this enum
    |
  4 + use crate::ir::instructions::UnaryOp;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/consteval/mod.rs:208:79
    |
208 |                     _ => return Err(Error::new("Unsupported unary operation", Span::dummy())),
    |                                                                               ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/consteval/mod.rs:213:69
    |
213 |             _ => Err(Error::new("Type mismatch in unary operation", Span::dummy())),
    |                                                                     ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/consteval/mod.rs:221:65
    |
221 |             _ => return Err(Error::new("Invalid function call", Span::dummy())),
    |                                                                 ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/consteval/mod.rs:239:17
    |
239 |                 Span::dummy()
    |                 ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/consteval/mod.rs:246:61
    |
246 |             return Err(Error::new("abs expects 1 argument", Span::dummy()));
    |                                                             ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/consteval/mod.rs:252:65
    |
252 |             _ => Err(Error::new("abs expects numeric argument", Span::dummy())),
    |                                                                 ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/consteval/mod.rs:258:62
    |
258 |             return Err(Error::new("min expects 2 arguments", Span::dummy()));
    |                                                              ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/consteval/mod.rs:264:66
    |
264 |             _ => Err(Error::new("min expects numeric arguments", Span::dummy())),
    |                                                                  ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/consteval/mod.rs:270:62
    |
270 |             return Err(Error::new("max expects 2 arguments", Span::dummy()));
    |                                                              ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/consteval/mod.rs:276:66
    |
276 |             _ => Err(Error::new("max expects numeric arguments", Span::dummy())),
    |                                                                  ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/consteval/mod.rs:282:62
    |
282 |             return Err(Error::new("pow expects 2 arguments", Span::dummy()));
    |                                                              ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/consteval/mod.rs:291:80
    |
291 |                     return Err(Error::new("Negative exponent for integer pow", Span::dummy()));
    |                                                                                ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/consteval/mod.rs:295:66
    |
295 |             _ => Err(Error::new("pow expects numeric arguments", Span::dummy())),
    |                                                                  ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/consteval/mod.rs:301:62
    |
301 |             return Err(Error::new("sqrt expects 1 argument", Span::dummy()));
    |                                                              ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/consteval/mod.rs:307:70
    |
307 |                     return Err(Error::new("sqrt of negative number", Span::dummy()));
    |                                                                      ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

error[E0433]: failed to resolve: use of undeclared type `Span`
   --> compiler/src/consteval/mod.rs:311:64
    |
311 |             _ => Err(Error::new("sqrt expects float argument", Span::dummy())),
    |                                                                ^^^^ use of undeclared type `Span`
    |
help: consider importing this struct through its public re-export
    |
  4 + use crate::prelude::Span;
    |

warning: unused import: `TypeVar`
 --> compiler/src/semantic/type_checker.rs:6:69
  |
6 | use super::type_env::{TypeEnv, InferredType, Substitution, Unifier, TypeVar};
  |                                                                     ^^^^^^^
  |
  = note: `#[warn(unused_imports)]` (part of `#[warn(unused)]`) on by default

warning: unused import: `BasicBlock`
 --> compiler/src/ir/builder.rs:5:42
  |
5 | use super::ssa::{Function as IrFunction, BasicBlock, Value, ValueId, Constant, Module};
  |                                          ^^^^^^^^^^

warning: unused import: `crate::ir::types::IrType`
 --> compiler/src/optimizer/constant_folding.rs:5:5
  |
5 | use crate::ir::types::IrType;
  |     ^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `ValueId`
 --> compiler/src/optimizer/inline.rs:3:54
  |
3 | use crate::ir::ssa::{Module, Function as IrFunction, ValueId};
  |                                                      ^^^^^^^

warning: unused import: `Path`
 --> compiler/src/codegen/linker.rs:5:17
  |
5 | use std::path::{Path, PathBuf};
  |                 ^^^^

warning: unused import: `crate::parser::ast::*`
 --> compiler/src/macro_system/mod.rs:9:5
  |
9 | use crate::parser::ast::*;
  |     ^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `std::prelude::*`
 --> compiler/src/async_runtime/mod.rs:9:5
  |
9 | use std::prelude::*;
  |     ^^^^^^^^^^^^^^^

warning: unused import: `Error`
  --> compiler/src/verification/mod.rs:11:20
   |
11 | use crate::error::{Error, Result};
   |                    ^^^^^

warning: unused import: `std::collections::HashMap`
  --> compiler/src/verification/mod.rs:12:5
   |
12 | use std::collections::HashMap;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `crate::ir::ssa::*`
  --> compiler/src/gpu/mod.rs:10:5
   |
10 | use crate::ir::ssa::*;
   |     ^^^^^^^^^^^^^^^^^

warning: unused import: `Error`
  --> compiler/src/gpu/mod.rs:11:20
   |
11 | use crate::error::{Error, Result};
   |                    ^^^^^

Some errors have detailed explanations: E0412, E0432, E0583, E0659.
For more information about an error, try `rustc --explain E0412`.
error: could not document `vez_compiler`
warning: build failed, waiting for other jobs to finish...
error[E0277]: `F1` is not a future
   --> compiler/src/async_runtime/mod.rs:113:17
    |
113 |     let r1 = f1.await;
    |                 ^^^^^ `F1` is not a future
    |
    = note: F1 must be a future or must implement `IntoFuture` to be awaited
    = note: required for `F1` to implement `IntoFuture`
help: remove the `.await`
    |
113 -     let r1 = f1.await;
113 +     let r1 = f1;
    |
help: consider further restricting type parameter `F1` with trait `Future`
    |
110 |     F1: Future + std::future::Future,
    |                +++++++++++++++++++++

error[E0277]: `F2` is not a future
   --> compiler/src/async_runtime/mod.rs:114:17
    |
114 |     let r2 = f2.await;
    |                 ^^^^^ `F2` is not a future
    |
    = note: F2 must be a future or must implement `IntoFuture` to be awaited
    = note: required for `F2` to implement `IntoFuture`
help: remove the `.await`
    |
114 -     let r2 = f2.await;
114 +     let r2 = f2;
    |
help: consider further restricting type parameter `F2` with trait `Future`
    |
111 |     F2: Future + std::future::Future,
    |                +++++++++++++++++++++

error[E0023]: this pattern has 1 field, but the corresponding tuple variant has 2 fields
  --> compiler/src/lexer/token.rs:66:35
   |
26 |     IntLiteral(String, Option<String>),   // value, optional suffix (i32, u64, etc.)
   |                ------  -------------- tuple variant has 2 fields
...
66 |             TokenKind::IntLiteral(_) | TokenKind::FloatLiteral(_) |
   |                                   ^ expected 2 fields, found 1
   |
help: use `_` to explicitly ignore each field
   |
66 |             TokenKind::IntLiteral(_, _) | TokenKind::FloatLiteral(_) |
   |                                    +++
help: use `..` to ignore all fields
   |
66 -             TokenKind::IntLiteral(_) | TokenKind::FloatLiteral(_) |
66 +             TokenKind::IntLiteral(..) | TokenKind::FloatLiteral(_) |
   |

error[E0023]: this pattern has 1 field, but the corresponding tuple variant has 2 fields
  --> compiler/src/lexer/token.rs:66:64
   |
27 |     FloatLiteral(String, Option<String>), // value, optional suffix (f32, f64)
   |                  ------  -------------- tuple variant has 2 fields
...
66 |             TokenKind::IntLiteral(_) | TokenKind::FloatLiteral(_) |
   |                                                                ^ expected 2 fields, found 1
   |
help: use `_` to explicitly ignore each field
   |
66 |             TokenKind::IntLiteral(_) | TokenKind::FloatLiteral(_, _) |
   |                                                                 +++
help: use `..` to ignore all fields
   |
66 -             TokenKind::IntLiteral(_) | TokenKind::FloatLiteral(_) |
66 +             TokenKind::IntLiteral(_) | TokenKind::FloatLiteral(..) |
   |

error[E0308]: mismatched types
   --> compiler/src/lexer/mod.rs:689:13
    |
682 |     fn lex_slash(&mut self) -> Result<TokenKind> {
    |                                ----------------- expected `std::result::Result<TokenKind, error::Error>` because of return type
...
689 |             self.next_token() // Skip comment and get next token
    |             ^^^^^^^^^^^^^^^^^ expected `Result<TokenKind, Error>`, found `Result<Token, Error>`
    |
    = note: expected enum `std::result::Result<TokenKind, _>`
               found enum `std::result::Result<Token, _>`

error[E0308]: mismatched types
   --> compiler/src/lexer/mod.rs:698:32
    |
682 |     fn lex_slash(&mut self) -> Result<TokenKind> {
    |                                ----------------- expected `std::result::Result<TokenKind, error::Error>` because of return type
...
698 |                         return self.next_token(); // Skip comment
    |                                ^^^^^^^^^^^^^^^^^ expected `Result<TokenKind, Error>`, found `Result<Token, Error>`
    |
    = note: expected enum `std::result::Result<TokenKind, _>`
               found enum `std::result::Result<Token, _>`

error[E0599]: no function or associated item named `default` found for struct `span::Span` in the current scope
  --> compiler/src/semantic/resolver.rs:66:19
   |
66 |             Span::default(),
   |                   ^^^^^^^ function or associated item not found in `span::Span`
   |
  ::: compiler/src/span.rs:31:1
   |
31 | pub struct Span {
   | --------------- function or associated item `default` not found for this struct
   |
note: if you're trying to build a new `span::Span`, consider using `span::Span::new` which returns `span::Span`
  --> compiler/src/span.rs:37:5
   |
37 |     pub fn new(start: Position, end: Position) -> Self {
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   = help: items from traits can only be used if the trait is implemented and in scope
   = note: the following trait defines an item `default`, perhaps you need to implement it:
           candidate #1: `Default`

error[E0599]: no variant or associated item named `DuplicateSymbol` found for enum `error::ErrorKind` in the current scope
  --> compiler/src/semantic/resolver.rs:71:50
   |
71 |             self.add_error(Error::new(ErrorKind::DuplicateSymbol, e));
   |                                                  ^^^^^^^^^^^^^^^ variant or associated item not found in `error::ErrorKind`
   |
  ::: compiler/src/error.rs:18:1
   |
18 | pub enum ErrorKind {
   | ------------------ variant or associated item `DuplicateSymbol` not found for this enum

error[E0599]: no function or associated item named `default` found for struct `span::Span` in the current scope
  --> compiler/src/semantic/resolver.rs:84:23
   |
84 |                 Span::default(),
   |                       ^^^^^^^ function or associated item not found in `span::Span`
   |
  ::: compiler/src/span.rs:31:1
   |
31 | pub struct Span {
   | --------------- function or associated item `default` not found for this struct
   |
note: if you're trying to build a new `span::Span`, consider using `span::Span::new` which returns `span::Span`
  --> compiler/src/span.rs:37:5
   |
37 |     pub fn new(start: Position, end: Position) -> Self {
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   = help: items from traits can only be used if the trait is implemented and in scope
   = note: the following trait defines an item `default`, perhaps you need to implement it:
           candidate #1: `Default`

error[E0599]: no variant or associated item named `DuplicateSymbol` found for enum `error::ErrorKind` in the current scope
  --> compiler/src/semantic/resolver.rs:89:54
   |
89 |                 self.add_error(Error::new(ErrorKind::DuplicateSymbol, e));
   |                                                      ^^^^^^^^^^^^^^^ variant or associated item not found in `error::ErrorKind`
   |
  ::: compiler/src/error.rs:18:1
   |
18 | pub enum ErrorKind {
   | ------------------ variant or associated item `DuplicateSymbol` not found for this enum

error[E0599]: no function or associated item named `default` found for struct `span::Span` in the current scope
  --> compiler/src/semantic/resolver.rs:99:23
   |
99 |                 Span::default(),
   |                       ^^^^^^^ function or associated item not found in `span::Span`
   |
  ::: compiler/src/span.rs:31:1
   |
31 | pub struct Span {
   | --------------- function or associated item `default` not found for this struct
   |
note: if you're trying to build a new `span::Span`, consider using `span::Span::new` which returns `span::Span`
  --> compiler/src/span.rs:37:5
   |
37 |     pub fn new(start: Position, end: Position) -> Self {
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   = help: items from traits can only be used if the trait is implemented and in scope
   = note: the following trait defines an item `default`, perhaps you need to implement it:
           candidate #1: `Default`

error[E0599]: no variant or associated item named `DuplicateSymbol` found for enum `error::ErrorKind` in the current scope
   --> compiler/src/semantic/resolver.rs:104:54
    |
104 |                 self.add_error(Error::new(ErrorKind::DuplicateSymbol, e));
    |                                                      ^^^^^^^^^^^^^^^ variant or associated item not found in `error::ErrorKind`
    |
   ::: compiler/src/error.rs:18:1
    |
 18 | pub enum ErrorKind {
    | ------------------ variant or associated item `DuplicateSymbol` not found for this enum

error[E0599]: no function or associated item named `default` found for struct `span::Span` in the current scope
   --> compiler/src/semantic/resolver.rs:122:19
    |
122 |             Span::default(),
    |                   ^^^^^^^ function or associated item not found in `span::Span`
    |
   ::: compiler/src/span.rs:31:1
    |
 31 | pub struct Span {
    | --------------- function or associated item `default` not found for this struct
    |
note: if you're trying to build a new `span::Span`, consider using `span::Span::new` which returns `span::Span`
   --> compiler/src/span.rs:37:5
    |
 37 |     pub fn new(start: Position, end: Position) -> Self {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    = help: items from traits can only be used if the trait is implemented and in scope
    = note: the following trait defines an item `default`, perhaps you need to implement it:
            candidate #1: `Default`

error[E0599]: no variant or associated item named `DuplicateSymbol` found for enum `error::ErrorKind` in the current scope
   --> compiler/src/semantic/resolver.rs:127:50
    |
127 |             self.add_error(Error::new(ErrorKind::DuplicateSymbol, e));
    |                                                  ^^^^^^^^^^^^^^^ variant or associated item not found in `error::ErrorKind`
    |
   ::: compiler/src/error.rs:18:1
    |
 18 | pub enum ErrorKind {
    | ------------------ variant or associated item `DuplicateSymbol` not found for this enum

error[E0599]: no function or associated item named `default` found for struct `span::Span` in the current scope
   --> compiler/src/semantic/resolver.rs:136:19
    |
136 |             Span::default(),
    |                   ^^^^^^^ function or associated item not found in `span::Span`
    |
   ::: compiler/src/span.rs:31:1
    |
 31 | pub struct Span {
    | --------------- function or associated item `default` not found for this struct
    |
note: if you're trying to build a new `span::Span`, consider using `span::Span::new` which returns `span::Span`
   --> compiler/src/span.rs:37:5
    |
 37 |     pub fn new(start: Position, end: Position) -> Self {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    = help: items from traits can only be used if the trait is implemented and in scope
    = note: the following trait defines an item `default`, perhaps you need to implement it:
            candidate #1: `Default`

error[E0599]: no variant or associated item named `DuplicateSymbol` found for enum `error::ErrorKind` in the current scope
   --> compiler/src/semantic/resolver.rs:141:50
    |
141 |             self.add_error(Error::new(ErrorKind::DuplicateSymbol, e));
    |                                                  ^^^^^^^^^^^^^^^ variant or associated item not found in `error::ErrorKind`
    |
   ::: compiler/src/error.rs:18:1
    |
 18 | pub enum ErrorKind {
    | ------------------ variant or associated item `DuplicateSymbol` not found for this enum

error[E0599]: no function or associated item named `default` found for struct `span::Span` in the current scope
   --> compiler/src/semantic/resolver.rs:151:23
    |
151 |                 Span::default(),
    |                       ^^^^^^^ function or associated item not found in `span::Span`
    |
   ::: compiler/src/span.rs:31:1
    |
 31 | pub struct Span {
    | --------------- function or associated item `default` not found for this struct
    |
note: if you're trying to build a new `span::Span`, consider using `span::Span::new` which returns `span::Span`
   --> compiler/src/span.rs:37:5
    |
 37 |     pub fn new(start: Position, end: Position) -> Self {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    = help: items from traits can only be used if the trait is implemented and in scope
    = note: the following trait defines an item `default`, perhaps you need to implement it:
            candidate #1: `Default`

error[E0599]: no variant or associated item named `DuplicateSymbol` found for enum `error::ErrorKind` in the current scope
   --> compiler/src/semantic/resolver.rs:156:54
    |
156 |                 self.add_error(Error::new(ErrorKind::DuplicateSymbol, e));
    |                                                      ^^^^^^^^^^^^^^^ variant or associated item not found in `error::ErrorKind`
    |
   ::: compiler/src/error.rs:18:1
    |
 18 | pub enum ErrorKind {
    | ------------------ variant or associated item `DuplicateSymbol` not found for this enum

error[E0599]: no function or associated item named `default` found for struct `span::Span` in the current scope
   --> compiler/src/semantic/resolver.rs:166:19
    |
166 |             Span::default(),
    |                   ^^^^^^^ function or associated item not found in `span::Span`
    |
   ::: compiler/src/span.rs:31:1
    |
 31 | pub struct Span {
    | --------------- function or associated item `default` not found for this struct
    |
note: if you're trying to build a new `span::Span`, consider using `span::Span::new` which returns `span::Span`
   --> compiler/src/span.rs:37:5
    |
 37 |     pub fn new(start: Position, end: Position) -> Self {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    = help: items from traits can only be used if the trait is implemented and in scope
    = note: the following trait defines an item `default`, perhaps you need to implement it:
            candidate #1: `Default`

error[E0599]: no variant or associated item named `DuplicateSymbol` found for enum `error::ErrorKind` in the current scope
   --> compiler/src/semantic/resolver.rs:171:50
    |
171 |             self.add_error(Error::new(ErrorKind::DuplicateSymbol, e));
    |                                                  ^^^^^^^^^^^^^^^ variant or associated item not found in `error::ErrorKind`
    |
   ::: compiler/src/error.rs:18:1
    |
 18 | pub enum ErrorKind {
    | ------------------ variant or associated item `DuplicateSymbol` not found for this enum

error[E0599]: no function or associated item named `default` found for struct `span::Span` in the current scope
   --> compiler/src/semantic/resolver.rs:185:23
    |
185 |                 Span::default(),
    |                       ^^^^^^^ function or associated item not found in `span::Span`
    |
   ::: compiler/src/span.rs:31:1
    |
 31 | pub struct Span {
    | --------------- function or associated item `default` not found for this struct
    |
note: if you're trying to build a new `span::Span`, consider using `span::Span::new` which returns `span::Span`
   --> compiler/src/span.rs:37:5
    |
 37 |     pub fn new(start: Position, end: Position) -> Self {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    = help: items from traits can only be used if the trait is implemented and in scope
    = note: the following trait defines an item `default`, perhaps you need to implement it:
            candidate #1: `Default`

error[E0599]: no variant or associated item named `DuplicateSymbol` found for enum `error::ErrorKind` in the current scope
   --> compiler/src/semantic/resolver.rs:190:54
    |
190 |                 self.add_error(Error::new(ErrorKind::DuplicateSymbol, e));
    |                                                      ^^^^^^^^^^^^^^^ variant or associated item not found in `error::ErrorKind`
    |
   ::: compiler/src/error.rs:18:1
    |
 18 | pub enum ErrorKind {
    | ------------------ variant or associated item `DuplicateSymbol` not found for this enum

error[E0599]: no function or associated item named `default` found for struct `span::Span` in the current scope
   --> compiler/src/semantic/resolver.rs:217:19
    |
217 |             Span::default(),
    |                   ^^^^^^^ function or associated item not found in `span::Span`
    |
   ::: compiler/src/span.rs:31:1
    |
 31 | pub struct Span {
    | --------------- function or associated item `default` not found for this struct
    |
note: if you're trying to build a new `span::Span`, consider using `span::Span::new` which returns `span::Span`
   --> compiler/src/span.rs:37:5
    |
 37 |     pub fn new(start: Position, end: Position) -> Self {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    = help: items from traits can only be used if the trait is implemented and in scope
    = note: the following trait defines an item `default`, perhaps you need to implement it:
            candidate #1: `Default`

error[E0599]: no variant or associated item named `DuplicateSymbol` found for enum `error::ErrorKind` in the current scope
   --> compiler/src/semantic/resolver.rs:222:50
    |
222 |             self.add_error(Error::new(ErrorKind::DuplicateSymbol, e));
    |                                                  ^^^^^^^^^^^^^^^ variant or associated item not found in `error::ErrorKind`
    |
   ::: compiler/src/error.rs:18:1
    |
 18 | pub enum ErrorKind {
    | ------------------ variant or associated item `DuplicateSymbol` not found for this enum

error[E0599]: no function or associated item named `default` found for struct `span::Span` in the current scope
   --> compiler/src/semantic/resolver.rs:250:27
    |
250 |                     Span::default(),
    |                           ^^^^^^^ function or associated item not found in `span::Span`
    |
   ::: compiler/src/span.rs:31:1
    |
 31 | pub struct Span {
    | --------------- function or associated item `default` not found for this struct
    |
note: if you're trying to build a new `span::Span`, consider using `span::Span::new` which returns `span::Span`
   --> compiler/src/span.rs:37:5
    |
 37 |     pub fn new(start: Position, end: Position) -> Self {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    = help: items from traits can only be used if the trait is implemented and in scope
    = note: the following trait defines an item `default`, perhaps you need to implement it:
            candidate #1: `Default`

error[E0599]: no variant or associated item named `DuplicateSymbol` found for enum `error::ErrorKind` in the current scope
   --> compiler/src/semantic/resolver.rs:259:58
    |
259 |                     self.add_error(Error::new(ErrorKind::DuplicateSymbol, e));
    |                                                          ^^^^^^^^^^^^^^^ variant or associated item not found in `error::ErrorKind`
    |
   ::: compiler/src/error.rs:18:1
    |
 18 | pub enum ErrorKind {
    | ------------------ variant or associated item `DuplicateSymbol` not found for this enum

error[E0599]: no function or associated item named `default` found for struct `span::Span` in the current scope
   --> compiler/src/semantic/resolver.rs:357:27
    |
357 |                     Span::default(),
    |                           ^^^^^^^ function or associated item not found in `span::Span`
    |
   ::: compiler/src/span.rs:31:1
    |
 31 | pub struct Span {
    | --------------- function or associated item `default` not found for this struct
    |
note: if you're trying to build a new `span::Span`, consider using `span::Span::new` which returns `span::Span`
   --> compiler/src/span.rs:37:5
    |
 37 |     pub fn new(start: Position, end: Position) -> Self {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    = help: items from traits can only be used if the trait is implemented and in scope
    = note: the following trait defines an item `default`, perhaps you need to implement it:
            candidate #1: `Default`

error[E0599]: no variant or associated item named `DuplicateSymbol` found for enum `error::ErrorKind` in the current scope
   --> compiler/src/semantic/resolver.rs:362:58
    |
362 |                     self.add_error(Error::new(ErrorKind::DuplicateSymbol, e));
    |                                                          ^^^^^^^^^^^^^^^ variant or associated item not found in `error::ErrorKind`
    |
   ::: compiler/src/error.rs:18:1
    |
 18 | pub enum ErrorKind {
    | ------------------ variant or associated item `DuplicateSymbol` not found for this enum

error[E0599]: no function or associated item named `default` found for struct `span::Span` in the current scope
   --> compiler/src/semantic/resolver.rs:407:27
    |
407 |                     Span::default(),
    |                           ^^^^^^^ function or associated item not found in `span::Span`
    |
   ::: compiler/src/span.rs:31:1
    |
 31 | pub struct Span {
    | --------------- function or associated item `default` not found for this struct
    |
note: if you're trying to build a new `span::Span`, consider using `span::Span::new` which returns `span::Span`
   --> compiler/src/span.rs:37:5
    |
 37 |     pub fn new(start: Position, end: Position) -> Self {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    = help: items from traits can only be used if the trait is implemented and in scope
    = note: the following trait defines an item `default`, perhaps you need to implement it:
            candidate #1: `Default`

error[E0599]: no variant or associated item named `DuplicateSymbol` found for enum `error::ErrorKind` in the current scope
   --> compiler/src/semantic/resolver.rs:412:58
    |
412 |                     self.add_error(Error::new(ErrorKind::DuplicateSymbol, e));
    |                                                          ^^^^^^^^^^^^^^^ variant or associated item not found in `error::ErrorKind`
    |
   ::: compiler/src/error.rs:18:1
    |
 18 | pub enum ErrorKind {
    | ------------------ variant or associated item `DuplicateSymbol` not found for this enum

error[E0599]: no variant or associated item named `TypeError` found for enum `error::ErrorKind` in the current scope
   --> compiler/src/semantic/type_env.rs:239:36
    |
239 |                         ErrorKind::TypeError,
    |                                    ^^^^^^^^^ variant or associated item not found in `error::ErrorKind`
    |
   ::: compiler/src/error.rs:18:1
    |
 18 | pub enum ErrorKind {
    | ------------------ variant or associated item `TypeError` not found for this enum
    |
help: there is a variant with a similar name
    |
239 -                         ErrorKind::TypeError,
240 -                         "Occurs check failed: infinite type"
241 -                     ))
239 +                         ErrorKind::MoveError)
    |

error[E0599]: no variant or associated item named `TypeError` found for enum `error::ErrorKind` in the current scope
   --> compiler/src/semantic/type_env.rs:253:36
    |
253 |                         ErrorKind::TypeError,
    |                                    ^^^^^^^^^ variant or associated item not found in `error::ErrorKind`
    |
   ::: compiler/src/error.rs:18:1
    |
 18 | pub enum ErrorKind {
    | ------------------ variant or associated item `TypeError` not found for this enum
    |
help: there is a variant with a similar name
    |
253 -                         ErrorKind::TypeError,
254 -                         format!("Function arity mismatch: {} vs {}", params1.len(), params2.len())
255 -                     ));
253 +                         ErrorKind::MoveError);
    |

error[E0599]: no variant or associated item named `TypeError` found for enum `error::ErrorKind` in the current scope
   --> compiler/src/semantic/type_env.rs:275:36
    |
275 |                         ErrorKind::TypeError,
    |                                    ^^^^^^^^^ variant or associated item not found in `error::ErrorKind`
    |
   ::: compiler/src/error.rs:18:1
    |
 18 | pub enum ErrorKind {
    | ------------------ variant or associated item `TypeError` not found for this enum
    |
help: there is a variant with a similar name
    |
275 -                         ErrorKind::TypeError,
276 -                         format!("Type mismatch: {} vs {}", name1, name2)
277 -                     ));
275 +                         ErrorKind::MoveError);
    |

error[E0599]: no variant or associated item named `TypeError` found for enum `error::ErrorKind` in the current scope
   --> compiler/src/semantic/type_env.rs:282:36
    |
282 |                         ErrorKind::TypeError,
    |                                    ^^^^^^^^^ variant or associated item not found in `error::ErrorKind`
    |
   ::: compiler/src/error.rs:18:1
    |
 18 | pub enum ErrorKind {
    | ------------------ variant or associated item `TypeError` not found for this enum
    |
help: there is a variant with a similar name
    |
282 -                         ErrorKind::TypeError,
283 -                         "Generic argument count mismatch"
284 -                     ));
282 +                         ErrorKind::MoveError);
    |

error[E0599]: no variant or associated item named `TypeError` found for enum `error::ErrorKind` in the current scope
   --> compiler/src/semantic/type_env.rs:300:36
    |
300 |                         ErrorKind::TypeError,
    |                                    ^^^^^^^^^ variant or associated item not found in `error::ErrorKind`
    |
   ::: compiler/src/error.rs:18:1
    |
 18 | pub enum ErrorKind {
    | ------------------ variant or associated item `TypeError` not found for this enum
    |
help: there is a variant with a similar name
    |
300 -                         ErrorKind::TypeError,
301 -                         "Tuple size mismatch"
302 -                     ));
300 +                         ErrorKind::MoveError);
    |

error[E0599]: no variant or associated item named `TypeError` found for enum `error::ErrorKind` in the current scope
   --> compiler/src/semantic/type_env.rs:318:36
    |
318 |                         ErrorKind::TypeError,
    |                                    ^^^^^^^^^ variant or associated item not found in `error::ErrorKind`
    |
   ::: compiler/src/error.rs:18:1
    |
 18 | pub enum ErrorKind {
    | ------------------ variant or associated item `TypeError` not found for this enum
    |
help: there is a variant with a similar name
    |
318 -                         ErrorKind::TypeError,
319 -                         "Array size mismatch"
320 -                     ));
318 +                         ErrorKind::MoveError);
    |

error[E0599]: no variant or associated item named `TypeError` found for enum `error::ErrorKind` in the current scope
   --> compiler/src/semantic/type_env.rs:341:36
    |
341 |                         ErrorKind::TypeError,
    |                                    ^^^^^^^^^ variant or associated item not found in `error::ErrorKind`
    |
   ::: compiler/src/error.rs:18:1
    |
 18 | pub enum ErrorKind {
    | ------------------ variant or associated item `TypeError` not found for this enum
    |
help: there is a variant with a similar name
    |
341 -                         ErrorKind::TypeError,
342 -                         format!("Type mismatch: {} vs {}", n1, n2)
343 -                     ))
341 +                         ErrorKind::MoveError)
    |

error[E0599]: no variant or associated item named `TypeError` found for enum `error::ErrorKind` in the current scope
   --> compiler/src/semantic/type_env.rs:349:28
    |
349 |                 ErrorKind::TypeError,
    |                            ^^^^^^^^^ variant or associated item not found in `error::ErrorKind`
    |
   ::: compiler/src/error.rs:18:1
    |
 18 | pub enum ErrorKind {
    | ------------------ variant or associated item `TypeError` not found for this enum
    |
help: there is a variant with a similar name
    |
349 -                 ErrorKind::TypeError,
350 -                 format!("Cannot unify types: {:?} and {:?}", t1, t2)
351 -             ))
349 +                 ErrorKind::MoveError)
    |

error[E0599]: no variant or associated item named `TypeError` found for enum `error::ErrorKind` in the current scope
   --> compiler/src/semantic/type_checker.rs:144:36
    |
144 |                         ErrorKind::TypeError,
    |                                    ^^^^^^^^^ variant or associated item not found in `error::ErrorKind`
    |
   ::: compiler/src/error.rs:18:1
    |
 18 | pub enum ErrorKind {
    | ------------------ variant or associated item `TypeError` not found for this enum
    |
help: there is a variant with a similar name
    |
144 -                         ErrorKind::TypeError,
145 -                         "Let binding must have type annotation or initializer"
146 -                     ));
144 +                         ErrorKind::MoveError);
    |

warning: unreachable expression
  --> compiler/src/codegen/llvm_backend.rs:46:9
   |
33 |         return "x86_64-unknown-linux-gnu".to_string();
   |         --------------------------------------------- any code following this expression is unreachable
...
46 |         "unknown-unknown-unknown".to_string()
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ unreachable expression
   |
   = note: `#[warn(unreachable_code)]` (part of `#[warn(unused)]`) on by default

error[E0599]: no variant or associated item named `I1` found for enum `IrType` in the current scope
  --> compiler/src/codegen/llvm_backend.rs:60:21
   |
60 |             IrType::I1 => "i1".to_string(),
   |                     ^^ variant or associated item not found in `IrType`
   |
  ::: compiler/src/ir/types.rs:7:1
   |
 7 | pub enum IrType {
   | --------------- variant or associated item `I1` not found for this enum
   |
help: there is a variant with a similar name
   |
60 -             IrType::I1 => "i1".to_string(),
60 +             IrType::I8 => "i1".to_string(),
   |

error[E0599]: no variant or associated item named `Ptr` found for enum `IrType` in the current scope
  --> compiler/src/codegen/llvm_backend.rs:73:21
   |
73 |             IrType::Ptr(inner) => format!("{}*", self.type_to_llvm(inner)),
   |                     ^^^ variant or associated item not found in `IrType`
   |
  ::: compiler/src/ir/types.rs:7:1
   |
 7 | pub enum IrType {
   | --------------- variant or associated item `Ptr` not found for this enum

error[E0026]: variant `Instruction::Branch` does not have fields named `true_bb`, `false_bb`
   --> compiler/src/codegen/llvm_backend.rs:290:41
    |
290 |             Instruction::Branch { cond, true_bb, false_bb } => {
    |                                         ^^^^^^^  ^^^^^^^^ variant `Instruction::Branch` does not have these fields

error[E0027]: pattern does not mention fields `then_block`, `else_block`
   --> compiler/src/codegen/llvm_backend.rs:290:13
    |
290 |             Instruction::Branch { cond, true_bb, false_bb } => {
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ missing fields `then_block`, `else_block`
    |
help: include the missing fields in the pattern
    |
290 |             Instruction::Branch { cond, true_bb, false_bb, then_block, else_block } => {
    |                                                          ++++++++++++++++++++++++
help: if you don't care about these missing fields, you can explicitly ignore them
    |
290 |             Instruction::Branch { cond, true_bb, false_bb, then_block: _, else_block: _ } => {
    |                                                          ++++++++++++++++++++++++++++++
help: or always ignore missing fields here
    |
290 |             Instruction::Branch { cond, true_bb, false_bb, .. } => {
    |                                                          ++++

error[E0609]: no field `0` on type `&usize`
   --> compiler/src/codegen/llvm_backend.rs:295:53
    |
295 |                 Ok(format!("br label %bb{}", target.0))
    |                                                     ^ unknown field

error[E0609]: no field `0` on type `&usize`
   --> compiler/src/codegen/llvm_backend.rs:305:63
    |
305 |                         format!("[ {}, %bb{} ]", val_name, bb.0)
    |                                                               ^ unknown field

error[E0599]: no variant or associated item named `I1` found for enum `IrType` in the current scope
   --> compiler/src/codegen/llvm_backend.rs:337:59
    |
337 |             Value::Constant(Constant::Bool(_)) => IrType::I1,
    |                                                           ^^ variant or associated item not found in `IrType`
    |
   ::: compiler/src/ir/types.rs:7:1
    |
  7 | pub enum IrType {
    | --------------- variant or associated item `I1` not found for this enum
    |
help: there is a variant with a similar name
    |
337 -             Value::Constant(Constant::Bool(_)) => IrType::I1,
337 +             Value::Constant(Constant::Bool(_)) => IrType::I8,
    |

error[E0599]: no variant named `MacroCall` found for enum `ast::Expr`
  --> compiler/src/macro_system/expander.rs:25:19
   |
25 |             Expr::MacroCall { name, args, span } => {
   |                   ^^^^^^^^^ variant not found in `ast::Expr`
   |
  ::: compiler/src/parser/ast.rs:94:1
   |
94 | pub enum Expr {
   | ------------- variant `MacroCall` not found here

error[E0769]: tuple variant `Expr::Binary` written as struct variant
  --> compiler/src/macro_system/expander.rs:28:13
   |
28 |             Expr::Binary { op, left, right, span } => {
   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
help: use the tuple variant pattern syntax instead
   |
28 -             Expr::Binary { op, left, right, span } => {
28 +             Expr::Binary(_, _, _) => {
   |

error[E0769]: tuple variant `Expr::Call` written as struct variant
  --> compiler/src/macro_system/expander.rs:38:13
   |
38 |             Expr::Call { func, args, span } => {
   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
help: use the tuple variant pattern syntax instead
   |
38 -             Expr::Call { func, args, span } => {
38 +             Expr::Call(_, _) => {
   |

error[E0769]: tuple variant `Expr::Block` written as struct variant
  --> compiler/src/macro_system/expander.rs:49:13
   |
49 |             Expr::Block { stmts, span } => {
   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
help: use the tuple variant pattern syntax instead
   |
49 -             Expr::Block { stmts, span } => {
49 +             Expr::Block(_) => {
   |

error[E0559]: variant `ast::Expr::Binary` has no field named `op`
  --> compiler/src/macro_system/expander.rs:32:21
   |
32 |                     op: *op,
   |                     ^^ field does not exist
   |
  ::: compiler/src/parser/ast.rs:97:5
   |
97 |     Binary(Box<Expr>, BinOp, Box<Expr>),
   |     ------ `ast::Expr::Binary` defined here
   |
help: `ast::Expr::Binary` is a tuple variant, use the appropriate syntax
   |
31 -                 Ok(Expr::Binary {
32 -                     op: *op,
33 -                     left,
34 -                     right,
35 -                     span: *span,
36 -                 })
31 +                 Ok(Expr::Binary(/* Box<ast::Expr> */, /* ast::BinOp */, /* Box<ast::Expr> */))
   |

error[E0559]: variant `ast::Expr::Binary` has no field named `left`
  --> compiler/src/macro_system/expander.rs:33:21
   |
33 |                     left,
   |                     ^^^^ field does not exist
   |
  ::: compiler/src/parser/ast.rs:97:5
   |
97 |     Binary(Box<Expr>, BinOp, Box<Expr>),
   |     ------ `ast::Expr::Binary` defined here
   |
help: `ast::Expr::Binary` is a tuple variant, use the appropriate syntax
   |
31 -                 Ok(Expr::Binary {
32 -                     op: *op,
33 -                     left,
34 -                     right,
35 -                     span: *span,
36 -                 })
31 +                 Ok(Expr::Binary(/* Box<ast::Expr> */, /* ast::BinOp */, /* Box<ast::Expr> */))
   |

error[E0559]: variant `ast::Expr::Binary` has no field named `right`
  --> compiler/src/macro_system/expander.rs:34:21
   |
34 |                     right,
   |                     ^^^^^ field does not exist
   |
  ::: compiler/src/parser/ast.rs:97:5
   |
97 |     Binary(Box<Expr>, BinOp, Box<Expr>),
   |     ------ `ast::Expr::Binary` defined here
   |
help: `ast::Expr::Binary` is a tuple variant, use the appropriate syntax
   |
31 -                 Ok(Expr::Binary {
32 -                     op: *op,
33 -                     left,
34 -                     right,
35 -                     span: *span,
36 -                 })
31 +                 Ok(Expr::Binary(/* Box<ast::Expr> */, /* ast::BinOp */, /* Box<ast::Expr> */))
   |

error[E0559]: variant `ast::Expr::Binary` has no field named `span`
  --> compiler/src/macro_system/expander.rs:35:21
   |
35 |                     span: *span,
   |                     ^^^^ field does not exist
   |
  ::: compiler/src/parser/ast.rs:97:5
   |
97 |     Binary(Box<Expr>, BinOp, Box<Expr>),
   |     ------ `ast::Expr::Binary` defined here
   |
help: `ast::Expr::Binary` is a tuple variant, use the appropriate syntax
   |
31 -                 Ok(Expr::Binary {
32 -                     op: *op,
33 -                     left,
34 -                     right,
35 -                     span: *span,
36 -                 })
31 +                 Ok(Expr::Binary(/* Box<ast::Expr> */, /* ast::BinOp */, /* Box<ast::Expr> */))
   |

error[E0559]: variant `ast::Expr::Call` has no field named `func`
  --> compiler/src/macro_system/expander.rs:44:21
   |
44 |                     func,
   |                     ^^^^ field does not exist
   |
  ::: compiler/src/parser/ast.rs:99:5
   |
99 |     Call(Box<Expr>, Vec<Expr>),
   |     ---- `ast::Expr::Call` defined here
   |
help: `ast::Expr::Call` is a tuple variant, use the appropriate syntax
   |
43 -                 Ok(Expr::Call {
44 -                     func,
45 -                     args,
46 -                     span: *span,
47 -                 })
43 +                 Ok(Expr::Call(/* Box<ast::Expr> */, /* Vec<ast::Expr> */))
   |

error[E0559]: variant `ast::Expr::Call` has no field named `args`
  --> compiler/src/macro_system/expander.rs:45:21
   |
45 |                     args,
   |                     ^^^^ field does not exist
   |
  ::: compiler/src/parser/ast.rs:99:5
   |
99 |     Call(Box<Expr>, Vec<Expr>),
   |     ---- `ast::Expr::Call` defined here
   |
help: `ast::Expr::Call` is a tuple variant, use the appropriate syntax
   |
43 -                 Ok(Expr::Call {
44 -                     func,
45 -                     args,
46 -                     span: *span,
47 -                 })
43 +                 Ok(Expr::Call(/* Box<ast::Expr> */, /* Vec<ast::Expr> */))
   |

error[E0559]: variant `ast::Expr::Call` has no field named `span`
  --> compiler/src/macro_system/expander.rs:46:21
   |
46 |                     span: *span,
   |                     ^^^^ field does not exist
   |
  ::: compiler/src/parser/ast.rs:99:5
   |
99 |     Call(Box<Expr>, Vec<Expr>),
   |     ---- `ast::Expr::Call` defined here
   |
help: `ast::Expr::Call` is a tuple variant, use the appropriate syntax
   |
43 -                 Ok(Expr::Call {
44 -                     func,
45 -                     args,
46 -                     span: *span,
47 -                 })
43 +                 Ok(Expr::Call(/* Box<ast::Expr> */, /* Vec<ast::Expr> */))
   |

error[E0559]: variant `ast::Expr::Block` has no field named `stmts`
   --> compiler/src/macro_system/expander.rs:54:21
    |
 54 |                     stmts,
    |                     ^^^^^ field does not exist
    |
   ::: compiler/src/parser/ast.rs:103:5
    |
103 |     Block(Vec<Stmt>),
    |     ----- `ast::Expr::Block` defined here
    |
help: `ast::Expr::Block` is a tuple variant, use the appropriate syntax
    |
 53 -                 Ok(Expr::Block {
 54 -                     stmts,
 55 -                     span: *span,
 56 -                 })
 53 +                 Ok(Expr::Block(/* Vec<ast::Stmt> */))
    |

error[E0559]: variant `ast::Expr::Block` has no field named `span`
   --> compiler/src/macro_system/expander.rs:55:21
    |
 55 |                     span: *span,
    |                     ^^^^ field does not exist
    |
   ::: compiler/src/parser/ast.rs:103:5
    |
103 |     Block(Vec<Stmt>),
    |     ----- `ast::Expr::Block` defined here
    |
help: `ast::Expr::Block` is a tuple variant, use the appropriate syntax
    |
 53 -                 Ok(Expr::Block {
 54 -                     stmts,
 55 -                     span: *span,
 56 -                 })
 53 +                 Ok(Expr::Block(/* Vec<ast::Stmt> */))
    |

error[E0769]: tuple variant `Stmt::Let` written as struct variant
  --> compiler/src/macro_system/expander.rs:67:13
   |
67 |             Stmt::Let { pattern, ty, init, span } => {
   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
help: use the tuple variant pattern syntax instead
   |
67 -             Stmt::Let { pattern, ty, init, span } => {
67 +             Stmt::Let(_, _, _) => {
   |

error[E0559]: variant `ast::Stmt::Let` has no field named `pattern`
  --> compiler/src/macro_system/expander.rs:73:21
   |
73 |                     pattern: pattern.clone(),
   |                     ^^^^^^^ field does not exist
   |
  ::: compiler/src/parser/ast.rs:87:5
   |
87 |     Let(String, Option<Type>, Option<Expr>),
   |     --- `ast::Stmt::Let` defined here
   |
help: `ast::Stmt::Let` is a tuple variant, use the appropriate syntax
   |
72 -                 Ok(Stmt::Let {
73 -                     pattern: pattern.clone(),
74 -                     ty: ty.clone(),
75 -                     init,
76 -                     span: *span,
77 -                 })
72 +                 Ok(Stmt::Let(/* String */, /* Option<ast::Type> */, /* Option<ast::Expr> */))
   |

error[E0559]: variant `ast::Stmt::Let` has no field named `ty`
  --> compiler/src/macro_system/expander.rs:74:21
   |
74 |                     ty: ty.clone(),
   |                     ^^ field does not exist
   |
  ::: compiler/src/parser/ast.rs:87:5
   |
87 |     Let(String, Option<Type>, Option<Expr>),
   |     --- `ast::Stmt::Let` defined here
   |
help: `ast::Stmt::Let` is a tuple variant, use the appropriate syntax
   |
72 -                 Ok(Stmt::Let {
73 -                     pattern: pattern.clone(),
74 -                     ty: ty.clone(),
75 -                     init,
76 -                     span: *span,
77 -                 })
72 +                 Ok(Stmt::Let(/* String */, /* Option<ast::Type> */, /* Option<ast::Expr> */))
   |

error[E0559]: variant `ast::Stmt::Let` has no field named `init`
  --> compiler/src/macro_system/expander.rs:75:21
   |
75 |                     init,
   |                     ^^^^ field does not exist
   |
  ::: compiler/src/parser/ast.rs:87:5
   |
87 |     Let(String, Option<Type>, Option<Expr>),
   |     --- `ast::Stmt::Let` defined here
   |
help: `ast::Stmt::Let` is a tuple variant, use the appropriate syntax
   |
72 -                 Ok(Stmt::Let {
73 -                     pattern: pattern.clone(),
74 -                     ty: ty.clone(),
75 -                     init,
76 -                     span: *span,
77 -                 })
72 +                 Ok(Stmt::Let(/* String */, /* Option<ast::Type> */, /* Option<ast::Expr> */))
   |

error[E0559]: variant `ast::Stmt::Let` has no field named `span`
  --> compiler/src/macro_system/expander.rs:76:21
   |
76 |                     span: *span,
   |                     ^^^^ field does not exist
   |
  ::: compiler/src/parser/ast.rs:87:5
   |
87 |     Let(String, Option<Type>, Option<Expr>),
   |     --- `ast::Stmt::Let` defined here
   |
help: `ast::Stmt::Let` is a tuple variant, use the appropriate syntax
   |
72 -                 Ok(Stmt::Let {
73 -                     pattern: pattern.clone(),
74 -                     ty: ty.clone(),
75 -                     init,
76 -                     span: *span,
77 -                 })
72 +                 Ok(Stmt::Let(/* String */, /* Option<ast::Type> */, /* Option<ast::Expr> */))
   |

error[E0308]: mismatched types
  --> compiler/src/macro_system/expander.rs:86:17
   |
86 |                 format!("macro expansion depth exceeded (max: {})", self.max_depth),
   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `String`
   |
   = note: this error originates in the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0277]: the trait bound `String: From<span::Span>` is not satisfied
  --> compiler/src/macro_system/expander.rs:87:17
   |
85 |             return Err(Error::new(
   |                        ---------- required by a bound introduced by this call
86 |                 format!("macro expansion depth exceeded (max: {})", self.max_depth),
87 |                 span,
   |                 ^^^^ the trait `From<span::Span>` is not implemented for `String`
   |
   = help: the following other types implement trait `From<T>`:
             `String` implements `From<&String>`
             `String` implements `From<&mut str>`
             `String` implements `From<&str>`
             `String` implements `From<Box<str>>`
             `String` implements `From<Cow<'_, str>>`
             `String` implements `From<char>`
             `String` implements `From<clap::Id>`
             `String` implements `From<clap::builder::Str>`
   = note: required for `span::Span` to implement `Into<String>`
note: required by a bound in `error::Error::new`
  --> compiler/src/error.rs:47:47
   |
47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
   |                                               ^^^^^^^^^^^^ required by this bound in `Error::new`

error[E0308]: mismatched types
  --> compiler/src/macro_system/expander.rs:92:39
   |
92 |             .ok_or_else(|| Error::new(format!("undefined macro: {}", name), span))?;
   |                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `String`
   |
   = note: this error originates in the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0277]: the trait bound `String: From<span::Span>` is not satisfied
  --> compiler/src/macro_system/expander.rs:92:77
   |
92 |             .ok_or_else(|| Error::new(format!("undefined macro: {}", name), span))?;
   |                            ----------                                       ^^^^ the trait `From<span::Span>` is not implemented for `String`
   |                            |
   |                            required by a bound introduced by this call
   |
   = help: the following other types implement trait `From<T>`:
             `String` implements `From<&String>`
             `String` implements `From<&mut str>`
             `String` implements `From<&str>`
             `String` implements `From<Box<str>>`
             `String` implements `From<Cow<'_, str>>`
             `String` implements `From<char>`
             `String` implements `From<clap::Id>`
             `String` implements `From<clap::builder::Str>`
   = note: required for `span::Span` to implement `Into<String>`
note: required by a bound in `error::Error::new`
  --> compiler/src/error.rs:47:47
   |
47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
   |                                               ^^^^^^^^^^^^ required by this bound in `Error::new`

error[E0308]: mismatched types
   --> compiler/src/macro_system/expander.rs:110:21
    |
110 |                     format!("no matching macro rule for {}", def.name),
    |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `String`
    |
    = note: this error originates in the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0277]: the trait bound `String: From<span::Span>` is not satisfied
   --> compiler/src/macro_system/expander.rs:111:21
    |
109 |                 Err(Error::new(
    |                     ---------- required by a bound introduced by this call
110 |                     format!("no matching macro rule for {}", def.name),
111 |                     span,
    |                     ^^^^ the trait `From<span::Span>` is not implemented for `String`
    |
    = help: the following other types implement trait `From<T>`:
              `String` implements `From<&String>`
              `String` implements `From<&mut str>`
              `String` implements `From<&str>`
              `String` implements `From<Box<str>>`
              `String` implements `From<Cow<'_, str>>`
              `String` implements `From<char>`
              `String` implements `From<clap::Id>`
              `String` implements `From<clap::builder::Str>`
    = note: required for `span::Span` to implement `Into<String>`
note: required by a bound in `error::Error::new`
   --> compiler/src/error.rs:47:47
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |                                               ^^^^^^^^^^^^ required by this bound in `Error::new`

error[E0277]: the trait bound `String: From<span::Span>` is not satisfied
   --> compiler/src/macro_system/expander.rs:116:73
    |
116 |                 Err(Error::new("procedural macros not yet implemented", span))
    |                     ----------                                          ^^^^ the trait `From<span::Span>` is not implemented for `String`
    |                     |
    |                     required by a bound introduced by this call
    |
    = help: the following other types implement trait `From<T>`:
              `String` implements `From<&String>`
              `String` implements `From<&mut str>`
              `String` implements `From<&str>`
              `String` implements `From<Box<str>>`
              `String` implements `From<Cow<'_, str>>`
              `String` implements `From<char>`
              `String` implements `From<clap::Id>`
              `String` implements `From<clap::builder::Str>`
    = note: required for `span::Span` to implement `Into<String>`
note: required by a bound in `error::Error::new`
   --> compiler/src/error.rs:47:47
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |                                               ^^^^^^^^^^^^ required by this bound in `Error::new`

error[E0308]: mismatched types
   --> compiler/src/macro_system/expander.rs:116:32
    |
116 |                 Err(Error::new("procedural macros not yet implemented", span))
    |                     ---------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `&str`
    |                     |
    |                     arguments to this function are incorrect
    |
note: associated function defined here
   --> compiler/src/error.rs:47:12
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |            ^^^ ---------------

error[E0559]: variant `ast::Expr::Block` has no field named `stmts`
   --> compiler/src/macro_system/expander.rs:224:13
    |
224 |             stmts: vec![],
    |             ^^^^^ field does not exist
    |
   ::: compiler/src/parser/ast.rs:103:5
    |
103 |     Block(Vec<Stmt>),
    |     ----- `ast::Expr::Block` defined here
    |
help: `ast::Expr::Block` is a tuple variant, use the appropriate syntax
    |
223 -         Ok(Expr::Block {
224 -             stmts: vec![],
225 -             span,
226 -         })
223 +         Ok(Expr::Block(/* Vec<ast::Stmt> */))
    |

error[E0559]: variant `ast::Expr::Block` has no field named `span`
   --> compiler/src/macro_system/expander.rs:225:13
    |
225 |             span,
    |             ^^^^ field does not exist
    |
   ::: compiler/src/parser/ast.rs:103:5
    |
103 |     Block(Vec<Stmt>),
    |     ----- `ast::Expr::Block` defined here
    |
help: `ast::Expr::Block` is a tuple variant, use the appropriate syntax
    |
223 -         Ok(Expr::Block {
224 -             stmts: vec![],
225 -             span,
226 -         })
223 +         Ok(Expr::Block(/* Vec<ast::Stmt> */))
    |

error[E0599]: no function or associated item named `dummy` found for struct `span::Span` in the current scope
   --> compiler/src/macro_system/mod.rs:132:29
    |
132 |                 span: Span::dummy(),
    |                             ^^^^^ function or associated item not found in `span::Span`
    |
   ::: compiler/src/span.rs:31:1
    |
 31 | pub struct Span {
    | --------------- function or associated item `dummy` not found for this struct
    |
note: if you're trying to build a new `span::Span`, consider using `span::Span::new` which returns `span::Span`
   --> compiler/src/span.rs:37:5
    |
 37 |     pub fn new(start: Position, end: Position) -> Self {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0599]: no function or associated item named `dummy` found for struct `span::Span` in the current scope
   --> compiler/src/macro_system/mod.rs:187:29
    |
187 |                 span: Span::dummy(),
    |                             ^^^^^ function or associated item not found in `span::Span`
    |
   ::: compiler/src/span.rs:31:1
    |
 31 | pub struct Span {
    | --------------- function or associated item `dummy` not found for this struct
    |
note: if you're trying to build a new `span::Span`, consider using `span::Span::new` which returns `span::Span`
   --> compiler/src/span.rs:37:5
    |
 37 |     pub fn new(start: Position, end: Position) -> Self {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0599]: no function or associated item named `dummy` found for struct `span::Span` in the current scope
   --> compiler/src/macro_system/mod.rs:209:29
    |
209 |                 span: Span::dummy(),
    |                             ^^^^^ function or associated item not found in `span::Span`
    |
   ::: compiler/src/span.rs:31:1
    |
 31 | pub struct Span {
    | --------------- function or associated item `dummy` not found for this struct
    |
note: if you're trying to build a new `span::Span`, consider using `span::Span::new` which returns `span::Span`
   --> compiler/src/span.rs:37:5
    |
 37 |     pub fn new(start: Position, end: Position) -> Self {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0282]: type annotations needed
   --> compiler/src/async_runtime/executor.rs:132:25
    |
132 |                         task.poll(&waker);
    |                         ^^^^ cannot infer type

error[E0599]: no function or associated item named `from_millis` found for struct `async_runtime::Duration` in the current scope
   --> compiler/src/async_runtime/executor.rs:135:49
    |
135 |                         Thread::sleep(Duration::from_millis(10));
    |                                                 ^^^^^^^^^^^ function or associated item not found in `async_runtime::Duration`
    |
   ::: compiler/src/async_runtime/mod.rs:142:1
    |
142 | pub struct Duration {
    | ------------------- function or associated item `from_millis` not found for this struct

error[E0026]: variant `ast::Expr::Literal` does not have a field named `value`
   --> compiler/src/verification/smt_solver.rs:109:29
    |
109 |             Expr::Literal { value, .. } => {
    |                             ^^^^^
    |                             |
    |                             variant `ast::Expr::Literal` does not have this field
    |                             help: `ast::Expr::Literal` has a field named `0`

error[E0599]: no variant named `Variable` found for enum `ast::Expr`
   --> compiler/src/verification/smt_solver.rs:116:19
    |
116 |             Expr::Variable { name, .. } => Ok(name.clone()),
    |                   ^^^^^^^^ variant not found in `ast::Expr`
    |
   ::: compiler/src/parser/ast.rs:94:1
    |
 94 | pub enum Expr {
    | ------------- variant `Variable` not found here

error[E0026]: variant `ast::Expr::Binary` does not have fields named `op`, `left`, `right`
   --> compiler/src/verification/smt_solver.rs:117:28
    |
117 |             Expr::Binary { op, left, right, .. } => {
    |                            ^^  ^^^^  ^^^^^ variant `ast::Expr::Binary` does not have these fields

error[E0026]: variant `ast::Expr::Unary` does not have fields named `op`, `operand`
   --> compiler/src/verification/smt_solver.rs:139:27
    |
139 |             Expr::Unary { op, operand, .. } => {
    |                           ^^  ^^^^^^^ variant `ast::Expr::Unary` does not have these fields

error[E0308]: mismatched types
   --> compiler/src/verification/smt_solver.rs:113:41
    |
113 |                     _ => Err(Error::new("Unsupported literal type for SMT", Span::dummy())),
    |                              ---------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `&str`
    |                              |
    |                              arguments to this function are incorrect
    |
note: associated function defined here
   --> compiler/src/error.rs:47:12
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |            ^^^ ---------------

error[E0308]: mismatched types
   --> compiler/src/verification/smt_solver.rs:134:48
    |
134 |                     _ => return Err(Error::new("Unsupported binary operator for SMT", Span::dummy())),
    |                                     ---------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `&str`
    |                                     |
    |                                     arguments to this function are incorrect
    |
note: associated function defined here
   --> compiler/src/error.rs:47:12
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |            ^^^ ---------------

error[E0308]: mismatched types
   --> compiler/src/verification/smt_solver.rs:145:48
    |
145 |                     _ => return Err(Error::new("Unsupported unary operator for SMT", Span::dummy())),
    |                                     ---------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `&str`
    |                                     |
    |                                     arguments to this function are incorrect
    |
note: associated function defined here
   --> compiler/src/error.rs:47:12
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |            ^^^ ---------------

error[E0308]: mismatched types
   --> compiler/src/verification/smt_solver.rs:150:33
    |
150 |             _ => Err(Error::new("Unsupported expression type for SMT", Span::dummy())),
    |                      ---------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `&str`
    |                      |
    |                      arguments to this function are incorrect
    |
note: associated function defined here
   --> compiler/src/error.rs:47:12
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |            ^^^ ---------------

error[E0599]: no variant named `Variable` found for enum `ast::Expr`
   --> compiler/src/verification/smt_solver.rs:164:19
    |
164 |             Expr::Variable { name, .. } => {
    |                   ^^^^^^^^ variant not found in `ast::Expr`
    |
   ::: compiler/src/parser/ast.rs:94:1
    |
 94 | pub enum Expr {
    | ------------- variant `Variable` not found here

error[E0026]: variant `ast::Expr::Binary` does not have fields named `left`, `right`
   --> compiler/src/verification/smt_solver.rs:167:28
    |
167 |             Expr::Binary { left, right, .. } => {
    |                            ^^^^  ^^^^^ variant `ast::Expr::Binary` does not have these fields

error[E0026]: variant `ast::Expr::Unary` does not have a field named `operand`
   --> compiler/src/verification/smt_solver.rs:171:27
    |
171 |             Expr::Unary { operand, .. } => {
    |                           ^^^^^^^ variant `ast::Expr::Unary` does not have this field

error[E0308]: mismatched types
   --> compiler/src/verification/smt_solver.rs:195:37
    |
195 |             .map_err(|e| Error::new(format!("Failed to spawn SMT solver: {}", e), Span::dummy()))?;
    |                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `String`
    |
    = note: this error originates in the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0308]: mismatched types
   --> compiler/src/verification/smt_solver.rs:199:41
    |
199 |                 .map_err(|e| Error::new(format!("Failed to write to SMT solver: {}", e), Span::dummy()))?;
    |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `String`
    |
    = note: this error originates in the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0308]: mismatched types
   --> compiler/src/verification/smt_solver.rs:203:37
    |
203 |             .map_err(|e| Error::new(format!("Failed to read SMT solver output: {}", e), Span::dummy()))?;
    |                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `String`
    |
    = note: this error originates in the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0599]: no method named `prove_postcondition` found for mutable reference `&mut FormalVerifier` in the current scope
   --> compiler/src/verification/mod.rs:115:30
    |
115 |             let proof = self.prove_postcondition(func, post)?;
    |                              ^^^^^^^^^^^^^^^^^^^
    |
help: there is a method `verify_postcondition` with a similar name
    |
115 -             let proof = self.prove_postcondition(func, post)?;
115 +             let proof = self.verify_postcondition(func, post)?;
    |

error[E0599]: no method named `check_memory_safety` found for mutable reference `&mut FormalVerifier` in the current scope
   --> compiler/src/verification/mod.rs:120:34
    |
120 |         let memory_safety = self.check_memory_safety(func)?;
    |                                  ^^^^^^^^^^^^^^^^^^^
    |
help: there is a method `check_null_safety` with a similar name
    |
120 -         let memory_safety = self.check_memory_safety(func)?;
120 +         let memory_safety = self.check_null_safety(func)?;
    |

error[E0599]: no method named `prove_invariant_init` found for mutable reference `&mut FormalVerifier` in the current scope
   --> compiler/src/verification/mod.rs:136:31
    |
136 |         let init_proof = self.prove_invariant_init(&invariant)?;
    |                               ^^^^^^^^^^^^^^^^^^^^
    |
help: there is a method `verify_invariant_init` with a similar name
    |
136 -         let init_proof = self.prove_invariant_init(&invariant)?;
136 +         let init_proof = self.verify_invariant_init(&invariant)?;
    |

error[E0599]: no method named `prove_invariant_maintained` found for mutable reference `&mut FormalVerifier` in the current scope
   --> compiler/src/verification/mod.rs:142:35
    |
142 |         let maintain_proof = self.prove_invariant_maintained(&invariant, loop_stmt)?;
    |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^ method not found in `&mut FormalVerifier`

error[E0609]: no field `attributes` on type `&ast::Function`
   --> compiler/src/verification/mod.rs:204:27
    |
204 |         for attr in &func.attributes {
    |                           ^^^^^^^^^^ unknown field
    |
    = note: available fields are: `name`, `generics`, `params`, `return_type`, `where_clause`, `body`

error[E0282]: type annotations needed
   --> compiler/src/verification/mod.rs:207:40
    |
207 |                     preconditions.push(expr.clone());
    |                                        ^^^^ cannot infer type

error[E0609]: no field `attributes` on type `&ast::Function`
   --> compiler/src/verification/mod.rs:219:27
    |
219 |         for attr in &func.attributes {
    |                           ^^^^^^^^^^ unknown field
    |
    = note: available fields are: `name`, `generics`, `params`, `return_type`, `where_clause`, `body`

error[E0282]: type annotations needed
   --> compiler/src/verification/mod.rs:222:41
    |
222 |                     postconditions.push(expr.clone());
    |                                         ^^^^ cannot infer type

error[E0026]: variant `ast::Stmt::Let` does not have fields named `pattern`, `init`
   --> compiler/src/gpu/mod.rs:243:25
    |
243 |             Stmt::Let { pattern, init, .. } => {
    |                         ^^^^^^^  ^^^^ variant `ast::Stmt::Let` does not have these fields

error[E0026]: variant `ast::Expr::Literal` does not have a field named `value`
   --> compiler/src/gpu/mod.rs:259:29
    |
259 |             Expr::Literal { value, .. } => {
    |                             ^^^^^
    |                             |
    |                             variant `ast::Expr::Literal` does not have this field
    |                             help: `ast::Expr::Literal` has a field named `0`

error[E0599]: no variant named `Variable` found for enum `ast::Expr`
   --> compiler/src/gpu/mod.rs:267:19
    |
267 |             Expr::Variable { name, .. } => Ok(name.clone()),
    |                   ^^^^^^^^ variant not found in `ast::Expr`
    |
   ::: compiler/src/parser/ast.rs:94:1
    |
 94 | pub enum Expr {
    | ------------- variant `Variable` not found here

error[E0026]: variant `ast::Expr::Binary` does not have fields named `op`, `left`, `right`
   --> compiler/src/gpu/mod.rs:268:28
    |
268 |             Expr::Binary { op, left, right, .. } => {
    |                            ^^  ^^^^  ^^^^^ variant `ast::Expr::Binary` does not have these fields

error[E0599]: no variant or associated item named `I32` found for enum `ast::Type` in the current scope
   --> compiler/src/gpu/mod.rs:304:19
    |
304 |             Type::I32 => Ok("int".to_string()),
    |                   ^^^ variant or associated item not found in `ast::Type`
    |
   ::: compiler/src/parser/ast.rs:73:1
    |
 73 | pub enum Type {
    | ------------- variant or associated item `I32` not found for this enum

error[E0599]: no variant or associated item named `I64` found for enum `ast::Type` in the current scope
   --> compiler/src/gpu/mod.rs:305:19
    |
305 |             Type::I64 => Ok("long".to_string()),
    |                   ^^^ variant or associated item not found in `ast::Type`
    |
   ::: compiler/src/parser/ast.rs:73:1
    |
 73 | pub enum Type {
    | ------------- variant or associated item `I64` not found for this enum

error[E0599]: no variant or associated item named `F32` found for enum `ast::Type` in the current scope
   --> compiler/src/gpu/mod.rs:306:19
    |
306 |             Type::F32 => Ok("float".to_string()),
    |                   ^^^ variant or associated item not found in `ast::Type`
    |
   ::: compiler/src/parser/ast.rs:73:1
    |
 73 | pub enum Type {
    | ------------- variant or associated item `F32` not found for this enum

error[E0599]: no variant or associated item named `F64` found for enum `ast::Type` in the current scope
   --> compiler/src/gpu/mod.rs:307:19
    |
307 |             Type::F64 => Ok("double".to_string()),
    |                   ^^^ variant or associated item not found in `ast::Type`
    |
   ::: compiler/src/parser/ast.rs:73:1
    |
 73 | pub enum Type {
    | ------------- variant or associated item `F64` not found for this enum

error[E0599]: no variant or associated item named `Pointer` found for enum `ast::Type` in the current scope
   --> compiler/src/gpu/mod.rs:308:19
    |
308 |             Type::Pointer(inner) => Ok(format!("{}*", self.cuda_type(inner)?)),
    |                   ^^^^^^^ variant or associated item not found in `ast::Type`
    |
   ::: compiler/src/parser/ast.rs:73:1
    |
 73 | pub enum Type {
    | ------------- variant or associated item `Pointer` not found for this enum

error[E0599]: no variant or associated item named `I32` found for enum `ast::Type` in the current scope
   --> compiler/src/gpu/mod.rs:315:19
    |
315 |             Type::I32 => Ok("device int*".to_string()),
    |                   ^^^ variant or associated item not found in `ast::Type`
    |
   ::: compiler/src/parser/ast.rs:73:1
    |
 73 | pub enum Type {
    | ------------- variant or associated item `I32` not found for this enum

error[E0599]: no variant or associated item named `I64` found for enum `ast::Type` in the current scope
   --> compiler/src/gpu/mod.rs:316:19
    |
316 |             Type::I64 => Ok("device long*".to_string()),
    |                   ^^^ variant or associated item not found in `ast::Type`
    |
   ::: compiler/src/parser/ast.rs:73:1
    |
 73 | pub enum Type {
    | ------------- variant or associated item `I64` not found for this enum

error[E0599]: no variant or associated item named `F32` found for enum `ast::Type` in the current scope
   --> compiler/src/gpu/mod.rs:317:19
    |
317 |             Type::F32 => Ok("device float*".to_string()),
    |                   ^^^ variant or associated item not found in `ast::Type`
    |
   ::: compiler/src/parser/ast.rs:73:1
    |
 73 | pub enum Type {
    | ------------- variant or associated item `F32` not found for this enum

error[E0599]: no variant or associated item named `F64` found for enum `ast::Type` in the current scope
   --> compiler/src/gpu/mod.rs:318:19
    |
318 |             Type::F64 => Ok("device double*".to_string()),
    |                   ^^^ variant or associated item not found in `ast::Type`
    |
   ::: compiler/src/parser/ast.rs:73:1
    |
 73 | pub enum Type {
    | ------------- variant or associated item `F64` not found for this enum

error[E0599]: no variant or associated item named `I32` found for enum `ast::Type` in the current scope
   --> compiler/src/gpu/mod.rs:325:19
    |
325 |             Type::I32 => Ok("int".to_string()),
    |                   ^^^ variant or associated item not found in `ast::Type`
    |
   ::: compiler/src/parser/ast.rs:73:1
    |
 73 | pub enum Type {
    | ------------- variant or associated item `I32` not found for this enum

error[E0599]: no variant or associated item named `I64` found for enum `ast::Type` in the current scope
   --> compiler/src/gpu/mod.rs:326:19
    |
326 |             Type::I64 => Ok("int64_t".to_string()),
    |                   ^^^ variant or associated item not found in `ast::Type`
    |
   ::: compiler/src/parser/ast.rs:73:1
    |
 73 | pub enum Type {
    | ------------- variant or associated item `I64` not found for this enum

error[E0599]: no variant or associated item named `F32` found for enum `ast::Type` in the current scope
   --> compiler/src/gpu/mod.rs:327:19
    |
327 |             Type::F32 => Ok("float".to_string()),
    |                   ^^^ variant or associated item not found in `ast::Type`
    |
   ::: compiler/src/parser/ast.rs:73:1
    |
 73 | pub enum Type {
    | ------------- variant or associated item `F32` not found for this enum

error[E0599]: no variant or associated item named `F64` found for enum `ast::Type` in the current scope
   --> compiler/src/gpu/mod.rs:328:19
    |
328 |             Type::F64 => Ok("double".to_string()),
    |                   ^^^ variant or associated item not found in `ast::Type`
    |
   ::: compiler/src/parser/ast.rs:73:1
    |
 73 | pub enum Type {
    | ------------- variant or associated item `F64` not found for this enum

error[E0599]: no variant or associated item named `I32` found for enum `ast::Type` in the current scope
   --> compiler/src/gpu/mod.rs:335:19
    |
335 |             Type::I32 => Ok("int*".to_string()),
    |                   ^^^ variant or associated item not found in `ast::Type`
    |
   ::: compiler/src/parser/ast.rs:73:1
    |
 73 | pub enum Type {
    | ------------- variant or associated item `I32` not found for this enum

error[E0599]: no variant or associated item named `I64` found for enum `ast::Type` in the current scope
   --> compiler/src/gpu/mod.rs:336:19
    |
336 |             Type::I64 => Ok("long*".to_string()),
    |                   ^^^ variant or associated item not found in `ast::Type`
    |
   ::: compiler/src/parser/ast.rs:73:1
    |
 73 | pub enum Type {
    | ------------- variant or associated item `I64` not found for this enum

error[E0599]: no variant or associated item named `F32` found for enum `ast::Type` in the current scope
   --> compiler/src/gpu/mod.rs:337:19
    |
337 |             Type::F32 => Ok("float*".to_string()),
    |                   ^^^ variant or associated item not found in `ast::Type`
    |
   ::: compiler/src/parser/ast.rs:73:1
    |
 73 | pub enum Type {
    | ------------- variant or associated item `F32` not found for this enum

error[E0599]: no variant or associated item named `F64` found for enum `ast::Type` in the current scope
   --> compiler/src/gpu/mod.rs:338:19
    |
338 |             Type::F64 => Ok("double*".to_string()),
    |                   ^^^ variant or associated item not found in `ast::Type`
    |
   ::: compiler/src/parser/ast.rs:73:1
    |
 73 | pub enum Type {
    | ------------- variant or associated item `F64` not found for this enum

error[E0026]: variant `ast::Expr::Literal` does not have a field named `value`
  --> compiler/src/consteval/mod.rs:61:29
   |
61 |             Expr::Literal { value, .. } => self.eval_literal(value),
   |                             ^^^^^
   |                             |
   |                             variant `ast::Expr::Literal` does not have this field
   |                             help: `ast::Expr::Literal` has a field named `0`

error[E0599]: no variant named `Variable` found for enum `ast::Expr`
  --> compiler/src/consteval/mod.rs:63:19
   |
63 |             Expr::Variable { name, .. } => {
   |                   ^^^^^^^^ variant not found in `ast::Expr`
   |
  ::: compiler/src/parser/ast.rs:94:1
   |
94 | pub enum Expr {
   | ------------- variant `Variable` not found here

error[E0026]: variant `ast::Expr::Binary` does not have fields named `op`, `left`, `right`
  --> compiler/src/consteval/mod.rs:72:28
   |
72 |             Expr::Binary { op, left, right, .. } => {
   |                            ^^  ^^^^  ^^^^^ variant `ast::Expr::Binary` does not have these fields

error[E0026]: variant `ast::Expr::Unary` does not have fields named `op`, `operand`
  --> compiler/src/consteval/mod.rs:78:27
   |
78 |             Expr::Unary { op, operand, .. } => {
   |                           ^^  ^^^^^^^ variant `ast::Expr::Unary` does not have these fields

error[E0026]: variant `ast::Expr::Call` does not have fields named `func`, `args`
  --> compiler/src/consteval/mod.rs:83:26
   |
83 |             Expr::Call { func, args, .. } => {
   |                          ^^^^  ^^^^ variant `ast::Expr::Call` does not have these fields

error[E0026]: variant `ast::Expr::If` does not have fields named `condition`, `then_branch`, `else_branch`
  --> compiler/src/consteval/mod.rs:87:24
   |
87 |             Expr::If { condition, then_branch, else_branch, .. } => {
   |                        ^^^^^^^^^  ^^^^^^^^^^^  ^^^^^^^^^^^ variant `ast::Expr::If` does not have these fields

error[E0026]: variant `ast::Expr::Array` does not have a field named `elements`
  --> compiler/src/consteval/mod.rs:98:27
   |
98 |             Expr::Array { elements, .. } => {
   |                           ^^^^^^^^
   |                           |
   |                           variant `ast::Expr::Array` does not have this field
   |                           help: `ast::Expr::Array` has a field named `0`

error[E0308]: mismatched types
  --> compiler/src/consteval/mod.rs:67:25
   |
67 |                         format!("Undefined constant: {}", name),
   |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `String`
   |
   = note: this error originates in the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0308]: mismatched types
   --> compiler/src/consteval/mod.rs:107:17
    |
106 |             _ => Err(Error::new(
    |                      ---------- arguments to this function are incorrect
107 |                 "Expression cannot be evaluated at compile time",
    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `&str`
    |
note: associated function defined here
   --> compiler/src/error.rs:47:12
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |            ^^^ ---------------

error[E0308]: mismatched types
   --> compiler/src/consteval/mod.rs:132:51
    |
132 | ...                   return Err(Error::new("Division by zero", Span::dummy()));
    |                                  ---------- ^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `&str`
    |                                  |
    |                                  arguments to this function are incorrect
    |
note: associated function defined here
   --> compiler/src/error.rs:47:12
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |            ^^^ ---------------

error[E0308]: mismatched types
   --> compiler/src/consteval/mod.rs:148:48
    |
148 |                     _ => return Err(Error::new("Unsupported binary operation", Span::dummy())),
    |                                     ---------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `&str`
    |                                     |
    |                                     arguments to this function are incorrect
    |
note: associated function defined here
   --> compiler/src/error.rs:47:12
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |            ^^^ ---------------

error[E0308]: mismatched types
   --> compiler/src/consteval/mod.rs:165:48
    |
165 |                     _ => return Err(Error::new("Unsupported binary operation", Span::dummy())),
    |                                     ---------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `&str`
    |                                     |
    |                                     arguments to this function are incorrect
    |
note: associated function defined here
   --> compiler/src/error.rs:47:12
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |            ^^^ ---------------

error[E0308]: mismatched types
   --> compiler/src/consteval/mod.rs:176:48
    |
176 |                     _ => return Err(Error::new("Unsupported binary operation", Span::dummy())),
    |                                     ---------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `&str`
    |                                     |
    |                                     arguments to this function are incorrect
    |
note: associated function defined here
   --> compiler/src/error.rs:47:12
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |            ^^^ ---------------

error[E0308]: mismatched types
   --> compiler/src/consteval/mod.rs:181:33
    |
181 |             _ => Err(Error::new("Type mismatch in binary operation", Span::dummy())),
    |                      ---------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `&str`
    |                      |
    |                      arguments to this function are incorrect
    |
note: associated function defined here
   --> compiler/src/error.rs:47:12
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |            ^^^ ---------------

error[E0308]: mismatched types
   --> compiler/src/consteval/mod.rs:192:48
    |
192 |                     _ => return Err(Error::new("Unsupported unary operation", Span::dummy())),
    |                                     ---------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `&str`
    |                                     |
    |                                     arguments to this function are incorrect
    |
note: associated function defined here
   --> compiler/src/error.rs:47:12
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |            ^^^ ---------------

error[E0308]: mismatched types
   --> compiler/src/consteval/mod.rs:200:48
    |
200 |                     _ => return Err(Error::new("Unsupported unary operation", Span::dummy())),
    |                                     ---------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `&str`
    |                                     |
    |                                     arguments to this function are incorrect
    |
note: associated function defined here
   --> compiler/src/error.rs:47:12
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |            ^^^ ---------------

error[E0308]: mismatched types
   --> compiler/src/consteval/mod.rs:208:48
    |
208 |                     _ => return Err(Error::new("Unsupported unary operation", Span::dummy())),
    |                                     ---------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `&str`
    |                                     |
    |                                     arguments to this function are incorrect
    |
note: associated function defined here
   --> compiler/src/error.rs:47:12
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |            ^^^ ---------------

error[E0308]: mismatched types
   --> compiler/src/consteval/mod.rs:213:33
    |
213 |             _ => Err(Error::new("Type mismatch in unary operation", Span::dummy())),
    |                      ---------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `&str`
    |                      |
    |                      arguments to this function are incorrect
    |
note: associated function defined here
   --> compiler/src/error.rs:47:12
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |            ^^^ ---------------

error[E0599]: no variant named `Variable` found for enum `ast::Expr`
   --> compiler/src/consteval/mod.rs:220:19
    |
220 |             Expr::Variable { name, .. } => name,
    |                   ^^^^^^^^ variant not found in `ast::Expr`
    |
   ::: compiler/src/parser/ast.rs:94:1
    |
 94 | pub enum Expr {
    | ------------- variant `Variable` not found here

error[E0308]: mismatched types
   --> compiler/src/consteval/mod.rs:221:40
    |
221 |             _ => return Err(Error::new("Invalid function call", Span::dummy())),
    |                             ---------- ^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `&str`
    |                             |
    |                             arguments to this function are incorrect
    |
note: associated function defined here
   --> compiler/src/error.rs:47:12
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |            ^^^ ---------------

error[E0308]: mismatched types
   --> compiler/src/consteval/mod.rs:238:17
    |
238 |                 format!("Unknown compile-time function: {}", func_name),
    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `String`
    |
    = note: this error originates in the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0308]: mismatched types
   --> compiler/src/consteval/mod.rs:246:35
    |
246 |             return Err(Error::new("abs expects 1 argument", Span::dummy()));
    |                        ---------- ^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `&str`
    |                        |
    |                        arguments to this function are incorrect
    |
note: associated function defined here
   --> compiler/src/error.rs:47:12
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |            ^^^ ---------------

error[E0308]: mismatched types
   --> compiler/src/consteval/mod.rs:252:33
    |
252 |             _ => Err(Error::new("abs expects numeric argument", Span::dummy())),
    |                      ---------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `&str`
    |                      |
    |                      arguments to this function are incorrect
    |
note: associated function defined here
   --> compiler/src/error.rs:47:12
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |            ^^^ ---------------

error[E0308]: mismatched types
   --> compiler/src/consteval/mod.rs:258:35
    |
258 |             return Err(Error::new("min expects 2 arguments", Span::dummy()));
    |                        ---------- ^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `&str`
    |                        |
    |                        arguments to this function are incorrect
    |
note: associated function defined here
   --> compiler/src/error.rs:47:12
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |            ^^^ ---------------

error[E0308]: mismatched types
   --> compiler/src/consteval/mod.rs:264:33
    |
264 |             _ => Err(Error::new("min expects numeric arguments", Span::dummy())),
    |                      ---------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `&str`
    |                      |
    |                      arguments to this function are incorrect
    |
note: associated function defined here
   --> compiler/src/error.rs:47:12
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |            ^^^ ---------------

error[E0308]: mismatched types
   --> compiler/src/consteval/mod.rs:270:35
    |
270 |             return Err(Error::new("max expects 2 arguments", Span::dummy()));
    |                        ---------- ^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `&str`
    |                        |
    |                        arguments to this function are incorrect
    |
note: associated function defined here
   --> compiler/src/error.rs:47:12
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |            ^^^ ---------------

error[E0308]: mismatched types
   --> compiler/src/consteval/mod.rs:276:33
    |
276 |             _ => Err(Error::new("max expects numeric arguments", Span::dummy())),
    |                      ---------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `&str`
    |                      |
    |                      arguments to this function are incorrect
    |
note: associated function defined here
   --> compiler/src/error.rs:47:12
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |            ^^^ ---------------

error[E0308]: mismatched types
   --> compiler/src/consteval/mod.rs:282:35
    |
282 |             return Err(Error::new("pow expects 2 arguments", Span::dummy()));
    |                        ---------- ^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `&str`
    |                        |
    |                        arguments to this function are incorrect
    |
note: associated function defined here
   --> compiler/src/error.rs:47:12
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |            ^^^ ---------------

error[E0308]: mismatched types
   --> compiler/src/consteval/mod.rs:291:43
    |
291 |                     return Err(Error::new("Negative exponent for integer pow", Span::dummy()));
    |                                ---------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `&str`
    |                                |
    |                                arguments to this function are incorrect
    |
note: associated function defined here
   --> compiler/src/error.rs:47:12
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |            ^^^ ---------------

error[E0308]: mismatched types
   --> compiler/src/consteval/mod.rs:295:33
    |
295 |             _ => Err(Error::new("pow expects numeric arguments", Span::dummy())),
    |                      ---------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `&str`
    |                      |
    |                      arguments to this function are incorrect
    |
note: associated function defined here
   --> compiler/src/error.rs:47:12
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |            ^^^ ---------------

error[E0308]: mismatched types
   --> compiler/src/consteval/mod.rs:301:35
    |
301 |             return Err(Error::new("sqrt expects 1 argument", Span::dummy()));
    |                        ---------- ^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `&str`
    |                        |
    |                        arguments to this function are incorrect
    |
note: associated function defined here
   --> compiler/src/error.rs:47:12
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |            ^^^ ---------------

error[E0308]: mismatched types
   --> compiler/src/consteval/mod.rs:307:43
    |
307 |                     return Err(Error::new("sqrt of negative number", Span::dummy()));
    |                                ---------- ^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `&str`
    |                                |
    |                                arguments to this function are incorrect
    |
note: associated function defined here
   --> compiler/src/error.rs:47:12
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |            ^^^ ---------------

error[E0308]: mismatched types
   --> compiler/src/consteval/mod.rs:311:33
    |
311 |             _ => Err(Error::new("sqrt expects float argument", Span::dummy())),
    |                      ---------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `ErrorKind`, found `&str`
    |                      |
    |                      arguments to this function are incorrect
    |
note: associated function defined here
   --> compiler/src/error.rs:47:12
    |
 47 |     pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
    |            ^^^ ---------------

warning: unused variable: `func`
   --> compiler/src/verification/mod.rs:194:41
    |
194 |     fn check_overflow_safety(&mut self, func: &Function) -> Result<bool> {
    |                                         ^^^^ help: if this is intentional, prefix it with an underscore: `_func`
    |
    = note: `#[warn(unused_variables)]` (part of `#[warn(unused)]`) on by default

error[E0594]: cannot assign to `proof.status`, as `proof` is not declared as mutable
   --> compiler/src/verification/mod.rs:247:13
    |
247 |             proof.status = ProofStatus::Proven;
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ cannot assign
    |
help: consider changing this to be mutable
    |
237 |         let mut proof = Proof {
    |             +++

error[E0594]: cannot assign to `proof.status`, as `proof` is not declared as mutable
   --> compiler/src/verification/mod.rs:249:13
    |
249 |             proof.status = ProofStatus::Failed;
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ cannot assign
    |
help: consider changing this to be mutable
    |
237 |         let mut proof = Proof {
    |             +++

warning: variable does not need to be mutable
   --> compiler/src/verification/mod.rs:268:13
    |
268 |         let mut proof = Proof {
    |             ----^^^^^
    |             |
    |             help: remove this `mut`
    |
    = note: `#[warn(unused_mut)]` (part of `#[warn(unused)]`) on by default

Some errors have detailed explanations: E0023, E0026, E0027, E0277, E0282, E0308, E0412, E0432, E0433...
For more information about an error, try `rustc --explain E0023`.
warning: `vez_compiler` (lib) generated 14 warnings
error: could not compile `vez_compiler` (lib) due to 288 previous errors; 14 warnings emitted
[0;32mâœ“[0m Documentation built successfully

==========================================
9. File Structure Verification
==========================================
[1;33mâ†’[0m Checking source file count...
[0;32mâœ“[0m Found 50 Rust source files
[1;33mâ†’[0m Checking total lines of code...
[0;32mâœ“[0m Total lines of code: 13179
[1;33mâ†’[0m Checking for README...
[0;32mâœ“[0m README.md exists
[1;33mâ†’[0m Checking for LICENSE...
[0;32mâœ“[0m LICENSE file exists

==========================================
10. Integration Tests
==========================================
[1;33mâ†’[0m Creating test VeZ source file...
[0;32mâœ“[0m Test source file created
[1;33mâ†’[0m Testing compiler on test file...
./comprehensive_test.sh: line 322: ./target/debug/vezc: No such file or directory
[0;32mâœ“[0m Compiler accepted test file

==========================================
Test Summary
==========================================

[0;32mPassed:[0m   21
[0;31mFailed:[0m   1
[1;33mWarnings:[0m 17

[0;31m==========================================
âœ— SOME TESTS FAILED
==========================================\033[0m

Failed tests:
  [0;31mâœ—[0m vezc binary not found

Detailed logs saved:
  - build_lib.log
  - build_bin.log
  - build_workspace.log
  - test_compiler.log
  - test_workspace.log
  - check.log

