//! HTML documentation renderer

use std::path::PathBuf;
use super::{Documentation, DocResult, DocRenderer, ItemDoc, ItemKind, render};

pub struct HtmlRenderer {
    theme: HtmlTheme,
}

impl HtmlRenderer {
    pub fn new() -> Self {
        HtmlRenderer {
            theme: HtmlTheme::default(),
        }
    }

    pub fn with_theme(mut self, theme: HtmlTheme) -> Self {
        self.theme = theme;
        self
    }
}

impl Default for HtmlRenderer {
    fn default() -> Self {
        Self::new()
    }
}

impl DocRenderer for HtmlRenderer {
    fn render(&self, docs: &Documentation) -> DocResult<String> {
        let mut html = String::new();
        
        html.push_str(&self.render_header(&docs.module.name));
        
        if let Some(desc) = &docs.module.description {
            html.push_str(&format!(
                "<section class=\"module-description\">\n<p>{}</p>\n</section>\n",
                render::escape_html(desc)
            ));
        }
        
        html.push_str("<nav class=\"toc\">\n<h2>Contents</h2>\n<ul>\n");
        
        for item in &docs.items {
            let slug = render::slugify(&item.name);
            let kind = item_kind_str(&item.kind);
            html.push_str(&format!(
                "<li><a href=\"#{}\">{} {}</a></li>\n",
                slug, kind, render::escape_html(&item.name)
            ));
        }
        
        html.push_str("</ul>\n</nav>\n");
        
        html.push_str("<main class=\"items\">\n");
        
        for item in &docs.items {
            html.push_str(&self.render_item(item));
        }
        
        html.push_str("</main>\n");
        html.push_str(&self.render_footer());
        
        Ok(html)
    }

    fn render_index(&self, files: &[PathBuf]) -> DocResult<String> {
        let mut html = String::new();
        
        html.push_str(&self.render_header("VeZ Documentation"));
        
        html.push_str("<main class=\"index\">\n");
        html.push_str("<h1>VeZ Documentation</h1>\n");
        html.push_str("<ul class=\"module-list\">\n");
        
        for file in files {
            if let Some(name) = file.file_stem().and_then(|s| s.to_str()) {
                if name != "index" {
                    html.push_str(&format!(
                        "<li><a href=\"{}.html\">{}</a></li>\n",
                        name, name
                    ));
                }
            }
        }
        
        html.push_str("</ul>\n");
        html.push_str("</main>\n");
        html.push_str(&self.render_footer());
        
        Ok(html)
    }

    fn file_extension(&self) -> &str {
        "html"
    }
}

impl HtmlRenderer {
    fn render_header(&self, title: &str) -> String {
        format!(
            r#"<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>{} - VeZ Documentation</title>
<style>
{}
</style>
</head>
<body>
<header>
<h1><a href="index.html">VeZ</a></h1>
</header>
"#,
            render::escape_html(title),
            self.theme.css()
        )
    }

    fn render_footer(&self) -> String {
        String::from(
            r#"<footer>
<p>Generated by VeZ Documentation Generator</p>
</footer>
</body>
</html>"#
        )
    }

    fn render_item(&self, item: &ItemDoc) -> String {
        let mut html = String::new();
        let slug = render::slugify(&item.name);
        let kind = item_kind_str(&item.kind);
        
        html.push_str(&format!(
            "<section id=\"{}\" class=\"item {}\">\n",
            slug,
            kind.to_lowercase()
        ));
        
        html.push_str(&format!(
            "<h{}><span class=\"kind\">{}</span> <code>{}</code></h{}>\n",
            2, kind, render::escape_html(&item.name), 2
        ));
        
        if let Some(desc) = &item.description {
            html.push_str(&format!(
                "<div class=\"description\"><p>{}</p></div>\n",
                render::escape_html(desc)
            ));
        }
        
        if !item.params.is_empty() {
            html.push_str("<div class=\"params\">\n<h3>Parameters</h3>\n<dl>\n");
            for param in &item.params {
                html.push_str(&format!(
                    "<dt><code>{}</code>: <span class=\"type\">{}</span></dt>\n",
                    render::escape_html(&param.name),
                    render::escape_html(&param.type_name)
                ));
                if let Some(desc) = &param.description {
                    html.push_str(&format!("<dd>{}</dd>\n", render::escape_html(desc)));
                }
            }
            html.push_str("</dl>\n</div>\n");
        }
        
        if let Some(ret) = &item.returns {
            html.push_str(&format!(
                "<div class=\"returns\">\n<h3>Returns</h3>\n<p><span class=\"type\">{}</span>",
                render::escape_html(&ret.type_name)
            ));
            if let Some(desc) = &ret.description {
                html.push_str(&format!(" - {}", render::escape_html(desc)));
            }
            html.push_str("</p>\n</div>\n");
        }
        
        if !item.examples.is_empty() {
            html.push_str("<div class=\"examples\">\n<h3>Examples</h3>\n");
            for example in &item.examples {
                if let Some(desc) = &example.description {
                    html.push_str(&format!("<p>{}</p>\n", render::escape_html(desc)));
                }
                html.push_str(&format!(
                    "<pre><code class=\"language-{}\">{}</code></pre>\n",
                    example.language,
                    render::escape_html(&example.code)
                ));
            }
            html.push_str("</div>\n");
        }
        
        html.push_str(&format!(
            "<div class=\"source\"><a href=\"#L{}\">Source</a></div>\n",
            item.source_line
        ));
        
        html.push_str("</section>\n");
        
        html
    }
}

fn item_kind_str(kind: &ItemKind) -> &'static str {
    match kind {
        ItemKind::Function => "Function",
        ItemKind::Struct => "Struct",
        ItemKind::Enum => "Enum",
        ItemKind::Trait => "Trait",
        ItemKind::Const => "Const",
        ItemKind::Static => "Static",
        ItemKind::Type => "Type",
        ItemKind::Module => "Module",
    }
}

pub struct HtmlTheme {
    name: String,
}

impl HtmlTheme {
    pub fn new(name: &str) -> Self {
        HtmlTheme {
            name: name.to_string(),
        }
    }

    pub fn css(&self) -> &'static str {
        r#"
:root {
    --bg-color: #ffffff;
    --text-color: #333333;
    --link-color: #0066cc;
    --code-bg: #f5f5f5;
    --border-color: #e0e0e0;
}
body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
    line-height: 1.6;
    max-width: 1200px;
    margin: 0 auto;
    padding: 20px;
    color: var(--text-color);
}
header {
    border-bottom: 1px solid var(--border-color);
    padding-bottom: 10px;
    margin-bottom: 20px;
}
header h1 a {
    color: var(--text-color);
    text-decoration: none;
}
code, pre {
    font-family: 'Fira Code', 'Consolas', monospace;
    background: var(--code-bg);
    border-radius: 4px;
}
pre {
    padding: 15px;
    overflow-x: auto;
}
.item {
    margin-bottom: 30px;
    padding-bottom: 20px;
    border-bottom: 1px solid var(--border-color);
}
.kind {
    font-size: 0.8em;
    color: #666;
    text-transform: uppercase;
}
.type {
    color: #0066cc;
}
.toc {
    background: var(--code-bg);
    padding: 15px;
    border-radius: 4px;
    margin-bottom: 30px;
}
.toc ul {
    list-style: none;
    padding-left: 0;
}
"#
    }
}

impl Default for HtmlTheme {
    fn default() -> Self {
        HtmlTheme::new("default")
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_html_renderer_header() {
        let renderer = HtmlRenderer::new();
        let html = renderer.render_header("Test Module");
        assert!(html.contains("<title>Test Module - VeZ Documentation</title>"));
    }

    #[test]
    fn test_item_kind_str() {
        assert_eq!(item_kind_str(&ItemKind::Function), "Function");
        assert_eq!(item_kind_str(&ItemKind::Struct), "Struct");
    }
}
